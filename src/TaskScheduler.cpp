#include "TaskScheduler.h"
#include "hungarian.h"
#include "scheduler.h"
#include "const.h"


#include <Objects/Basic/time.hpp>
#include <Objects/Environment/environment.hpp>

#include <settings.hpp>


extern void sigint_handler(int);

/**
 * Initializes the task scheduler with a given time limit for preprocessing.
 *
 * This function prepares the task scheduler by allocating up to half of the given preprocessing time limit
 * and adjust for a specified tolerance to account for potential timing errors.
 * It ensures that initialization does not exceed the allocated time.
 *
 * @param preprocess_time_limit The total time limit allocated for preprocessing (in milliseconds).
 *
 */
void TaskScheduler::initialize(int preprocess_time_limit)
{
#ifdef ENABLE_DEFAULT_SCHEDULER
    clock_t start = clock();
    //give at most half of the entry time_limit to scheduler;
    //-SCHEDULER_TIMELIMIT_TOLERANCE for timing error tolerance
    // 1000ms是留给默认路径规划函数初始化的时间
    int limit = preprocess_time_limit - DefaultPlanner::SCHEDULER_TIMELIMIT_TOLERANCE - 1000;
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(limit);
    DefaultPlanner::schedule_initialize(limit, env);
    // cout << "num task initial: " << env->new_tasks.size() << endl; // 由于是0, 所以无法预分配

    agent_task.resize(env->num_of_agents); // initialize all agents to free state
    task_wait.resize(110000, 0);
    task_lengths.resize(130000, 99999);
    radius_count_agent = (env->rows + env->cols) / 16;

    /*
    if (env->map_name[0] == 's' || env->map_name[0] == 'w')
    {
        cout << "sort and ware highway" << endl;

        // even row delete before
        // cout << "even row global_neighbors[62056] size before: " << DefaultPlanner::global_neighbors[62056].size() << endl;
        // odd row delete before
        // cout << "odd row global_neighbors[60855] size before: " << DefaultPlanner::global_neighbors[60855].size() << endl;

        build_row_highway_delete(endtime);

        // even row delete after
        // cout << "even row global_neighbors[62056] size after: " << DefaultPlanner::global_neighbors[62056].size() << endl;
        // odd row delete after
        // cout << "odd row global_neighbors[60855] size after: " << DefaultPlanner::global_neighbors[60855].size() << endl;


        // cout << "even column global_neighbors[47451] size before: " << DefaultPlanner::global_neighbors[47451].size() << endl;
        // cout << "odd column global_neighbors[33971] size before: " << DefaultPlanner::global_neighbors[33971].size() << endl;

        build_column_highway_delete(endtime);

        // cout << "even column global_neighbors[47451] size after: " << DefaultPlanner::global_neighbors[47451].size() << endl;
        // cout << "odd column global_neighbors[33971] size after: " << DefaultPlanner::global_neighbors[33971].size() << endl;

        // build_row_highway_add(endtime);
        // cout << "extra add size: " << extra_add.size() << endl;

        // build_row_highway_compute(endtime);

        // build_column_highway_add(endtime);
        // cout << "extra add size: " << extra_add.size() << endl;

        for (int i = 0; i < env->rows * env->cols; i++)
        {
            if (env->map[i] == 0)
            {
                DefaultPlanner::global_heuristictable.at(i).htable.resize(env->map.size(), MAX_TIMESTEP);

                for (int j = 0; j < env->rows * env->cols; j++)
                {
                    if (env->map[j] == 0)
                    {
                        DefaultPlanner::global_heuristictable.at(i).htable[j] = DefaultPlanner::manhattanDistance(i, j, env);
                    }
                }
            }
        }
    }
     */

    if(env->map.size() <= 128 * 128)
    {
        // Random 1 2 3 4 5
        small_region_column = 8; // (历史统计)(大)每个region所占的列数
        small_region_row = 8; // (历史统计)(大)每个region所占的行数

        large_region_column = small_region_column * 2;
        large_region_row = small_region_row * 2;
    }
    else
    {
        // choose method according to agent num, 2048 as separator
        // CITY-01
        if(env->curr_states.size() <= 2048)
        {
            small_region_column = 24; // (历史统计)(大)每个region所占的列数
            small_region_row = 24; // (历史统计)(大)每个region所占的行数

            large_region_column = small_region_column * 2;
            large_region_row = small_region_row * 2;
        }
        else
        {
            // 用8192作为adaptive_jam_middle_current_goal_task_circle_count和default的分界点，看看能不能把sortation和warehouse分离出来。
            if(env->curr_states.size() <= 8192) // CITY-02 and GAME
            {
                // CITY-02
                if(env->curr_states.size() <= 4096)
                {
                    small_region_column = 24; // (历史统计)(大)每个region所占的列数
                    small_region_row = 24; // (历史统计)(大)每个region所占的行数

                    large_region_column = small_region_column * 2;
                    large_region_row = small_region_row * 2;
                }
                else // GAME
                {
                    small_region_column = 24; // (历史统计)(大)每个region所占的列数
                    small_region_row = 24; // (历史统计)(大)每个region所占的行数

                    large_region_column = small_region_column * 2;
                    large_region_row = small_region_row * 2;
                }
            }
            else // SORTATION and WAREHOUSE
            {
                if (env->map_name[0] == 's')
                {
                    small_region_column = 12; // (历史统计)(大)每个region所占的列数
                    small_region_row = 12; // (历史统计)(大)每个region所占的行数

                    large_region_column = small_region_column * 2;
                    large_region_row = small_region_row * 2;
                }
                else if (env->map_name[0] == 'w')
                {
                    small_region_column = 12; // (历史统计)(大)每个region所占的列数
                    small_region_row = 12; // (历史统计)(大)每个region所占的行数

                    large_region_column = small_region_column * 2;
                    large_region_row = small_region_row * 2;
                }
            }
        }
    }

    /*
    small_region_column = 12; // (历史统计)(大)每个region所占的列数
    small_region_row = 12; // (历史统计)(大)每个region所占的行数

    large_region_column = small_region_column * 2;
    large_region_row = small_region_row * 2;
    //*/

    // 地图有几列region
    num_small_region_column = std::ceil((double)env->cols / small_region_column);
    // 地图有几行region
    num_small_region_row = std::ceil((double)env->rows / small_region_row);

    // cout << "num region column: " << num_small_region_column << endl;
    // cout << "num region row: " << num_small_region_row << endl;

    // 地图有几列region
    num_large_region_column = std::ceil((double)env->cols / large_region_column);
    // 地图有几行region
    num_large_region_row = std::ceil((double)env->rows / large_region_row);

    small_region_wait_num.resize(num_small_region_column * num_small_region_row, 0); // 每个区域历史等待点的数量初始化为0
    small_region_cell_num.resize(num_small_region_column * num_small_region_row, 0); // 每个区域地图点的数量初始化为0
    small_region_blank_num.resize(num_small_region_column * num_small_region_row, 0); // 每个区域空点的数量初始化为0
    small_region_obstacle_num.resize(num_small_region_column * num_small_region_row, 0); // 每个区域障碍物的数量初始化为0

    large_region_wait_num.resize(num_large_region_column * num_large_region_row, 0); // 每个区域当下agent的数量初始化为0
    large_region_blank_num.resize(num_large_region_column * num_large_region_row, 0); // 每个区域当下agent的数量初始化为0

    for (int i = 0; i < env->rows; i++)
    {
        for (int j = 0; j < env->cols; j++)
        {
            int cell_loc = i * env->cols + j;
            // cout << cell_loc << " ";
            int cell_loc_x = cell_loc % env->cols;
            int cell_loc_y = cell_loc / env->cols;

            // 历史region
            int cell_region_x = cell_loc_x / small_region_column;
            int cell_region_y = cell_loc_y / small_region_row;

            small_region_cell_num[cell_region_y * num_small_region_column + cell_region_x]++;

            if (env->map[cell_loc] == 0)
            {
                small_region_blank_num[cell_region_y * num_small_region_column + cell_region_x]++;
            }
            else if (env->map[cell_loc] == 1)
            {
                small_region_obstacle_num[cell_region_y * num_small_region_column + cell_region_x]++;
            }

            // 当下region
            int current_cell_region_x = cell_loc_x / large_region_column;
            int current_cell_region_y = cell_loc_y / large_region_row;

            if (env->map[cell_loc] == 0)
            {
                large_region_blank_num[current_cell_region_y * num_large_region_column + current_cell_region_x]++;
            }
        }
    }

    /*
    cout << "region cell num: " << endl;
    for (auto const& element : small_region_cell_num)
    {
        cout << element << " ";
    }
    cout << endl;

    cout << "region blank num: " << endl;
    for (auto const& element : small_region_blank_num)
    {
        cout << element << " ";
    }
    cout << endl;

    cout << "region obstacle num: " << endl;
    for (auto const& element : small_region_obstacle_num)
    {
        cout << element << " ";
    }
    cout << endl;
    */

    // test fixed queue
    /*
    FixedQueue queue(3); // 长度固定为3

    // 创建一些长度为5的vector<int>元素
    std::vector<std::vector<int>> test_data = {
        {1, 2, 3, 4, 5},
        {6, 7, 8, 9, 10},
        {11, 12, 13, 14, 15},
        {16, 17, 18, 19, 20}
    };

    for (const auto& vec : test_data) {
        auto removed = queue.push(vec); // 添加元素，可能移除旧元素
        if (!removed.empty()) {
            std::cout << "Removed: [ ";
            for (int val : removed) {
                std::cout << val << " ";
            }
            std::cout << "]" << std::endl;
        }
        queue.print();
    }
    */
    period_small_region_wait_num.set_max_size(100); // 100个时间步内的small_region_wait_num信息
    period_large_region_wait_num.set_max_size(100); // 100个时间步内的large_region_wait_num信息

    prev_states.resize(env->num_of_agents, State{ -1, -1, -1 });

    // compute map point dist as many as possible
    // compute_map_point_dist(endtime);
    // compute_map_point_dist_symmetry(endtime);

    // rhcr_initialize(); // 带旋转启发式的初始化

    // compute_map_point_dist_reverse(endtime);

    cout << "Scheduler initialize Time Usage: " <<  ((float)(clock() - start))/CLOCKS_PER_SEC <<endl;
#else
    init_environment(*env);
#endif
}

// 寻找grid一行中最大连续0的个数
std::tuple<int, int, int> TaskScheduler::find_longest_zeros(const std::vector<int>& vec)
{
    int max_length = 0;       // 最大连续0的长度
    int start_index = -1;     // 最大连续0的起点索引
    int end_index = -1;       // 最大连续0的终点索引

    int current_start = -1;   // 当前连续0的起点索引
    int current_length = 0;   // 当前连续0的长度

    for (int i = 0; i < vec.size(); ++i) {
        if (vec[i] == 0) {
            // 如果是0，更新当前连续0的长度
            if (current_length == 0) {
                current_start = i;  // 标记当前连续0的起点
            }
            current_length++;

            // 如果当前连续0长度超过最大长度，则更新最大长度和起终点
            if (current_length > max_length) {
                max_length = current_length;
                start_index = current_start;
                end_index = i;
            }
        }
        else {
            // 如果不是0，重置当前连续0的长度
            current_length = 0;
        }
    }

    return { max_length, start_index, end_index };
}

void TaskScheduler::build_row_highway_delete(TimePoint _endtime)
{
    /*
    cout << "num global neighbors: " << DefaultPlanner::global_neighbors.size() << endl;
    cout << "global neighbor[0] num: " << DefaultPlanner::global_neighbors[0].size() << endl;
    cout << "global neighbor[1] num: " << DefaultPlanner::global_neighbors[1].size() << endl;
    cout << "global htable size: " << DefaultPlanner::global_heuristictable.size() << endl;
    cout << "global htable[0] empty: " << DefaultPlanner::global_heuristictable[0].empty() << endl;
    cout << "global htable[1] empty: " << DefaultPlanner::global_heuristictable[1].empty() << endl;
     */
     // 给grid赋值
    grid.resize(env->rows);
    for (int i = 0; i < env->rows; i++)
    {
        grid[i].resize(env->cols);
        for (int j = 0; j < env->cols; j++)
        {
            int index = i * env->cols + j;
            // cout << index << " ";
            grid[i][j] = env->map[index];
        }
    }
    // cout << endl;

    // 统计每行最长连续0的个数, 用来找出走廊行。
    vector<int> rowsLongestZeros(env->rows, 0); // 每行最长连续0的个数
    for (int i = 0; i < env->rows; i++)
    {
        auto [max_length, start_index, end_index] = find_longest_zeros(grid[i]);

        /*
        std::cout << "row " << i << " Maximum length of consecutive zeros: " << max_length << "\n";
        std::cout << "Start index: " << start_index << "\n";
        std::cout << "End index: " << end_index << "\n";
        // */

        rowsLongestZeros[i] = max_length;
    }

    vector<int> passageRows; // 走廊行的特点是, 自己最长零串的长度过半, 而上下邻居行的最长零串长度都不过半
    for (int i = 1; i < env->rows - 1; i++)
    {
        if (rowsLongestZeros[i] > env->cols / 2
            && rowsLongestZeros[i - 1] < env->cols / 2
            && rowsLongestZeros[i + 1] < env->cols / 2)
        {
            passageRows.emplace_back(i);
        }
    }

    /*
    cout << "passage row: ";
    for(int i=0;i<passageRows.size();i++)
    {
        cout << passageRows[i] << " ";
    }
    cout << endl;
     */

    for (auto row : passageRows)
    {
        for (int j = 0; j < env->cols; j++)
        {
            int index = row * env->cols + j;
            // cout << index << " ";
            // cout << DefaultPlanner::global_neighbors[index].size() << " ";
            /*
            cout << "(";
            for(auto neighbor : DefaultPlanner::global_neighbors[index])
            {
                cout << neighbor << " ";
            }
            cout << ")";
             */
        }
        // cout << endl;
    }

    vector<int> oddPassageRows;
    vector<int> evenPassageRows;
    for (int i = 0; i < passageRows.size(); i++)
    {
        if (i % 2 == 0)
        {
            evenPassageRows.emplace_back(passageRows[i]);
        }
        else
        {
            oddPassageRows.emplace_back(passageRows[i]);
        }
    }

    //*
    cout << "even passage rows: ";
    for(auto row : evenPassageRows)
    {
        cout << row << " ";
    }
    cout << endl;

    cout << "odd passage rows: ";
    for(auto row : oddPassageRows)
    {
        cout << row << " ";
    }
    cout << endl;
     //*/

    // even行删除左邻居
    for (auto row : evenPassageRows)
    {
        // for (int j = 20; j < env->cols - 20; j++)
        for (int j = 1; j < env->cols - 1; j++)
        {
            int index = row * env->cols + j;
            int valueToRemove = index - 1;
            auto it = std::find(DefaultPlanner::global_neighbors[index].begin(),
                DefaultPlanner::global_neighbors[index].end(), valueToRemove);
            if (it != DefaultPlanner::global_neighbors[index].end())
            {
                // cout << "even row index " << index << " delete left " << endl;
                DefaultPlanner::global_neighbors[index].erase(it);
            }    
        }
    }

    // odd行删除右邻居
    for (auto row : oddPassageRows)
    {
        // for (int j = 20; j < env->cols - 20; j++)
        for (int j = 1; j < env->cols - 1; j++)
        {
            int index = row * env->cols + j;
            int valueToRemove = index + 1;
            auto it = std::find(DefaultPlanner::global_neighbors[index].begin(),
                DefaultPlanner::global_neighbors[index].end(), valueToRemove);
            if (it != DefaultPlanner::global_neighbors[index].end()) 
            {
                // cout << "odd row index " << index << " delete right " << endl;
                DefaultPlanner::global_neighbors[index].erase(it);
            }
        }
    }   

    /*
    cout << "even row neighbor size: ";
    for (auto row : evenPassageRows)
    {
        // for (int j = 20; j < env->cols - 20; j++)
        for (int j = 20; j < env->cols - 20; j++)
        {
            int index = row * env->cols + j;

            // cout << DefaultPlanner::global_neighbors[index].size() << " ";
            cout << index << " ";
        }
    }
    cout << endl;

    cout << "odd row neighbor size: ";
    for (auto row : oddPassageRows)
    {
        // for (int j = 20; j < env->cols - 20; j++)
        for (int j = 20; j < env->cols - 20; j++)
        {
            int index = row * env->cols + j;

            cout << DefaultPlanner::global_neighbors[index].size() << " ";
        }
    }
    cout << endl;
    */

    // cout << "5020 to 5021: " << DefaultPlanner::get_h(env, 5020, 5021) << endl; // 13
    // cout << "5021 to 5020: " << DefaultPlanner::get_h(env, 5021, 5020) << endl; // 1
}

void TaskScheduler::build_row_highway_add(TimePoint _endtime)
{
    /*
    cout << "num global neighbors: " << DefaultPlanner::global_neighbors.size() << endl;
    cout << "global neighbor[0] num: " << DefaultPlanner::global_neighbors[0].size() << endl;
    cout << "global neighbor[1] num: " << DefaultPlanner::global_neighbors[1].size() << endl;
    cout << "global htable size: " << DefaultPlanner::global_heuristictable.size() << endl;
    cout << "global htable[0] empty: " << DefaultPlanner::global_heuristictable[0].empty() << endl;
    cout << "global htable[1] empty: " << DefaultPlanner::global_heuristictable[1].empty() << endl;
     //*/
     // 给grid赋值
    grid.resize(env->rows);
    for (int i = 0; i < env->rows; i++)
    {
        grid[i].resize(env->cols);
        for (int j = 0; j < env->cols; j++)
        {
            int index = i * env->cols + j;
            // cout << index << " ";
            grid[i][j] = env->map[index];
        }
    }
    // cout << endl;

    // 统计每行最长连续0的个数, 用来找出走廊行。
    vector<int> rowsLongestZeros(env->rows, 0); // 每行最长连续0的个数
    for (int i = 0; i < env->rows; i++)
    {
        auto [max_length, start_index, end_index] = find_longest_zeros(grid[i]);

        /*
        std::cout << "row " << i << " Maximum length of consecutive zeros: " << max_length << "\n";
        std::cout << "Start index: " << start_index << "\n";
        std::cout << "End index: " << end_index << "\n";
        // */

        rowsLongestZeros[i] = max_length;
    }

    vector<int> passageRows; // 走廊行的特点是, 自己最长零串的长度过半, 而上下邻居行的最长零串长度都不过半
    for (int i = 1; i < env->rows - 1; i++)
    {
        if (rowsLongestZeros[i] > env->cols / 2
            && rowsLongestZeros[i - 1] < env->cols / 2
            && rowsLongestZeros[i + 1] < env->cols / 2)
        {
            passageRows.emplace_back(i);
        }
    }

    /*
    cout << "passage row: ";
    for(int i=0;i<passageRows.size();i++)
    {
        cout << passageRows[i] << " ";
    }
    cout << endl;
     */

    for (auto row : passageRows)
    {
        for (int j = 0; j < env->cols; j++)
        {
            int index = row * env->cols + j;
            // cout << index << " ";
            // cout << DefaultPlanner::global_neighbors[index].size() << " ";
            /*
            cout << "(";
            for(auto neighbor : DefaultPlanner::global_neighbors[index])
            {
                cout << neighbor << " ";
            }
            cout << ")";
             */
        }
        // cout << endl;
    }

    vector<int> oddPassageRows;
    vector<int> evenPassageRows;
    for (int i = 0; i < passageRows.size(); i++)
    {
        if (i % 2 == 0)
        {
            evenPassageRows.emplace_back(passageRows[i]);
        }
        else
        {
            oddPassageRows.emplace_back(passageRows[i]);
        }
    }

    //*
    cout << "even passage rows: ";
    for (auto row : evenPassageRows)
    {
        cout << row << " ";
    }
    cout << endl;

    cout << "odd passage rows: ";
    for (auto row : oddPassageRows)
    {
        cout << row << " ";
    }
    cout << endl;
    //*/

    /*
   // even行删除左邻居
    for (auto row : evenPassageRows)
    {
        // for (int j = 20; j < env->cols - 20; j++)
        for (int j = 1; j < env->cols - 1; j++)
        {
            int index = row * env->cols + j;
            int valueToRemove = index - 1;
            
            extra_add.emplace_back(std::make_pair(index, valueToRemove));

            DefaultPlanner::global_heuristictable.at(valueToRemove).htable.resize(env->map.size(), MAX_TIMESTEP);
        }
    }

    // odd行删除右邻居
    for (auto row : oddPassageRows)
    {
        // for (int j = 20; j < env->cols - 20; j++)
        for (int j = 1; j < env->cols - 1; j++)
        {
            int index = row * env->cols + j;
            int valueToRemove = index + 1;
            
            extra_add.emplace_back(std::make_pair(index, valueToRemove));

            DefaultPlanner::global_heuristictable.at(valueToRemove).htable.resize(env->map.size(), MAX_TIMESTEP);
        }
    }
    */
}


void TaskScheduler::build_row_highway_compute(TimePoint _endtime)
{
    /*
    cout << "num global neighbors: " << DefaultPlanner::global_neighbors.size() << endl;
    cout << "global neighbor[0] num: " << DefaultPlanner::global_neighbors[0].size() << endl;
    cout << "global neighbor[1] num: " << DefaultPlanner::global_neighbors[1].size() << endl;
    cout << "global htable size: " << DefaultPlanner::global_heuristictable.size() << endl;
    cout << "global htable[0] empty: " << DefaultPlanner::global_heuristictable[0].empty() << endl;
    cout << "global htable[1] empty: " << DefaultPlanner::global_heuristictable[1].empty() << endl;
     //*/
     // 给grid赋值
    grid.resize(env->rows);
    for (int i = 0; i < env->rows; i++)
    {
        grid[i].resize(env->cols);
        for (int j = 0; j < env->cols; j++)
        {
            int index = i * env->cols + j;
            // cout << index << " ";
            grid[i][j] = env->map[index];
        }
    }
    // cout << endl;

    for (int i = 0; i < env->rows * env->cols; i++)
    {
        if (env->map[i] == 0)
        {
            DefaultPlanner::global_heuristictable.at(i).htable.resize(env->map.size(), MAX_TIMESTEP);

            for (int j = 0; j < env->rows * env->cols; j++)
            {
                if (env->map[j] == 0)
                {
                    DefaultPlanner::global_heuristictable.at(i).htable[j] = DefaultPlanner::manhattanDistance(i, j, env);
                }                
            }
        }
    }

    cout << 639 << endl;

    // 统计每行最长连续0的个数, 用来找出走廊行。
    vector<int> rowsLongestZeros(env->rows, 0); // 每行最长连续0的个数
    for (int i = 0; i < env->rows; i++)
    {
        auto [max_length, start_index, end_index] = find_longest_zeros(grid[i]);

        /*
        std::cout << "row " << i << " Maximum length of consecutive zeros: " << max_length << "\n";
        std::cout << "Start index: " << start_index << "\n";
        std::cout << "End index: " << end_index << "\n";
        // */

        rowsLongestZeros[i] = max_length;
    }

    vector<int> passageRows; // 走廊行的特点是, 自己最长零串的长度过半, 而上下邻居行的最长零串长度都不过半
    for (int i = 1; i < env->rows - 1; i++)
    {
        if (rowsLongestZeros[i] > env->cols / 2
            && rowsLongestZeros[i - 1] < env->cols / 2
            && rowsLongestZeros[i + 1] < env->cols / 2)
        {
            passageRows.emplace_back(i);
        }
    }

    /*
    cout << "passage row: ";
    for(int i=0;i<passageRows.size();i++)
    {
        cout << passageRows[i] << " ";
    }
    cout << endl;
     */

    for (auto row : passageRows)
    {
        for (int j = 0; j < env->cols; j++)
        {
            int index = row * env->cols + j;
            // cout << index << " ";
            // cout << DefaultPlanner::global_neighbors[index].size() << " ";
            /*
            cout << "(";
            for(auto neighbor : DefaultPlanner::global_neighbors[index])
            {
                cout << neighbor << " ";
            }
            cout << ")";
             */
        }
        // cout << endl;
    }

    vector<int> oddPassageRows;
    vector<int> evenPassageRows;
    for (int i = 0; i < passageRows.size(); i++)
    {
        if (i % 2 == 0)
        {
            evenPassageRows.emplace_back(passageRows[i]);
        }
        else
        {
            oddPassageRows.emplace_back(passageRows[i]);
        }
    }

    //*
    cout << "even passage rows: ";
    for (auto row : evenPassageRows)
    {
        cout << row << " ";
    }
    cout << endl;

    cout << "odd passage rows: ";
    for (auto row : oddPassageRows)
    {
        cout << row << " ";
    }
    cout << endl;
    //*/

   // even行删除左邻居
    for (auto row : evenPassageRows)
    {
        // for (int j = 20; j < env->cols - 20; j++)
        for (int j = 1; j < env->cols - 1; j++)
        {
            int index = row * env->cols + j;
            int valueToRemove = index - 1;

            extra_add.emplace_back(std::make_pair(index, valueToRemove));

            // DefaultPlanner::global_heuristictable.at(valueToRemove).htable.resize(env->map.size(), MAX_TIMESTEP);
        }
    }

    // odd行删除右邻居
    for (auto row : oddPassageRows)
    {
        // for (int j = 20; j < env->cols - 20; j++)
        for (int j = 1; j < env->cols - 1; j++)
        {
            int index = row * env->cols + j;
            int valueToRemove = index + 1;

            extra_add.emplace_back(std::make_pair(index, valueToRemove));

            // DefaultPlanner::global_heuristictable.at(valueToRemove).htable.resize(env->map.size(), MAX_TIMESTEP);
        }
    }


}


void TaskScheduler::build_column_highway_delete(TimePoint _endtime)
{
    /*
    cout << "num global neighbors: " << DefaultPlanner::global_neighbors.size() << endl;
    cout << "global neighbor[0] num: " << DefaultPlanner::global_neighbors[0].size() << endl;
    cout << "global neighbor[1] num: " << DefaultPlanner::global_neighbors[1].size() << endl;
    cout << "global htable size: " << DefaultPlanner::global_heuristictable.size() << endl;
    cout << "global htable[0] empty: " << DefaultPlanner::global_heuristictable[0].empty() << endl;
    cout << "global htable[1] empty: " << DefaultPlanner::global_heuristictable[1].empty() << endl;
     */
     // 给grid赋值
    grid.resize(env->rows);
    for (int i = 0; i < env->rows; i++)
    {
        grid[i].resize(env->cols);
        for (int j = 0; j < env->cols; j++)
        {
            int index = i * env->cols + j;
            // cout << index << " ";
            grid[i][j] = env->map[index];
        }
    }
    // cout << endl;

    // 统计每列最长连续0的个数, 用来找出走廊列。
    vector<int> columnsLongestZeros(env->cols, 0); // 每列最长连续0的个数
    for (int i = 0; i < env->cols; i++)
    {
        vector<int> each_column(env->rows, 0);
        for (int j = 0; j < env->rows; j++)
        {
            each_column[j] = grid[j][i];
        }

        auto [max_length, start_index, end_index] = find_longest_zeros(each_column);

        /*
        std::cout << "column " << i << " Maximum length of consecutive zeros: " << max_length << "\n";
        std::cout << "Start index: " << start_index << "\n";
        std::cout << "End index: " << end_index << "\n";
        // */

        columnsLongestZeros[i] = max_length;
    }

    vector<int> passageColumns; // 走廊列的特点是, 自己最长零串的长度过半, 而左右邻居列的最长零串长度都不过半
    for (int i = 1; i < env->cols - 1; i++)
    {
        if (columnsLongestZeros[i] > env->rows / 2
            && columnsLongestZeros[i - 1] < env->rows / 2
            && columnsLongestZeros[i + 1] < env->rows / 2)
        {
            passageColumns.emplace_back(i);
        }
    }

    /*
    cout << "passage columns: ";
    for(int i=0;i<passageColumns.size();i++)
    {
        cout << passageColumns[i] << " ";
    }
    cout << endl;
     //*/

    vector<int> oddPassageColumns;
    vector<int> evenPassageColumns;
    for (int i = 0; i < passageColumns.size(); i++)
    {
        if (i % 2 == 0)
        {
            evenPassageColumns.emplace_back(passageColumns[i]);
        }
        else
        {
            oddPassageColumns.emplace_back(passageColumns[i]);
        }
    }

    /*
    cout << "even passage columns: ";
    for(auto column : evenPassageColumns)
    {
        cout << column << " ";
    }
    cout << endl;

    cout << "odd passage columns: ";
    for(auto column : oddPassageColumns)
    {
        cout << column << " ";
    }
    cout << endl;
     //*/

    // even column delete north
    for (auto column : evenPassageColumns)
    {
        for (int i = 1; i < env->rows - 1; i++)
        {
            int index = i * env->cols + column;
            int valueToRemove = index - env->cols;

            auto it = std::find(DefaultPlanner::global_neighbors[index].begin(),
                DefaultPlanner::global_neighbors[index].end(), valueToRemove);

            if (it != DefaultPlanner::global_neighbors[index].end()) 
            {
                // cout << "even column index " << index << " delete up " << endl;
                DefaultPlanner::global_neighbors[index].erase(it);
            }
        }
    }

    // odd column delete south
    for (auto column : oddPassageColumns)
    {
        for (int i = 1; i < env->rows - 1; i++)
        {
            int index = i * env->cols + column;
            // 根据usage.cpp, 向南对应1
            int valueToRemove = index + env->cols;

            auto it = std::find(DefaultPlanner::global_neighbors[index].begin(),
                DefaultPlanner::global_neighbors[index].end(), valueToRemove);

            if (it != DefaultPlanner::global_neighbors[index].end())
            {
                // cout << "odd column index " << index << " delete down " << endl;
                DefaultPlanner::global_neighbors[index].erase(it);
            }
        }
    }

    /*
    // even column delete north
    cout << "even column neighbor num: ";
    for (auto column : evenPassageColumns)
    {
        for (int i = 20; i < env->rows - 20; i++)
        {
            int index = i * env->cols + column;

            cout << DefaultPlanner::global_neighbors[index].size() << " ";
        }
    }
    cout << endl;

    cout << "odd column neighbor num: ";
    for (auto column : oddPassageColumns)
    {
        for (int i = 20; i < env->rows - 20; i++)
        {
            int index = i * env->cols + column;

            cout << DefaultPlanner::global_neighbors[index].size() << " ";
        }
    }
    cout << endl;
    */
}

void TaskScheduler::build_column_highway_add(TimePoint _endtime)
{
    /*
    cout << "num global neighbors: " << DefaultPlanner::global_neighbors.size() << endl;
    cout << "global neighbor[0] num: " << DefaultPlanner::global_neighbors[0].size() << endl;
    cout << "global neighbor[1] num: " << DefaultPlanner::global_neighbors[1].size() << endl;
    cout << "global htable size: " << DefaultPlanner::global_heuristictable.size() << endl;
    cout << "global htable[0] empty: " << DefaultPlanner::global_heuristictable[0].empty() << endl;
    cout << "global htable[1] empty: " << DefaultPlanner::global_heuristictable[1].empty() << endl;
     */
     // 给grid赋值
    grid.resize(env->rows);
    for (int i = 0; i < env->rows; i++)
    {
        grid[i].resize(env->cols);
        for (int j = 0; j < env->cols; j++)
        {
            int index = i * env->cols + j;
            // cout << index << " ";
            grid[i][j] = env->map[index];
        }
    }
    // cout << endl;

    // 统计每列最长连续0的个数, 用来找出走廊列。
    vector<int> columnsLongestZeros(env->cols, 0); // 每列最长连续0的个数
    for (int i = 0; i < env->cols; i++)
    {
        vector<int> each_column(env->rows, 0);
        for (int j = 0; j < env->rows; j++)
        {
            each_column[j] = grid[j][i];
        }

        auto [max_length, start_index, end_index] = find_longest_zeros(each_column);

        /*
        std::cout << "column " << i << " Maximum length of consecutive zeros: " << max_length << "\n";
        std::cout << "Start index: " << start_index << "\n";
        std::cout << "End index: " << end_index << "\n";
        // */

        columnsLongestZeros[i] = max_length;
    }

    vector<int> passageColumns; // 走廊列的特点是, 自己最长零串的长度过半, 而左右邻居列的最长零串长度都不过半
    for (int i = 1; i < env->cols - 1; i++)
    {
        if (columnsLongestZeros[i] > env->rows / 2
            && columnsLongestZeros[i - 1] < env->rows / 2
            && columnsLongestZeros[i + 1] < env->rows / 2)
        {
            passageColumns.emplace_back(i);
        }
    }

    /*
    cout << "passage columns: ";
    for(int i=0;i<passageColumns.size();i++)
    {
        cout << passageColumns[i] << " ";
    }
    cout << endl;
     //*/

    vector<int> oddPassageColumns;
    vector<int> evenPassageColumns;
    for (int i = 0; i < passageColumns.size(); i++)
    {
        if (i % 2 == 0)
        {
            evenPassageColumns.emplace_back(passageColumns[i]);
        }
        else
        {
            oddPassageColumns.emplace_back(passageColumns[i]);
        }
    }

    /*
    cout << "even passage columns: ";
    for(auto column : evenPassageColumns)
    {
        cout << column << " ";
    }
    cout << endl;

    cout << "odd passage columns: ";
    for(auto column : oddPassageColumns)
    {
        cout << column << " ";
    }
    cout << endl;
     //*/

     // even column delete north
    for (auto column : evenPassageColumns)
    {
        for (int i = 20; i < env->rows - 20; i++)
        {
            int index = i * env->cols + column;
            int valueToRemove = index - env->cols;

            extra_add.emplace_back(std::make_pair(index, valueToRemove));

            DefaultPlanner::global_heuristictable.at(valueToRemove).htable.resize(env->map.size(), MAX_TIMESTEP);
        }
    }

    // odd column delete south
    for (auto column : oddPassageColumns)
    {
        for (int i = 20; i < env->rows - 20; i++)
        {
            int index = i * env->cols + column;
            // 根据usage.cpp, 向南对应1
            int valueToRemove = index + env->cols;

            extra_add.emplace_back(std::make_pair(index, valueToRemove));

            DefaultPlanner::global_heuristictable.at(valueToRemove).htable.resize(env->map.size(), MAX_TIMESTEP);
        }
    }
}

void TaskScheduler::assign_extra_add()
{
    // cout << "extra add: " << extra_add.size() << endl;
    for (auto const& pair : extra_add)
    {
        DefaultPlanner::global_heuristictable.at(pair.second).htable[pair.first] = 10000;
    }
}

// 带旋转启发式的初始化
void TaskScheduler::rhcr_initialize()
{
    sorting_grid.load_LoRR_map(env);

    namespace po = boost::program_options;
    vm.insert(std::make_pair("single_agent_solver", po::variable_value(std::string("ASTAR"), false)));
    // vm.insert(std::make_pair("single_agent_solver", po::variable_value(std::string("SIPP"), false)));

    // vm.insert(std::make_pair("solver", po::variable_value(std::string("PBS"), false)));
    vm.insert(std::make_pair("lazyP", po::variable_value(false, false)));
    vm.insert(std::make_pair("prioritize_start", po::variable_value(true, false)));
    vm.insert(std::make_pair("hold_endpoints", po::variable_value(false, false)));
    vm.insert(std::make_pair("dummy_paths", po::variable_value(false, false)));
    vm.insert(std::make_pair("CAT", po::variable_value(false, false)));

    vm.insert(std::make_pair("solver", po::variable_value(std::string("ECBS"), false)));
    vm.insert(std::make_pair("potential_function", po::variable_value(std::string("NONE"), false)));
    vm.insert(std::make_pair("potential_threshold", po::variable_value(0.0, false)));
    vm.insert(std::make_pair("suboptimal_bound", po::variable_value(1.0, false)));

    vm.insert(std::make_pair("id", po::variable_value(false, false)));

    MAPFSolver* solver = set_solver(sorting_grid, vm);
    sorting_system = new SortingSystem(sorting_grid, *solver);
    assert(!sorting_system->hold_endpoints);
    assert(!sorting_system->useDummyPaths);

    vm.insert(std::make_pair("output", po::variable_value(std::string("../exp/test"), false)));
    vm.insert(std::make_pair("screen", po::variable_value(1, false)));
    vm.insert(std::make_pair("log", po::variable_value(false, false)));
    vm.insert(std::make_pair("agentNum", po::variable_value(env->num_of_agents, false)));
    vm.insert(std::make_pair("cutoffTime", po::variable_value(60, false)));
    vm.insert(std::make_pair("simulation_window", po::variable_value(1, false)));
    vm.insert(std::make_pair("planning_window", po::variable_value(5, false)));
    vm.insert(std::make_pair("travel_time_window", po::variable_value(0, false)));
    vm.insert(std::make_pair("rotation", po::variable_value(true, false)));
    vm.insert(std::make_pair("robust", po::variable_value(0, false)));
    // hold endpoints已经有了
    // dummy path已经有了
    vm.insert(std::make_pair("seed", po::variable_value(0, false)));

    set_parameters(*sorting_system, vm);
    sorting_grid.preprocessing_LoRR(sorting_system->consider_rotation, env);
    vm.insert(std::make_pair("simulation_time", po::variable_value(20, false)));

    // cout << "map 400: " << env->map[400] << endl;
    // cout << "map 962: " << env->map[962] << endl;
    // cout << "rhcr dist: " << sorting_grid.heuristics[0].at(33) << endl;
    // cout << "default dist: " << DefaultPlanner::get_h(env, 0, 33) << endl;
}

/**
 * Plans a task schedule within a specified time limit.
 *
 * This function schedules tasks by calling schedule_plan function in default planner with half of the given time limit,
 * adjusted for timing error tolerance. The planned schedule is output to the provided schedule vector.
 *
 * @param time_limit The total time limit allocated for scheduling (in milliseconds).
 * @param proposed_schedule A reference to a vector that will be populated with the proposed schedule (next task id for each agent).
 */

void TaskScheduler::plan(int time_limit, std::vector<int> & proposed_schedule)
{
    ETimer timer; // 总之就是个计时器
    // 使用默认调度器
#ifdef ENABLE_DEFAULT_SCHEDULER
    // give at most half of the entry time_limit to scheduler;
    // -SCHEDULER_TIMELIMIT_TOLERANCE for timing error tolerance
    int limit = time_limit/2 - DefaultPlanner::SCHEDULER_TIMELIMIT_TOLERANCE;
    // DefaultPlanner::schedule_plan(limit, proposed_schedule, env);
    // greedy_only_first(limit, proposed_schedule);
    // greedy_sum(limit, proposed_schedule);
    // greedy_sum_vector(limit, proposed_schedule);
    // greedy_sum_at_once(limit, proposed_schedule);
    // greedy_sum_suburb_first(limit, proposed_schedule);
    // greedy_sum_urban_first(limit, proposed_schedule);
    // urban_first_adaptive_jam_task_pickup_region_count_current(limit, proposed_schedule);
    // urban_first_adaptive_jam_task_pickup_region_count_current_not_get(limit, proposed_schedule);
    // greedy_sum_sparse_region_first(limit, proposed_schedule);
    // greedy_sum_sparse_wait_region_first(limit, proposed_schedule);
    // greedy_sum_all_time_sparse_wait_region_first(limit, proposed_schedule);
    // greedy_sum_dense_region_first(limit, proposed_schedule);
    // greedy_sum_dense_wait_region_first(limit, proposed_schedule);
    // greedy_sum_all_time_dense_wait_region_first(limit, proposed_schedule);

    // hungarian_only_first(limit, proposed_schedule);
    // hungarian_pickup_snatch(limit, proposed_schedule, env);
    // hungarian_sum(limit, proposed_schedule);
    // hungarian_sum_at_once(limit, proposed_schedule, env);
    hungarian_sum_snatch(limit, proposed_schedule);
    // hungarian_sum_snatch_not_get(limit, proposed_schedule);
    // hungarian_sum_snatch_and_pickup_jam_based_current(limit, proposed_schedule);
    // hungarian_sum_snatch_complex(limit, proposed_schedule, env);

    // pickup_jam_based_current(limit, proposed_schedule, env);
    // adaptive_jam_pickup_current_circle(limit, proposed_schedule);
    // adaptive_jam_task_circle_current(limit, proposed_schedule);
    // adaptive_jam_task_circle_current_square(limit, proposed_schedule);
    // adaptive_jam_task_circle_count_current(limit, proposed_schedule);
    // adaptive_jam_task_circle_count_current_preassign(limit, proposed_schedule);
    // adaptive_jam_task_circle_count_current_compare_dist(limit, proposed_schedule);
    // hungarian_sum_snatch_adaptive_jam_task_circle_count_current(limit, proposed_schedule);
    // adaptive_jam_task_circle_count_current_busy(limit, proposed_schedule);
    // adaptive_jam_task_half_circle_count_current(limit, proposed_schedule); // 1.1.0
    // adaptive_jam_task_double_circle_count_current(limit, proposed_schedule); // 1.1.1
    // hungarian_sum_snatch_adaptive_jam_task_double_circle_count_current(limit, proposed_schedule); // 1.1.1.1
    // adaptive_jam_task_circle_count_current_sample(limit, proposed_schedule, 2048); // 1.1.2
    // adaptive_jam_task_circle_count_current_extrapolation(limit, proposed_schedule); // 1.1.3
    // adaptive_jam_pickup_delivery_circle_count_current(limit, proposed_schedule); // 1.1.4
    // adaptive_jam_both_circle_count_current(limit, proposed_schedule); // 1.1.5
    // adaptive_jam_task_pickup_region_count_current(limit, proposed_schedule); // 1.2
    // adaptive_jam_task_pickup_region_count_goal(limit, proposed_schedule); // 1.2.-3
    // adaptive_jam_agent_pickup_region_count_current(limit, proposed_schedule); // 1.2.-2
    // adaptive_jam_adaptive_pickup_region_count_current(limit, proposed_schedule); // 1.2.-1
    // hungarian_sum_snatch_adaptive_jam_task_pickup_region_count_current(limit, proposed_schedule); // 1.2.0
    // hungarian_sum_snatch_adaptive_jam_task_pickup_region_current_density(limit, proposed_schedule); // 1.2.0.1
    // hungarian_sum_snatch_adaptive_jam_task_pickup_region_current_density_times_agent_pickup(limit, proposed_schedule); // 1.2.0.2
    // adaptive_jam_task_region_current_density(limit, proposed_schedule); // 1.2.1
    // adaptive_jam_task_region_current_density_times_agent_pickup(limit, proposed_schedule); // 1.2.2
    // adaptive_jam_task_region_current_density_times_agent_pickup_not_get(limit, proposed_schedule); // 1.2.2.-1
    // adaptive_jam_task_region_current_density_times_agent_pickup_not_get_delay(limit, proposed_schedule); // 1.2.2.-2
    // adaptive_jam_task_region_current_density_times_agent_pickup_at_once(limit, proposed_schedule); // 1.2.2.0
    // adaptive_jam_task_region_current_density_times_agent_pickup_delivery(limit, proposed_schedule); // 1.2.2.2
    // adaptive_jam_task_region_all_time_average_density(limit, proposed_schedule); // 1.2.3
    // adaptive_jam_task_region_time_window_density(limit, proposed_schedule); // 1.2.4
    // adaptive_jam_task_region_time_window_density_times_agent_pickup(limit, proposed_schedule); // 1.2.4.1
    // adaptive_jam_pickup_region_large_small_partition_count(limit, proposed_schedule); // 1.2.4.2.0
    // adaptive_jam_task_region_long_short_term_count(limit, proposed_schedule); // 1.2.4.2
    // adaptive_jam_task_region_long_short_term_density(limit, proposed_schedule); // 1.2.4.3
    // adaptive_jam_task_region_long_short_term_density_times_agent_pickup(limit, proposed_schedule); // 1.2.4.4
    // adaptive_jam_pickup_region_long_large_short_small_density(limit, proposed_schedule); // 1.2.4.5
    // adaptive_jam_agent_pickup_crossed_region_count_current(limit, proposed_schedule); // 1.2.5
    // adaptive_jam_agent_pickup_crossed_region_current_density(limit, proposed_schedule); // 1.2.5.1
    // adaptive_jam_agent_pickup_crossed_region_current_density_times_agent_pickup(limit, proposed_schedule); // 1.2.5.2
    // adaptive_jam_agent_pickup_crossed_region_current_weighted_density_times_agent_pickup(limit, proposed_schedule); // 1.2.5.2
    // adaptive_jam_agent_pickup_crossed_region_current_density_times_agent_pickup_delivery(limit, proposed_schedule); // 1.2.5.3
    // adaptive_jam_pickup_delivery_crossed_region_count_current(limit, proposed_schedule); // 1.2.6
    // adaptive_jam_pickup_delivery_crossed_region_count_goal(limit, proposed_schedule); // 1.2.6.1
    // adaptive_jam_agent_pickup_delivery_crossed_region_count_current(limit, proposed_schedule); // 1.2.7
    // adaptive_jam_agent_pickup_delivery_crossed_region_current_density(limit, proposed_schedule); // 1.2.8
    // adaptive_jam_agent_pickup_delivery_crossed_region_current_weighted_density(limit, proposed_schedule); // 1.2.9
    // adaptive_jam_agent_pickup_delivery_crossed_region_current_weighted_density_times_agent_pickup(limit, proposed_schedule); // 1.2.10
    // adaptive_jam_task_pickup_region_count_average_wait(limit, proposed_schedule); // 1.3
    // adaptive_jam_task_pickup_region_average_wait_density(limit, proposed_schedule); // 1.3.1
    // adaptive_jam_task_pickup_region_count_time_window_wait(limit, proposed_schedule); // 1.3.2
    // adaptive_jam_task_delivery_region_count_average_wait(limit, proposed_schedule); // 1.4
    // adaptive_jam_task_delivery_region_count_time_window_wait(limit, proposed_schedule); // 1.4.1
    // adaptive_jam_task_errand_region_count_average_wait(limit, proposed_schedule); // 1.5
    // adaptive_jam_task_errand_region_count_time_window_wait(limit, proposed_schedule); // 1.5.1
    // adaptive_jam_task_errand_region_count_current(limit, proposed_schedule); // 1.5.2
    // adaptive_jam_count_near_small_current_far_large_current(limit, proposed_schedule); // 1.5.3
    // adaptive_jam_count_pickup_current_delivery_goal(limit, proposed_schedule); // 1.5.4.-3
    // adaptive_jam_count_weighted_pickup_current_delivery_goal(limit, proposed_schedule); // 1.5.4.-2
    // adaptive_jam_count_pickup_current_delivery_time_window_wait(limit, proposed_schedule); // 1.5.4.-1
    // adaptive_jam_count_near_current_far_time_window_wait(limit, proposed_schedule); // 1.5.4
    // adaptive_jam_count_pickup_current_delivery_time_window_average_wait(limit, proposed_schedule); // 1.5.5
    // adaptive_jam_count_pickup_current_minus_delivery_time_window_average_wait(limit, proposed_schedule); // 1.5.6
    // adaptive_jam_count_pickup_current_minus_delivery_time_window_average_wait_constant(limit, proposed_schedule); // 1.5.7
    // adaptive_jam_count_pickup_current_delivery_time_window_average_wait_middle_large(limit, proposed_schedule); // 1.5.8
    // adaptive_jam_middle_circle_count_current(limit, proposed_schedule);
    // adaptive_jam_task_circle_vector_current(limit, proposed_schedule);
    // adaptive_jam_task_circle_vector_current_busy(limit, proposed_schedule);
    // adaptive_jam_task_circle_vector_current_extrapolation(limit, proposed_schedule);
    // adaptive_jam_task_circle_vector_current_complex(limit, proposed_schedule);

    // pickup_jam_based_goal(limit, proposed_schedule, env);
    // adaptive_jam_task_circle_count_goal(limit, proposed_schedule);
    // adaptive_jam_task_circle_count_goal_compare_dist(limit, proposed_schedule);
    // hungarian_sum_snatch_adaptive_jam_task_circle_count_goal(limit, proposed_schedule);
    // adaptive_jam_task_circle_count_goal_preassign(limit, proposed_schedule);
    // adaptive_jam_task_circle_count_next_goal(limit, proposed_schedule); // 3.1
    // adaptive_jam_task_circle_count_all_goals(limit, proposed_schedule); // 3.2
    // adaptive_jam_task_circle_count_all_goals_not_get(limit, proposed_schedule); // 3.2.-2
    // adaptive_jam_task_circle_count_all_goals_delivery_edge(limit, proposed_schedule); // 3.2.-1
    // adaptive_jam_task_circle_count_all_goals_minus_wait(limit, proposed_schedule); // 3.2.0
    // linear_regression_jam_task_circle_count_all_goals(limit, proposed_schedule); // 3.2.1    
    // adaptive_jam_task_circle_count_all_goals_at_once(limit, proposed_schedule); // 3.2.2
    // adaptive_jam_count_pickup_circle_goal_delivery_square_goal(limit, proposed_schedule); // 3.3
    // adaptive_jam_task_double_circle_count_goal(limit, proposed_schedule); // 3.4
    // adaptive_jam_task_triangle_circle_count_goal(limit, proposed_schedule); // 3.5
    // adaptive_jam_task_circle_vector_goal(limit, proposed_schedule);

    // adaptive_jam_task_circle_count_both_current_goal(limit, proposed_schedule);
    // adaptive_jam_task_circle_count_both_current_goal_compare_dist(limit, proposed_schedule);
    // hungarian_sum_snatch_adaptive_jam_task_circle_count_both_current_goal(limit, proposed_schedule);

    // adaptive_jam_task_circle_count_middle_current_goal(limit, proposed_schedule); // 6
    // adaptive_jam_task_circle_count_middle_current_goal_compare_dist(limit, proposed_schedule);
    // hungarian_sum_snatch_adaptive_jam_task_circle_count_middle_current_goal(limit, proposed_schedule);
    // adaptive_jam_task_circle_count_middle_current_next_goal(limit, proposed_schedule); // 6.0
    // adaptive_jam_task_circle_middle_current_goal_density(limit, proposed_schedule); // 6.1
    // adaptive_jam_task_circle_middle_current_goal_density_times_agent_pickup(limit, proposed_schedule); // 6.2
    // adaptive_jam_task_circle_middle_current_goal_density_times_agent_pickup_delivery(limit, proposed_schedule); // 6.3
    // adaptive_jam_task_Manhattan_circle_count_middle_current_goal(limit, proposed_schedule);
    // adaptive_jam_task_Manhattan_circle_count_middle_current_goal_rhcr(limit, proposed_schedule);
    // adaptive_jam_task_fix_Manhattan_circle_count_middle_current_goal(limit, proposed_schedule);

    // adaptive_jam_task_region_count_middle_current_goal(limit, proposed_schedule); // 8
    // adaptive_jam_task_h_circle_count_middle_current_goal(limit, proposed_schedule); // 8.1

    // adaptive_jam_task_circle_vector_middle_current_goal(limit, proposed_schedule);
    // adaptive_jam_curr_pickup_intersect_curr_goal(limit, proposed_schedule); // 11
    // adaptive_jam_curr_pickup_intersect_curr_goal_not_get(limit, proposed_schedule); // 11.-1
    // adaptive_jam_curr_pickup_intersect_curr_goal_at_once(limit, proposed_schedule); // 11.0
    // adaptive_jam_curr_pickup_intersect_curr_goal_at_once_not_get(limit, proposed_schedule); // 11.0.-2
    // adaptive_jam_vector_curr_pickup_intersect_curr_goal_at_once(limit, proposed_schedule); // 11.0.1
    // adaptive_jam_curr_pickup_intersect_curr_goal_preassign(limit, proposed_schedule); // 11.1
    // adaptive_jam_curr_pickup_intersect_curr_goal_density(limit, proposed_schedule); // 11.2
    // adaptive_jam_curr_pickup_delivery_intersect_curr_goal(limit, proposed_schedule);

    // choose method according to map size, 128x128 as separator
    /*
    if(env->map.size() <= 128 * 128)
    {
        // Random 1 2 3 4 5
        // sigint_handler(1);
        hungarian_sum_snatch_not_get(limit, proposed_schedule);
    }
    else
    {
        // choose method according to agent num, 2048 as separator
        // CITY-01
        if(env->curr_states.size() <= 2048)
        {
            // sigint_handler(1);
            hungarian_sum_snatch_not_get(limit, proposed_schedule);
        }
        else
        {
            // 用8192作为adaptive_jam_middle_current_goal_task_circle_count和default的分界点，看看能不能把sortation和warehouse分离出来。
            if(env->curr_states.size() <= 8192) // CITY-02 and GAME
            {
                // CITY-02
                if(env->curr_states.size() <= 4096)
                {
                    // sigint_handler(1);
                    adaptive_jam_task_circle_count_all_goals_not_get(limit, proposed_schedule);
                }
                else // GAME
                {
                    // sigint_handler(1);
                    adaptive_jam_curr_pickup_intersect_curr_goal_not_get(limit, proposed_schedule);
                }
            }
            else // SORTATION and WAREHOUSE
            {                
                if (env->map_name[0] == 's')
                {
                    // sigint_handler(1);
                    urban_first_adaptive_jam_task_pickup_region_count_current_not_get(limit, proposed_schedule);
                }
                else if (env->map_name[0] == 'w')
                {
                    // sigint_handler(1);
                    adaptive_jam_task_region_current_density_times_agent_pickup_not_get(limit, proposed_schedule);
                }
            }
        }
    }
     //*/

    /*
    cout << "task pool size: " << env->task_pool.size() << endl;
    for(auto element : env->task_pool)
    {
        cout << "task id" << element.first << " " << element.second.idx_next_loc << endl;
    }
     */
#else
    TimePoint end_time = std::min(env->plan_start_time + Milliseconds(time_limit - 10), get_now() + Milliseconds(SCHEDULER_REBUILD_DP_TIME + SCHEDULER_LAZY_SOLVE_TIME + SCHEDULER_LNS_SOLVE_TIME));
    update_environment(*env);
    my_scheduler.plan(end_time, proposed_schedule);

    PRINT(
            uint32_t cnt = 0;
            for (uint32_t r = 0; r < proposed_schedule.size(); r++) {
                cnt += proposed_schedule[r] != -1;
            };
            uint32_t p = cnt * 100.0 / proposed_schedule.size();
            ASSERT(0 <= p && p <= 100, "invalid p: " + std::to_string(p));
            Printer() << "[Scheduler] assigned robots: " << p << "%" << (p != 100 ? " bad\n" : "\n");
            Printer() << "[Scheduler] time: " << timer << '\n';);
#endif
}

// 预先计算地图上任意两点之间的距离
void TaskScheduler::compute_map_point_dist(TimePoint _endtime) const
{
    size_t count = 0;
    for(int i=0;i<env->map.size();i++)
    {
        for(int j=0;j<env->map.size();j++)
        {
            // check for timeout every 100 dist computation
            if (count % 100 == 0 && std::chrono::steady_clock::now() > _endtime)
            {
                return;
            }

            if (j != i && env->map[i]==0 && env->map[j]==0)
            {
                DefaultPlanner::get_h(env, i, j);
                count++;
            }
        }
    }
}


// 预先计算地图上任意两点之间的距离
void TaskScheduler::compute_map_point_dist_reverse(TimePoint _endtime) const
{
    size_t count = 0;
    for (int i = 0; i < env->map.size(); i++)
    {
        for (int j = env->map.size()-1; j >= 0; j--)
        {
            // check for timeout every 100 dist computation
            if (count % 100 == 0 && std::chrono::steady_clock::now() > _endtime)
            {
                return;
            }

            if (j != i && env->map[i] == 0 && env->map[j] == 0)
            {
                DefaultPlanner::get_h(env, i, j);
                count++;
            }
        }
    }
}


// 预先计算地图上任意两点之间的距离, 采用对称性加快计算速度
void TaskScheduler::compute_map_point_dist_symmetry(TimePoint _endtime) const
{
    // cout << DefaultPlanner::global_heuristictable.size() << endl;

    size_t count = 0;
    for(int i=0;i<env->map.size();i++)
    {
        for(int j=i+1;j<env->map.size();j++)
        {
            // check for timeout every 10 dist computation
            if (count % 100 == 0 && std::chrono::steady_clock::now() > _endtime)
            {
                return;
            }

            if (env->map[i]==0 && env->map[j]==0)
            {
                if(DefaultPlanner::global_heuristictable.at(i).htable.empty())
                {
                    DefaultPlanner::global_heuristictable.at(i).htable.resize(
                            env->map.size(), MAX_TIMESTEP);
                }

                // get_h(i,j)填充的是global_heuristictable.at(j).htable[i], 这里使用对称性加快速度
                DefaultPlanner::global_heuristictable.at(i).htable[j] =
                        DefaultPlanner::get_h(env, i, j);
                count++;
                // cout << i << " " << j << endl; // i=0, j=1
                // cout << DefaultPlanner::global_heuristictable.size() << endl;
                // cout << DefaultPlanner::global_heuristictable.at(i).htable[j] << endl; // 0
                // cout << DefaultPlanner::global_heuristictable.at(j).htable[i] << endl; // 65536
                // return;
            }
        }
    }
}

// 默认分配算法，cost只计算agent和任务pickup点的位置。
void TaskScheduler::greedy_only_first(int time_limit, std::vector<int> & proposed_schedule)
{
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    int min_task_i, min_task_makespan, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        //keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        min_task_makespan = INT_MAX;
        count = 0;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            //check for timeout every 10 task evaluations
            if (count % 10 == 0 && std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations){
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
                break; // schedule only first
            }

            // update the new minimum makespan
            if (dist < min_task_makespan){
                min_task_i = t_id;
                min_task_makespan = dist;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1){
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
        }
            // nothing to assign
        else{
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Time Usage: " <<  ((float)(clock() - start))/CLOCKS_PER_SEC <<endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: "<< env->new_tasks.size() <<  endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 默认分配算法，从默认代码中复制到TaskScheduler.cpp。
void TaskScheduler::greedy_sum(int time_limit, std::vector<int> & proposed_schedule)
{
    cout << "greedy sum" << endl;

    // assign_extra_add();

    // cout << "DefaultPlanner::global_neighbors[62056] size: " << DefaultPlanner::global_neighbors[62056].size() << endl;
    // cout << "even column global_neighbors[47451] size after: " << DefaultPlanner::global_neighbors[47451].size() << endl;
    // cout << "odd column global_neighbors[33971] size after: " << DefaultPlanner::global_neighbors[33971].size() << endl;

    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remainning time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    int min_task_index, min_task_makespan, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_index = -1;
        min_task_makespan = INT_MAX;
        count = 0;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            //check for timeout every 10 task evaluations
            if (count % 10 == 0 && std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations){
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            // update the new minimum makespan
            if (dist < min_task_makespan){
                min_task_index = t_id;
                min_task_makespan = dist;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_index != -1){
            proposed_schedule[i] = min_task_index;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_index);
        }
            // nothing to assign
        else{
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Time Usage: " <<  ((float)(clock() - start))/CLOCKS_PER_SEC <<endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: "<< env->new_tasks.size() <<  endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 默认分配算法，用于其他分配算法处理首批任务
void TaskScheduler::greedy_sum_without_newtask(int time_limit, std::vector<int> & proposed_schedule)
{
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remainning time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // 由于new task已经在调用前插入过了, 所以这里不再插入新任务
    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    int min_task_i, min_task_makespan, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        min_task_makespan = INT_MAX;
        count = 0;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            //check for timeout every 10 task evaluations
            if (count % 10 == 0 && std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations){
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            // update the new minimum makespan
            if (dist < min_task_makespan){
                min_task_i = t_id;
                min_task_makespan = dist;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1){
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
        }
            // nothing to assign
        else{
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Time Usage: " <<  ((float)(clock() - start))/CLOCKS_PER_SEC <<endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: "<< env->new_tasks.size() <<  endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 默认分配算法，用于其他分配算法处理首批任务
void TaskScheduler::greedy_sum_at_once_without_newtask(int time_limit, std::vector<int>& proposed_schedule)
{
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remainning time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // 由于new task已经在调用前插入过了, 所以这里不再插入新任务
    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    int min_task_i, min_task_makespan, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        min_task_makespan = INT_MAX;
        count = 0;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            //check for timeout every 10 task evaluations
            if (count % 10 == 0 && std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations) {
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                dist += task_distances[t_id];
                c_loc = loc;
                break;
            }

            // update the new minimum makespan
            if (dist < min_task_makespan) {
                min_task_i = t_id;
                min_task_makespan = dist;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1) {
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
        }
        // nothing to assign
        else {
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 默认分配算法，从默认代码中复制到TaskScheduler.cpp。
void TaskScheduler::greedy_sum_vector(int time_limit, std::vector<int>& proposed_schedule)
{
    cout << "greedy sum vector" << endl;
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remainning time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    // Copy free_agents to free_agents_vector
    std::vector<int> free_agents_vector(free_agents.begin(), free_agents.end());
    std::vector<int> agents_task_gap(free_agents.size(), 0); // agent选择任务和最优任务的差值
    std::vector<int> free_tasks_vector(free_tasks.begin(), free_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    int counter = 0;
    for (const int& free_task_id : env->new_tasks)
    {
        int total_dist = 0;
        int curr_loc = env->task_pool[free_task_id].locations[0];

        // iterate over the locations (errands) of the task to compute the makespan to finish the task
        // makespan: the time for the agent to complete all the errands of the task t_id in order
        for (int loc : env->task_pool[free_task_id].locations)
        {
            total_dist += DefaultPlanner::get_h(env, curr_loc, loc);
            curr_loc = loc;
        }

        task_lengths[free_task_id] = total_dist;
        counter++;
        // cout << counter << endl;
    }

    vector<int> work_assignment(free_agents.size(), -1); // "worker " << i << ", assignment " << work_assignment[i]

    int min_task_i, min_task_makespan, dist, c_loc, count;
    clock_t start = clock();

    vector<int> task_agent(110000, -1);

    // iterate over the free agents to decide which task to assign to each of them
    int first_total_assign_span = 0;
    for (int i = 0; i < free_agents_vector.size(); i++)
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int agent_id = free_agents_vector[i];

        assert(env->curr_task_schedule[agent_id] == -1);

        min_task_i = -1;
        min_task_makespan = INT_MAX;

        int min_ideal_task_i = -1;
        int min_ideal_task_makespan = INT_MAX;

        count = 0;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks_vector)
        {            

            //check for timeout every 10 task evaluations
            if (count % 10 == 0 && std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations) 
            {
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                dist += task_lengths[t_id];
                c_loc = loc;
                break;
            }

            // update the new minimum makespan
            if (dist < min_task_makespan) 
            {
                if (task_agent[t_id] == -1)
                {
                    min_task_i = t_id;
                    min_task_makespan = dist;
                }                
            }

            if (dist < min_ideal_task_makespan)
            {
                min_ideal_task_i = t_id;
                min_ideal_task_makespan = dist;
            }

            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1) 
        { 
            work_assignment[i] = min_task_i;
            task_agent[min_task_i] = i;
            first_total_assign_span += min_task_makespan;
            agents_task_gap[i] = min_task_makespan - min_ideal_task_makespan;
        }
    }

    cout << "first total assign span: " << first_total_assign_span << endl;

    /*
    cout << "real ideal task gap: " << endl;
    for (int i = 0; i < free_agents_vector.size(); i++)
    {
        cout << free_agents_vector[i] << " ideal real gap " << agents_task_gap[i] << endl;
    }
    */

    // 索引数组，表示dist2edges原始索引, 也和free_agents_vector的索引对应
    std::vector<int> indices(agents_task_gap.size());
    for (size_t i = 0; i < indices.size(); ++i) {
        indices[i] = i;
    }

    // 对索引数组进行排序，按照 data 的值排序
    std::sort(indices.begin(), indices.end(), [&](int a, int b) {
        return agents_task_gap[a] > agents_task_gap[b];  // 按 data 的值降序排序
        });

    //*
    // 输出排序后的索引顺序
    std::cout << "Sorted indices: ";
    for (int idx : indices) {
        std::cout << idx << " ";
    }
    std::cout << std::endl;

    // 输出排序后的数组
    std::cout << "Sorted values: ";
    for (int idx : indices) {
        std::cout << agents_task_gap[idx] << " ";
    }
    std::cout << std::endl;
     //*/

    vector<int> task_agent_second(110000, -1);

    // iterate over the free agents to decide which task to assign to each of them
    int second_total_assign_span = 0;
    for (int i = 0; i < free_agents_vector.size(); i++)
    {
        int position = indices[i]; // 排序后的索引

        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int agent_id = free_agents_vector[position];

        assert(env->curr_task_schedule[agent_id] == -1);

        min_task_i = -1;
        min_task_makespan = INT_MAX;

        count = 0;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks_vector)
        {

            //check for timeout every 10 task evaluations
            if (count % 10 == 0 && std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations)
            {
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                dist += task_lengths[t_id];
                c_loc = loc;
                break;
            }

            // update the new minimum makespan
            if (dist < min_task_makespan)
            {
                if (task_agent_second[t_id] == -1)
                {
                    min_task_i = t_id;
                    min_task_makespan = dist;
                }
            }

            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1)
        {
            work_assignment[position] = min_task_i;
            task_agent_second[min_task_i] = i;
            second_total_assign_span += min_task_makespan;
        }
    }

    cout << "second total assign span: " << second_total_assign_span << endl;

    for (int i = 0; i < free_agents_vector.size(); i++)
    {
        proposed_schedule[free_agents_vector[i]] = work_assignment[i];

        // 该工人被分配了任务
        if (work_assignment[i] != -1)
        {
            free_agents.erase(free_agents_vector[i]);
            free_tasks.erase(work_assignment[i]);
        }
    }

    cout << "Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// compute total distance of task before assignment
void TaskScheduler::greedy_sum_at_once(int time_limit, std::vector<int> & proposed_schedule)
{
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    int counter = 0;
    for (const int& new_task_id : env->new_tasks)
    {
        // this task distance has been calculated
        int total_dist = 0;
        int curr_loc = env->task_pool[new_task_id].locations[0];

        // iterate over the locations (errands) of the task to compute the makespan to finish the task
        // makespan: the time for the agent to complete all the errands of the task t_id in order
        for (int loc : env->task_pool[new_task_id].locations)
        {
            total_dist += DefaultPlanner::get_h(env, curr_loc, loc);
            curr_loc = loc;
        }

        task_distances[new_task_id] = total_dist;
        counter++;
        // cout << counter << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    // 遍历
    /*
    for (const auto& pair : task_distances) {
        std::cout << "task " << pair.first << " distance " << pair.second << "\n";
    }
     */

    int min_task_i, min_task_makespan, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    int best_total_distance = 0;
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        //keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        min_task_makespan = INT_MAX;
        count = 0;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            //check for timeout every 10 task evaluations
            if (count % 10 == 0 && std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations){
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                dist += task_distances[t_id];
                c_loc = loc;
                break;
            }

            // update the new minimum makespan
            if (dist < min_task_makespan){
                min_task_i = t_id;
                min_task_makespan = dist;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1){
            best_total_distance += min_task_makespan;
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
        }
            // nothing to assign
        else{
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Time Usage: " <<  ((float)(clock() - start))/CLOCKS_PER_SEC <<endl;
    // cout << "best total distance: " << best_total_distance << endl; // 2338
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: "<< env->new_tasks.size() <<  endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 优先给靠近地图角落的agent分配任务, 因为地图边缘不容易堵车。
void TaskScheduler::greedy_sum_suburb_first(int time_limit, std::vector<int> & proposed_schedule)
{
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    std::vector<int> free_agents_vector;
    free_agents_vector.assign(free_agents.begin(), free_agents.end());

    // cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    int min_task_i, min_task_makespan, dist, c_loc, count;
    clock_t start = clock();

    // 每个free agent和地图角落的距离
    vector<int> dist2edges(free_agents_vector.size());
    for(int i=0;i<free_agents_vector.size();i++)
    {
        int agent_loc = env->curr_states.at(free_agents_vector[i]).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;

        dist2edges[i] = std::min(agent_loc_x, env->cols - 1 - agent_loc_x) +
                            std::min(agent_loc_y, env->rows - 1 - agent_loc_y);
    }

    // 索引数组，表示dist2edges原始索引, 也和free_agents_vector的索引对应
    std::vector<int> indices(dist2edges.size());
    for (size_t i = 0; i < indices.size(); ++i) {
        indices[i] = i;
    }

    // 对索引数组进行排序，按照 data 的值排序
    std::sort(indices.begin(), indices.end(), [&](int a, int b) {
        return dist2edges[a] < dist2edges[b];  // 按 data 的值升序排序
    });

    /*
    // 输出排序后的索引顺序
    std::cout << "Sorted indices: ";
    for (int idx : indices) {
        std::cout << idx << " ";
    }
    std::cout << std::endl;

    // 输出排序后的数组
    std::cout << "Sorted values: ";
    for (int idx : indices) {
        std::cout << dist2edges[idx] << " ";
    }
    std::cout << std::endl;
     //*/

    // iterate over the free agents to decide which task to assign to each of them
    for(int i : indices)
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }

        auto agent_id = free_agents_vector[i];
        assert(env->curr_task_schedule[agent_id] == -1);

        min_task_i = -1;
        min_task_makespan = INT_MAX;
        count = 0;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            //check for timeout every 10 task evaluations
            if (count % 10 == 0 && std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(agent_id).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations){
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            // update the new minimum makespan
            if (dist < min_task_makespan){
                min_task_i = t_id;
                min_task_makespan = dist;
            }
            count++;
        }

        // assign the best free task to the agent_id (assuming one exists)
        if (min_task_i != -1){
            proposed_schedule[agent_id] = min_task_i;
            free_agents.erase(agent_id);
            free_tasks.erase(min_task_i);
        }
            // nothing to assign
        else{
            proposed_schedule[agent_id] = -1;
        }
    }

    cout << "Time Usage: " <<  ((float)(clock() - start))/CLOCKS_PER_SEC <<endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: "<< env->new_tasks.size() <<  endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 优先给靠近地图中心的agent分配任务, 因为地图中心更容易堵车。
void TaskScheduler::greedy_sum_urban_first(int time_limit, std::vector<int> & proposed_schedule)
{
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    std::vector<int> free_agents_vector;
    free_agents_vector.assign(free_agents.begin(), free_agents.end());

    // cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    int min_task_i, min_task_makespan, dist, c_loc, count;
    clock_t start = clock();

    // 每个free agent和地图中心的距离
    vector<int> dist2center(free_agents_vector.size());
    for(int i=0;i<free_agents_vector.size();i++)
    {
        int agent_loc = env->curr_states.at(free_agents_vector[i]).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;

        dist2center[i] = std::abs(agent_loc_x - env->cols / 2)
                                  + std::abs(agent_loc_y - env->rows / 2);
    }

    // 索引数组，表示dist2edges原始索引, 也和free_agents_vector的索引对应
    std::vector<int> indices(dist2center.size());
    for (size_t i = 0; i < indices.size(); ++i) {
        indices[i] = i;
    }

    // 对索引数组进行排序，按照 data 的值排序
    std::sort(indices.begin(), indices.end(), [&](int a, int b) {
        return dist2center[a] < dist2center[b];  // 按 data 的值升序排序
    });

    /*
    // 输出排序后的索引顺序
    std::cout << "Sorted indices: ";
    for (int idx : indices) {
        std::cout << idx << " ";
    }
    std::cout << std::endl;

    // 输出排序后的数组
    std::cout << "Sorted values: ";
    for (int idx : indices) {
        std::cout << dist2center[idx] << " ";
    }
    std::cout << std::endl;
     //*/

    // iterate over the free agents to decide which task to assign to each of them
    for(int i : indices)
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }

        auto agent_id = free_agents_vector[i];
        assert(env->curr_task_schedule[agent_id] == -1);

        min_task_i = -1;
        min_task_makespan = INT_MAX;
        count = 0;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            //check for timeout every 10 task evaluations
            if (count % 10 == 0 && std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(agent_id).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations){
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            // update the new minimum makespan
            if (dist < min_task_makespan){
                min_task_i = t_id;
                min_task_makespan = dist;
            }
            count++;
        }

        // assign the best free task to the agent_id (assuming one exists)
        if (min_task_i != -1){
            proposed_schedule[agent_id] = min_task_i;
            free_agents.erase(agent_id);
            free_tasks.erase(min_task_i);
        }
            // nothing to assign
        else{
            proposed_schedule[agent_id] = -1;
        }
    }

    cout << "Time Usage: " <<  ((float)(clock() - start))/CLOCKS_PER_SEC <<endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: "<< env->new_tasks.size() <<  endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 结合greedy_sum_urban_first和adaptive_jam_task_pickup_region_count_current
void TaskScheduler::urban_first_adaptive_jam_task_pickup_region_count_current(int time_limit, std::vector<int>& proposed_schedule)
{
    cout << "urban first adaptive jam task pickup region count current" << endl;
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    if (free_agents.size() > 50)
    {
        if (first_epoch_done_time == -1)
        {
            // 由于大算例初始任务过多, 在初始任务分配完成前采用默认算法
            greedy_sum_without_newtask(time_limit, proposed_schedule);
            return;
        }
    }
    else
    {
        if (first_epoch_done_time == -1)
        {
            first_epoch_done_time = env->curr_timestep; // 初始阶段的任务分配完毕的时间
        }
    }

    int region_column = 12; // 每个region所占的列数
    int region_row = 12; // 每个region所占的行数

    // 地图有几列region
    int num_region_column = std::ceil((double)env->cols / region_column);
    // 地图有几行region
    int num_region_row = std::ceil((double)env->rows / region_row);

    // 将map分为若干区域, 统计每个区域agent的数量
    vector<int> region_agent_num(num_region_column * num_region_row, 0);

    for (int i = 0; i < env->num_of_agents; i++)
    {
        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;

        int agent_region_x = agent_loc_x / region_column;
        int agent_region_y = agent_loc_y / region_row;

        region_agent_num[agent_region_y * num_region_column + agent_region_x]++;
    }

    /*
    cout << "region agent num: ";
    for(int i : region_agent_num)
    {
        cout << i << " ";
    }
    cout << endl;
     //*/

    std::vector<int> free_agents_vector;
    free_agents_vector.assign(free_agents.begin(), free_agents.end());
     // 每个free agent和地图中心的距离
    vector<int> dist2center(free_agents_vector.size());
    for (int i = 0; i < free_agents_vector.size(); i++)
    {
        int agent_loc = env->curr_states.at(free_agents_vector[i]).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;

        dist2center[i] = std::abs(agent_loc_x - env->cols / 2)
            + std::abs(agent_loc_y - env->rows / 2);
    }

    // 索引数组，表示dist2edges原始索引, 也和free_agents_vector的索引对应
    std::vector<int> indices(dist2center.size());
    for (size_t i = 0; i < indices.size(); ++i) {
        indices[i] = i;
    }

    // 对索引数组进行排序，按照 data 的值排序
    std::sort(indices.begin(), indices.end(), [&](int a, int b) {
        return dist2center[a] < dist2center[b];  // 按 data 的值升序排序
        });

    /*
    // 输出排序后的索引顺序
    std::cout << "Sorted indices: ";
    for (int idx : indices) {
        std::cout << idx << " ";
    }
    std::cout << std::endl;

    // 输出排序后的数组
    std::cout << "Sorted values: ";
    for (int idx : indices) {
        std::cout << dist2center[idx] << " ";
    }
    std::cout << std::endl;
     //*/

    if (env->num_of_agents <= 500) // 小算例直接算
    {
        for (int t_id : env->new_tasks)
        {
            int pickup_loc = env->task_pool[t_id].locations[0];
            int pickup_loc_x = pickup_loc % env->cols;
            int pickup_loc_y = pickup_loc / env->cols;

            int pickup_region_x = pickup_loc_x / region_column;
            int pickup_region_y = pickup_loc_y / region_row;

            task_region[t_id] = pickup_region_y * num_region_column + pickup_region_x;
        }
    }
    else // 大算例
    {
        if (env->curr_timestep == first_epoch_done_time) // 在first_epoch_done_time计算完此时的free tasks
        {
            for (int t_id : free_tasks)
            {
                int pickup_loc = env->task_pool[t_id].locations[0];
                int pickup_loc_x = pickup_loc % env->cols;
                int pickup_loc_y = pickup_loc / env->cols;

                int pickup_region_x = pickup_loc_x / region_column;
                int pickup_region_y = pickup_loc_y / region_row;

                task_region[t_id] = pickup_region_y * num_region_column + pickup_region_x;
            }
        }
        else // first_epoch_done_time之后就只计算新任务
        {
            for (int t_id : env->new_tasks)
            {
                int pickup_loc = env->task_pool[t_id].locations[0];
                int pickup_loc_x = pickup_loc % env->cols;
                int pickup_loc_y = pickup_loc / env->cols;

                int pickup_region_x = pickup_loc_x / region_column;
                int pickup_region_y = pickup_loc_y / region_row;

                task_region[t_id] = pickup_region_y * num_region_column + pickup_region_x;
            }
        }
    }


    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    for (int i : indices)
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }

        auto agent_id = free_agents_vector[i];
        assert(env->curr_task_schedule[agent_id] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            // check for timeout every 10 task evaluations
            if (std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(agent_id).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations) {
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            int sum_jam_weight = region_agent_num[task_region[t_id]];

            // sum_jam_weight * jam_coefficient = estimated delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic) {
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1) {
            proposed_schedule[agent_id] = min_task_i;
            free_agents.erase(agent_id);
            free_tasks.erase(min_task_i);
            agent_task[agent_id].task_id = min_task_i;
            agent_task[agent_id].min_task_dist = min_task_dist;
            agent_task[agent_id].task_heuristic = min_task_heuristic;
            agent_task[agent_id].assign_moment = env->curr_timestep; // assign task moment
            agent_task[agent_id].jam_when_assign = corresponding_traffic_jam;
        }
        // nothing to assign
        else {
            proposed_schedule[agent_id] = -1;
        }
    }

    cout << "Task Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}


// 结合greedy_sum_urban_first和adaptive_jam_task_pickup_region_count_current
void TaskScheduler::urban_first_adaptive_jam_task_pickup_region_count_current_not_get(int time_limit, std::vector<int>& proposed_schedule)
{
    cout << "urban first adaptive jam task pickup region count current not get" << endl;
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            /*
            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;
                */
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    if (free_agents.size() > 50)
    {
        if (first_epoch_done_time == -1)
        {
            // 由于大算例初始任务过多, 在初始任务分配完成前采用默认算法
            greedy_sum_without_newtask(time_limit, proposed_schedule);
            return;
        }
    }
    else
    {
        if (first_epoch_done_time == -1)
        {
            first_epoch_done_time = env->curr_timestep; // 初始阶段的任务分配完毕的时间
        }
    }

    int region_column = 12; // 每个region所占的列数
    int region_row = 12; // 每个region所占的行数

    // 地图有几列region
    int num_region_column = std::ceil((double)env->cols / region_column);
    // 地图有几行region
    int num_region_row = std::ceil((double)env->rows / region_row);

    // 将map分为若干区域, 统计每个区域agent的数量
    vector<int> region_agent_num(num_region_column * num_region_row, 0);

    for (int i = 0; i < env->num_of_agents; i++)
    {
        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;

        int agent_region_x = agent_loc_x / region_column;
        int agent_region_y = agent_loc_y / region_row;

        region_agent_num[agent_region_y * num_region_column + agent_region_x]++;
    }

    /*
    cout << "region agent num: ";
    for(int i : region_agent_num)
    {
        cout << i << " ";
    }
    cout << endl;
     //*/

    std::vector<int> free_agents_vector;
    free_agents_vector.assign(free_agents.begin(), free_agents.end());
    // 每个free agent和地图中心的距离
    vector<int> dist2center(free_agents_vector.size());
    for (int i = 0; i < free_agents_vector.size(); i++)
    {
        int agent_loc = env->curr_states.at(free_agents_vector[i]).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;

        dist2center[i] = std::abs(agent_loc_x - env->cols / 2)
            + std::abs(agent_loc_y - env->rows / 2);
    }

    // 索引数组，表示dist2edges原始索引, 也和free_agents_vector的索引对应
    std::vector<int> indices(dist2center.size());
    for (size_t i = 0; i < indices.size(); ++i) {
        indices[i] = i;
    }

    // 对索引数组进行排序，按照 data 的值排序
    std::sort(indices.begin(), indices.end(), [&](int a, int b) {
        return dist2center[a] < dist2center[b];  // 按 data 的值升序排序
        });

    /*
    // 输出排序后的索引顺序
    std::cout << "Sorted indices: ";
    for (int idx : indices) {
        std::cout << idx << " ";
    }
    std::cout << std::endl;

    // 输出排序后的数组
    std::cout << "Sorted values: ";
    for (int idx : indices) {
        std::cout << dist2center[idx] << " ";
    }
    std::cout << std::endl;
     //*/

    if (env->num_of_agents <= 500) // 小算例直接算
    {
        for (int t_id : env->new_tasks)
        {
            int pickup_loc = env->task_pool[t_id].locations[0];
            int pickup_loc_x = pickup_loc % env->cols;
            int pickup_loc_y = pickup_loc / env->cols;

            int pickup_region_x = pickup_loc_x / region_column;
            int pickup_region_y = pickup_loc_y / region_row;

            task_region[t_id] = pickup_region_y * num_region_column + pickup_region_x;
        }
    }
    else // 大算例
    {
        if (env->curr_timestep == first_epoch_done_time) // 在first_epoch_done_time计算完此时的free tasks
        {
            for (int t_id : free_tasks)
            {
                int pickup_loc = env->task_pool[t_id].locations[0];
                int pickup_loc_x = pickup_loc % env->cols;
                int pickup_loc_y = pickup_loc / env->cols;

                int pickup_region_x = pickup_loc_x / region_column;
                int pickup_region_y = pickup_loc_y / region_row;

                task_region[t_id] = pickup_region_y * num_region_column + pickup_region_x;
            }
        }
        else // first_epoch_done_time之后就只计算新任务
        {
            for (int t_id : env->new_tasks)
            {
                int pickup_loc = env->task_pool[t_id].locations[0];
                int pickup_loc_x = pickup_loc % env->cols;
                int pickup_loc_y = pickup_loc / env->cols;

                int pickup_region_x = pickup_loc_x / region_column;
                int pickup_region_y = pickup_loc_y / region_row;

                task_region[t_id] = pickup_region_y * num_region_column + pickup_region_x;
            }
        }
    }


    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    for (int i : indices)
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }

        auto agent_id = free_agents_vector[i];
        assert(env->curr_task_schedule[agent_id] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            // check for timeout every 10 task evaluations
            if (std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(agent_id).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations) {
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            int sum_jam_weight = region_agent_num[task_region[t_id]];

            // sum_jam_weight * jam_coefficient = estimated delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic) {
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1 && min_task_dist < 4995 - env->curr_timestep)
        {
            proposed_schedule[agent_id] = min_task_i;
            free_agents.erase(agent_id);
            free_tasks.erase(min_task_i);
            agent_task[agent_id].task_id = min_task_i;
            agent_task[agent_id].min_task_dist = min_task_dist;
            agent_task[agent_id].task_heuristic = min_task_heuristic;
            agent_task[agent_id].assign_moment = env->curr_timestep; // assign task moment
            agent_task[agent_id].jam_when_assign = corresponding_traffic_jam;
        }
        // nothing to assign
        else {
            proposed_schedule[agent_id] = -1;
        }
    }

    cout << "Task Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 优先给区域车流稀疏的agent分配任务, 因为车流稀疏区域不容易堵车。
void TaskScheduler::greedy_sum_sparse_region_first(int time_limit, std::vector<int> & proposed_schedule)
{
    cout << "greedy sum sparse first" << endl;
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    if (free_agents.size() > 50)
    {
        if (first_epoch_done_time == -1)
        {
            // 由于大算例初始任务过多, 在初始任务分配完成前采用默认算法
            greedy_sum_without_newtask(time_limit, proposed_schedule);
            return;
        }
    }
    else
    {
        if (first_epoch_done_time == -1)
        {
            first_epoch_done_time = env->curr_timestep; // 初始阶段的任务分配完毕的时间
        }
    }

    int region_column = 16; // 每个region所占的列数
    int region_row = 16; // 每个region所占的行数

    // 地图有几列region
    int num_region_column = std::ceil((double)env->cols / region_column);
    // 地图有几行region
    int num_region_row = std::ceil((double)env->rows / region_row);

    // 将map分为若干区域, 统计每个区域agent的数量
    vector<int> region_agent_num(num_region_column * num_region_row, 0);
    // Step 1: 统计每个区域agent的数量。
    for (int i = 0; i < env->num_of_agents; i++)
    {
        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;

        int agent_region_x = agent_loc_x / region_column;
        int agent_region_y = agent_loc_y / region_row;

        region_agent_num[agent_region_y * num_region_column + agent_region_x]++;
    }

    /*
    cout << "region agent num: ";
    for(int i : region_agent_num)
    {
        cout << i << " ";
    }
    cout << endl;
     //*/

     // Step 2: 计算每个free agent所在区域的agent数量。
    std::vector<int> free_agents_vector;
    free_agents_vector.assign(free_agents.begin(), free_agents.end());

    vector<int> free_agents_region_agent_num(free_agents_vector.size());
    for (int i = 0; i < free_agents_vector.size(); i++)
    {
        int agent_loc = env->curr_states.at(free_agents_vector[i]).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;

        int agent_region_x = agent_loc_x / region_column;
        int agent_region_y = agent_loc_y / region_row;

        free_agents_region_agent_num[i] = region_agent_num[agent_region_y * num_region_column + agent_region_x];
    }

    // 索引数组，表示free_agents_region_agent_num原始索引, 也和free_agents_vector的索引对应
    std::vector<int> indices(free_agents_region_agent_num.size());
    for (size_t i = 0; i < indices.size(); ++i)
    {
        indices[i] = i;
    }

    // 对索引数组进行排序，按照 data 的值排序
    std::sort(indices.begin(), indices.end(), [&](int a, int b) {
        return free_agents_region_agent_num[a] < free_agents_region_agent_num[b];  // 按 data 的值升序(<)排序
        });

    /*
    // 输出排序后的索引顺序
    std::cout << "Sorted indices: ";
    for (int idx : indices) {
        std::cout << idx << " ";
    }
    std::cout << std::endl;

    // 输出排序后的数组
    std::cout << "Sorted values: ";
    for (int idx : indices) {
        std::cout << free_agents_region_agent_num[idx] << " ";
    }
    std::cout << std::endl;
    //*/

    int min_task_i, min_task_makespan, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    for (int i : indices)
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }

        auto agent_id = free_agents_vector[i];
        assert(env->curr_task_schedule[agent_id] == -1);

        min_task_i = -1;
        min_task_makespan = INT_MAX;
        count = 0;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            //check for timeout every 10 task evaluations
            if (count % 10 == 0 && std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(agent_id).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations) {
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            // update the new minimum makespan
            if (dist < min_task_makespan) {
                min_task_i = t_id;
                min_task_makespan = dist;
            }
            count++;
        }

        // assign the best free task to the agent_id (assuming one exists)
        if (min_task_i != -1) {
            proposed_schedule[agent_id] = min_task_i;
            free_agents.erase(agent_id);
            free_tasks.erase(min_task_i);
        }
        // nothing to assign
        else {
            proposed_schedule[agent_id] = -1;
        }
    }

    cout << "Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 优先给区域等待点多的agent分配任务, 因为区域等待点多更容易堵车。
void TaskScheduler::greedy_sum_sparse_wait_region_first(int time_limit, std::vector<int>& proposed_schedule)
{
    cout << "greedy sum sparse wait region first" << endl;
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    if (free_agents.size() > 50)
    {
        if (first_epoch_done_time == -1)
        {
            // 由于大算例初始任务过多, 在初始任务分配完成前采用默认算法
            greedy_sum_without_newtask(time_limit, proposed_schedule);
            return;
        }
    }
    else
    {
        if (first_epoch_done_time == -1)
        {
            first_epoch_done_time = env->curr_timestep; // 初始阶段的任务分配完毕的时间
        }
    }

    int region_column = 16; // 每个region所占的列数
    int region_row = 16; // 每个region所占的行数

    // 地图有几列region
    int num_region_column = std::ceil((double)env->cols / region_column);
    // 地图有几行region
    int num_region_row = std::ceil((double)env->rows / region_row);

    // 将map分为若干区域, 统计每个区域等待点的数量
    vector<int> current_region_wait_num(num_region_column * num_region_row, 0);
    // Step 1: 统计每个区域等待点的数量。
    for (int i = 0; i < env->num_of_agents; i++)
    {
        // 如果和前一时刻位置和方向一样, 则陷入等待
        if (env->curr_states.at(i).location == prev_states[i].location
            && env->curr_states.at(i).orientation == prev_states[i].orientation)
        {
            int agent_loc = env->curr_states.at(i).location;
            int agent_loc_x = agent_loc % env->cols;
            int agent_loc_y = agent_loc / env->cols;

            int agent_region_x = agent_loc_x / region_column;
            int agent_region_y = agent_loc_y / region_row;

            current_region_wait_num[agent_region_y * num_region_column + agent_region_x]++;
        }
    }

    /*
    cout << "current region wait num: ";
    for (int i : current_small_region_wait_num)
    {
        cout << i << " ";
    }
    cout << endl;
    //*/

    // Step 2: 计算每个free agent所在区域的agent数量。
    std::vector<int> free_agents_vector;
    free_agents_vector.assign(free_agents.begin(), free_agents.end());

    vector<int> free_agents_region_wait_num(free_agents_vector.size());
    for (int i = 0; i < free_agents_vector.size(); i++)
    {
        int agent_loc = env->curr_states.at(free_agents_vector[i]).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;

        int agent_region_x = agent_loc_x / region_column;
        int agent_region_y = agent_loc_y / region_row;

        free_agents_region_wait_num[i] = current_region_wait_num[agent_region_y * num_region_column + agent_region_x];
    }

    // 索引数组，表示free_agents_region_agent_num原始索引, 也和free_agents_vector的索引对应
    std::vector<int> indices(free_agents_region_wait_num.size());
    for (size_t i = 0; i < indices.size(); ++i)
    {
        indices[i] = i;
    }

    // 对索引数组进行排序，按照 data 的值排序
    std::sort(indices.begin(), indices.end(), [&](int a, int b) {
        return free_agents_region_wait_num[a] < free_agents_region_wait_num[b];  // 按 data 的值升序(<)排序
        });

    //*
    // 输出排序后的索引顺序
    std::cout << "Sorted indices: ";
    for (int idx : indices) {
        std::cout << idx << " ";
    }
    std::cout << std::endl;

    // 输出排序后的数组
    std::cout << "Sorted values: ";
    for (int idx : indices) {
        std::cout << free_agents_region_wait_num[idx] << " ";
    }
    std::cout << std::endl;
     //*/

    int min_task_i, min_task_makespan, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    for (int i : indices)
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }

        auto agent_id = free_agents_vector[i];
        assert(env->curr_task_schedule[agent_id] == -1);

        min_task_i = -1;
        min_task_makespan = INT_MAX;
        count = 0;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            //check for timeout every 10 task evaluations
            if (count % 10 == 0 && std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(agent_id).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations) {
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            // update the new minimum makespan
            if (dist < min_task_makespan) {
                min_task_i = t_id;
                min_task_makespan = dist;
            }
            count++;
        }

        // assign the best free task to the agent_id (assuming one exists)
        if (min_task_i != -1) {
            proposed_schedule[agent_id] = min_task_i;
            free_agents.erase(agent_id);
            free_tasks.erase(min_task_i);
        }
        // nothing to assign
        else {
            proposed_schedule[agent_id] = -1;
        }
    }

    prev_states = env->curr_states; // 更新prev states for all agents

    cout << "Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 优先给历史区域等待点少的agent分配任务, 因为历史区域等待点少不容易堵车。
void TaskScheduler::greedy_sum_all_time_sparse_wait_region_first(int time_limit, std::vector<int>& proposed_schedule)
{
    cout << "greedy sum all time sparse wait region first" << endl;
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    if (free_agents.size() > 50)
    {
        if (first_epoch_done_time == -1)
        {
            // 由于大算例初始任务过多, 在初始任务分配完成前采用默认算法
            greedy_sum_without_newtask(time_limit, proposed_schedule);
            return;
        }
    }
    else
    {
        if (first_epoch_done_time == -1)
        {
            first_epoch_done_time = env->curr_timestep; // 初始阶段的任务分配完毕的时间
        }
    }

    // Step 1: 统计每个区域等待点的数量。
    for (int i = 0; i < env->num_of_agents; i++)
    {
        // 如果和前一时刻位置和方向一样, 则陷入等待
        if (env->curr_states.at(i).location == prev_states[i].location
            && env->curr_states.at(i).orientation == prev_states[i].orientation)
        {
            int agent_loc = env->curr_states.at(i).location;
            int agent_loc_x = agent_loc % env->cols;
            int agent_loc_y = agent_loc / env->cols;

            int agent_region_x = agent_loc_x / small_region_column;
            int agent_region_y = agent_loc_y / small_region_row;

            small_region_wait_num[agent_region_y * num_small_region_column + agent_region_x]++;
        }
    }

    /*
    cout << "current region wait num: ";
    for (int i : current_small_region_wait_num)
    {
        cout << i << " ";
    }
    cout << endl;
    //*/

    // Step 2: 计算每个free agent所在区域的agent数量。
    std::vector<int> free_agents_vector;
    free_agents_vector.assign(free_agents.begin(), free_agents.end());

    vector<int> free_agents_region_wait_num(free_agents_vector.size());
    for (int i = 0; i < free_agents_vector.size(); i++)
    {
        int agent_loc = env->curr_states.at(free_agents_vector[i]).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;

        int agent_region_x = agent_loc_x / small_region_column;
        int agent_region_y = agent_loc_y / small_region_row;

        free_agents_region_wait_num[i] = small_region_wait_num[agent_region_y * num_small_region_column + agent_region_x];
    }

    // 索引数组，表示free_agents_region_agent_num原始索引, 也和free_agents_vector的索引对应
    std::vector<int> indices(free_agents_region_wait_num.size());
    for (size_t i = 0; i < indices.size(); ++i)
    {
        indices[i] = i;
    }

    // 对索引数组进行排序，按照 data 的值排序
    std::sort(indices.begin(), indices.end(), [&](int a, int b) {
        return free_agents_region_wait_num[a] < free_agents_region_wait_num[b];  // 按 data 的值升序(<)排序
        });

    /*
    // 输出排序后的索引顺序
    std::cout << "Sorted indices: ";
    for (int idx : indices) {
        std::cout << idx << " ";
    }
    std::cout << std::endl;

    // 输出排序后的数组
    std::cout << "Sorted values: ";
    for (int idx : indices) {
        std::cout << free_agents_region_wait_num[idx] << " ";
    }
    std::cout << std::endl;
    //*/

    int min_task_i, min_task_makespan, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    for (int i : indices)
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }

        auto agent_id = free_agents_vector[i];
        assert(env->curr_task_schedule[agent_id] == -1);

        min_task_i = -1;
        min_task_makespan = INT_MAX;
        count = 0;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            //check for timeout every 10 task evaluations
            if (count % 10 == 0 && std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(agent_id).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations) {
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            // update the new minimum makespan
            if (dist < min_task_makespan) {
                min_task_i = t_id;
                min_task_makespan = dist;
            }
            count++;
        }

        // assign the best free task to the agent_id (assuming one exists)
        if (min_task_i != -1) {
            proposed_schedule[agent_id] = min_task_i;
            free_agents.erase(agent_id);
            free_tasks.erase(min_task_i);
        }
        // nothing to assign
        else {
            proposed_schedule[agent_id] = -1;
        }
    }

    prev_states = env->curr_states; // 更新prev states for all agents

    cout << "Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 优先给区域车流密集的agent分配任务, 因为车流密集区域更容易堵车。
void TaskScheduler::greedy_sum_dense_region_first(int time_limit, std::vector<int> & proposed_schedule)
{
    cout << "greedy sum dense first" << endl;
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    if (free_agents.size() > 50)
    {
        if (first_epoch_done_time == -1)
        {
            // 由于大算例初始任务过多, 在初始任务分配完成前采用默认算法
            greedy_sum_without_newtask(time_limit, proposed_schedule);
            return;
        }
    }
    else
    {
        if (first_epoch_done_time == -1)
        {
            first_epoch_done_time = env->curr_timestep; // 初始阶段的任务分配完毕的时间
        }
    }

    int region_column = 16; // 每个region所占的列数
    int region_row = 16; // 每个region所占的行数

    // 地图有几列region
    int num_region_column = std::ceil((double)env->cols / region_column);
    // 地图有几行region
    int num_region_row = std::ceil((double)env->rows / region_row);

    // 将map分为若干区域, 统计每个区域agent的数量
    vector<int> region_agent_num(num_region_column * num_region_row, 0);
    // Step 1: 统计每个区域agent的数量。
    for (int i = 0; i < env->num_of_agents; i++)
    {
        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;

        int agent_region_x = agent_loc_x / region_column;
        int agent_region_y = agent_loc_y / region_row;

        region_agent_num[agent_region_y * num_region_column + agent_region_x]++;
    }

    /*
    cout << "region agent num: ";
    for(int i : region_agent_num)
    {
        cout << i << " ";
    }
    cout << endl;
     //*/

    // Step 2: 计算每个free agent所在区域的agent数量。
    std::vector<int> free_agents_vector;
    free_agents_vector.assign(free_agents.begin(), free_agents.end());

    vector<int> free_agents_region_agent_num(free_agents_vector.size());
    for (int i = 0; i < free_agents_vector.size(); i++)
    {
        int agent_loc = env->curr_states.at(free_agents_vector[i]).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;

        int agent_region_x = agent_loc_x / region_column;
        int agent_region_y = agent_loc_y / region_row;

        free_agents_region_agent_num[i] = region_agent_num[agent_region_y * num_region_column + agent_region_x];
    }

    // 索引数组，表示free_agents_region_agent_num原始索引, 也和free_agents_vector的索引对应
    std::vector<int> indices(free_agents_region_agent_num.size());
    for (size_t i = 0; i < indices.size(); ++i) 
    {
        indices[i] = i;
    }

    // 对索引数组进行排序，按照 data 的值排序
    std::sort(indices.begin(), indices.end(), [&](int a, int b) {
        return free_agents_region_agent_num[a] > free_agents_region_agent_num[b];  // 按 data 的值降序(>)排序
        });

    /*
    // 输出排序后的索引顺序
    std::cout << "Sorted indices: ";
    for (int idx : indices) {
        std::cout << idx << " ";
    }
    std::cout << std::endl;

    // 输出排序后的数组
    std::cout << "Sorted values: ";
    for (int idx : indices) {
        std::cout << free_agents_region_agent_num[idx] << " ";
    }
    std::cout << std::endl;
     //*/

    int min_task_i, min_task_makespan, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    for (int i : indices)
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }

        auto agent_id = free_agents_vector[i];
        assert(env->curr_task_schedule[agent_id] == -1);

        min_task_i = -1;
        min_task_makespan = INT_MAX;
        count = 0;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            //check for timeout every 10 task evaluations
            if (count % 10 == 0 && std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(agent_id).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations) {
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            // update the new minimum makespan
            if (dist < min_task_makespan) {
                min_task_i = t_id;
                min_task_makespan = dist;
            }
            count++;
        }

        // assign the best free task to the agent_id (assuming one exists)
        if (min_task_i != -1) {
            proposed_schedule[agent_id] = min_task_i;
            free_agents.erase(agent_id);
            free_tasks.erase(min_task_i);
        }
        // nothing to assign
        else {
            proposed_schedule[agent_id] = -1;
        }
    }

    cout << "Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 优先给区域等待点多的agent分配任务, 因为区域等待点多更容易堵车。
void TaskScheduler::greedy_sum_dense_wait_region_first(int time_limit, std::vector<int>& proposed_schedule)
{
    cout << "greedy sum dense wait region first" << endl;
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    if (free_agents.size() > 50)
    {
        if (first_epoch_done_time == -1)
        {
            // 由于大算例初始任务过多, 在初始任务分配完成前采用默认算法
            greedy_sum_without_newtask(time_limit, proposed_schedule);
            return;
        }
    }
    else
    {
        if (first_epoch_done_time == -1)
        {
            first_epoch_done_time = env->curr_timestep; // 初始阶段的任务分配完毕的时间
        }
    }

    int region_column = 16; // 每个region所占的列数
    int region_row = 16; // 每个region所占的行数

    // 地图有几列region
    int num_region_column = std::ceil((double)env->cols / region_column);
    // 地图有几行region
    int num_region_row = std::ceil((double)env->rows / region_row);

    // 将map分为若干区域, 统计每个区域等待点的数量
    vector<int> current_region_wait_num(num_region_column * num_region_row, 0);
    // Step 1: 统计每个区域等待点的数量。
    for (int i = 0; i < env->num_of_agents; i++)
    {
        // 如果和前一时刻位置和方向一样, 则陷入等待
        if (env->curr_states.at(i).location == prev_states[i].location
            && env->curr_states.at(i).orientation == prev_states[i].orientation)
        {
            int agent_loc = env->curr_states.at(i).location;
            int agent_loc_x = agent_loc % env->cols;
            int agent_loc_y = agent_loc / env->cols;

            int agent_region_x = agent_loc_x / region_column;
            int agent_region_y = agent_loc_y / region_row;

            current_region_wait_num[agent_region_y * num_region_column + agent_region_x]++;
        }
    }

    /*
    cout << "current region wait num: ";
    for (int i : current_small_region_wait_num)
    {
        cout << i << " ";
    }
    cout << endl;
    //*/

     // Step 2: 计算每个free agent所在区域的agent数量。
    std::vector<int> free_agents_vector;
    free_agents_vector.assign(free_agents.begin(), free_agents.end());

    vector<int> free_agents_region_wait_num(free_agents_vector.size());
    for (int i = 0; i < free_agents_vector.size(); i++)
    {
        int agent_loc = env->curr_states.at(free_agents_vector[i]).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;

        int agent_region_x = agent_loc_x / region_column;
        int agent_region_y = agent_loc_y / region_row;

        free_agents_region_wait_num[i] = current_region_wait_num[agent_region_y * num_region_column + agent_region_x];
    }

    // 索引数组，表示free_agents_region_agent_num原始索引, 也和free_agents_vector的索引对应
    std::vector<int> indices(free_agents_region_wait_num.size());
    for (size_t i = 0; i < indices.size(); ++i)
    {
        indices[i] = i;
    }

    // 对索引数组进行排序，按照 data 的值排序
    std::sort(indices.begin(), indices.end(), [&](int a, int b) {
        return free_agents_region_wait_num[a] > free_agents_region_wait_num[b];  // 按 data 的值降序(>)排序
        });

    /*
    // 输出排序后的索引顺序
    std::cout << "Sorted indices: ";
    for (int idx : indices) {
        std::cout << idx << " ";
    }
    std::cout << std::endl;

    // 输出排序后的数组
    std::cout << "Sorted values: ";
    for (int idx : indices) {
        std::cout << free_agents_region_wait_num[idx] << " ";
    }
    std::cout << std::endl;
     //*/

    int min_task_i, min_task_makespan, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    for (int i : indices)
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }

        auto agent_id = free_agents_vector[i];
        assert(env->curr_task_schedule[agent_id] == -1);

        min_task_i = -1;
        min_task_makespan = INT_MAX;
        count = 0;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            //check for timeout every 10 task evaluations
            if (count % 10 == 0 && std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(agent_id).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations) {
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            // update the new minimum makespan
            if (dist < min_task_makespan) {
                min_task_i = t_id;
                min_task_makespan = dist;
            }
            count++;
        }

        // assign the best free task to the agent_id (assuming one exists)
        if (min_task_i != -1) {
            proposed_schedule[agent_id] = min_task_i;
            free_agents.erase(agent_id);
            free_tasks.erase(min_task_i);
        }
        // nothing to assign
        else {
            proposed_schedule[agent_id] = -1;
        }
    }

    prev_states = env->curr_states; // 更新prev states for all agents

    cout << "Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 优先给历史区域等待点多的agent分配任务, 因为历史区域等待点多容易堵车。
void TaskScheduler::greedy_sum_all_time_dense_wait_region_first(int time_limit, std::vector<int>& proposed_schedule)
{
    cout << "greedy sum all time dense wait region first" << endl;
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    if (free_agents.size() > 50)
    {
        if (first_epoch_done_time == -1)
        {
            // 由于大算例初始任务过多, 在初始任务分配完成前采用默认算法
            greedy_sum_without_newtask(time_limit, proposed_schedule);
            return;
        }
    }
    else
    {
        if (first_epoch_done_time == -1)
        {
            first_epoch_done_time = env->curr_timestep; // 初始阶段的任务分配完毕的时间
        }
    }

    // Step 1: 统计每个区域等待点的数量。
    for (int i = 0; i < env->num_of_agents; i++)
    {
        // 如果和前一时刻位置和方向一样, 则陷入等待
        if (env->curr_states.at(i).location == prev_states[i].location
            && env->curr_states.at(i).orientation == prev_states[i].orientation)
        {
            int agent_loc = env->curr_states.at(i).location;
            int agent_loc_x = agent_loc % env->cols;
            int agent_loc_y = agent_loc / env->cols;

            int agent_region_x = agent_loc_x / small_region_column;
            int agent_region_y = agent_loc_y / small_region_row;

            small_region_wait_num[agent_region_y * num_small_region_column + agent_region_x]++;
        }
    }

    /*
    cout << "current region wait num: ";
    for (int i : current_small_region_wait_num)
    {
        cout << i << " ";
    }
    cout << endl;
    //*/

    // Step 2: 计算每个free agent所在区域的agent数量。
    std::vector<int> free_agents_vector;
    free_agents_vector.assign(free_agents.begin(), free_agents.end());

    vector<int> free_agents_region_wait_num(free_agents_vector.size());
    for (int i = 0; i < free_agents_vector.size(); i++)
    {
        int agent_loc = env->curr_states.at(free_agents_vector[i]).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;

        int agent_region_x = agent_loc_x / small_region_column;
        int agent_region_y = agent_loc_y / small_region_row;

        free_agents_region_wait_num[i] = small_region_wait_num[agent_region_y * num_small_region_column + agent_region_x];
    }

    // 索引数组，表示free_agents_region_agent_num原始索引, 也和free_agents_vector的索引对应
    std::vector<int> indices(free_agents_region_wait_num.size());
    for (size_t i = 0; i < indices.size(); ++i)
    {
        indices[i] = i;
    }

    // 对索引数组进行排序，按照 data 的值排序
    std::sort(indices.begin(), indices.end(), [&](int a, int b) {
        return free_agents_region_wait_num[a] > free_agents_region_wait_num[b];  // 按 data 的值降序(>)排序
        });

    //*
    // 输出排序后的索引顺序
    std::cout << "Sorted indices: ";
    for (int idx : indices) {
        std::cout << idx << " ";
    }
    std::cout << std::endl;

    // 输出排序后的数组
    std::cout << "Sorted values: ";
    for (int idx : indices) {
        std::cout << free_agents_region_wait_num[idx] << " ";
    }
    std::cout << std::endl;
    //*/

    int min_task_i, min_task_makespan, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    for (int i : indices)
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }

        auto agent_id = free_agents_vector[i];
        assert(env->curr_task_schedule[agent_id] == -1);

        min_task_i = -1;
        min_task_makespan = INT_MAX;
        count = 0;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            //check for timeout every 10 task evaluations
            if (count % 10 == 0 && std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(agent_id).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations) {
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            // update the new minimum makespan
            if (dist < min_task_makespan) {
                min_task_i = t_id;
                min_task_makespan = dist;
            }
            count++;
        }

        // assign the best free task to the agent_id (assuming one exists)
        if (min_task_i != -1) {
            proposed_schedule[agent_id] = min_task_i;
            free_agents.erase(agent_id);
            free_tasks.erase(min_task_i);
        }
        // nothing to assign
        else {
            proposed_schedule[agent_id] = -1;
        }
    }

    prev_states = env->curr_states; // 更新prev states for all agents

    cout << "Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 匈牙利分配算法，cost只计算agent和任务pickup点的位置。
void TaskScheduler::hungarian_only_first(int time_limit, std::vector<int> & proposed_schedule)
{
    //use at most half of time_limit to compute schedule, -10 for timing error tolerance
    //so that the remainning time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;
    clock_t start = clock();

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    if(free_agents.empty())
    {
        return;
    }

    std::vector<int> free_agents_vec;
    free_agents_vec.assign(free_agents.begin(), free_agents.end());

    std::vector<int> free_tasks_vec;
    free_tasks_vec.assign(free_tasks.begin(), free_tasks.end());

    // 每个时间步，空闲agent数量等于新出现任务的数量。
    // cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    vector< vector<double> > cost_matrix;
    cost_matrix.resize(free_agents.size());
    for(int i=0;i<cost_matrix.size();i++)
    {
        auto agent_id = free_agents_vec[i];

        cost_matrix[i].resize(free_tasks.size(), 0);
        for(int j=0;j<free_tasks.size();j++)
        {
            auto task_id = free_tasks_vec[j];

            int dist = 0;
            int curr_loc = env->curr_states.at(agent_id).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[task_id].locations){
                dist += DefaultPlanner::get_h(env, curr_loc, loc);
                curr_loc = loc;
                break; // schedule only first
            }

            // 计算agent id完成task id的成本
            cost_matrix[i][j] = dist;
        }
    }

    vector<int> work_assignment; // "worker " << i << ", assignment " << work_assignment[i]
    Hungarian HungAlgo(cost_matrix);
    // HungAlgo.print_cost_matrix();
    double cost = HungAlgo.Solve(work_assignment);
    for(int i=0;i<free_agents_vec.size();i++)
    {
        // 该工人被分配了任务
        if(work_assignment[i] != -1)
        {
            free_agents.erase(free_agents_vec[i]);
            free_tasks.erase(free_tasks_vec[work_assignment[i]]);
        }

        proposed_schedule[free_agents_vec[i]] = free_tasks_vec[work_assignment[i]];
    }

    cout << "Time Usage: " <<  ((float)(clock() - start))/CLOCKS_PER_SEC <<endl;
}

// hungarian schedule only distance to pickup location and snatch order
void TaskScheduler::hungarian_pickup_snatch(int time_limit, std::vector<int> & proposed_schedule)
{
    //use at most half of time_limit to compute schedule, -10 for timing error tolerance
    //so that the remainning time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;
    clock_t start = clock();

    // 没有新agent就不用抢单了
    if(env->new_freeagents.empty())
    {
        return;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    int counter = 0;
    for (const int& free_task_id : free_tasks)
    {
        if (counter % 10 == 0 && std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
    }

    // free agent and agent with task but before pickup
    std::vector<int> free_agents_and_before_pickup;
    free_agents_and_before_pickup.assign(free_agents.begin(), free_agents.end());

    // free tasks and tasks already assigned but before pickup
    std::vector<int> free_tasks_and_before_pickup;
    free_tasks_and_before_pickup.assign(free_tasks.begin(), free_tasks.end());

    for(const auto& element : env->task_pool)
    {
        if(element.second.agent_assigned != -1 && element.second.idx_next_loc == 0)
        {
            free_agents_and_before_pickup.emplace_back(element.second.agent_assigned);
            free_tasks_and_before_pickup.emplace_back(element.second.task_id);
        }
    }

    // 每个时间步，空闲agent数量等于新出现任务的数量。
    // cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    vector< vector<double> > cost_matrix;
    cost_matrix.resize(free_agents_and_before_pickup.size());
    for(int i=0;i<cost_matrix.size();i++)
    {
        auto agent_id = free_agents_and_before_pickup[i];

        cost_matrix[i].resize(free_tasks_and_before_pickup.size(), 0);
        for(int j=0;j<free_tasks_and_before_pickup.size();j++)
        {
            auto task_id = free_tasks_and_before_pickup[j];

            int dist = 0;
            int curr_loc = env->curr_states.at(agent_id).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[task_id].locations){
                dist += DefaultPlanner::get_h(env, curr_loc, loc);
                curr_loc = loc;
                break;
            }

            // 计算agent id完成task id的成本
            cost_matrix[i][j] = dist;
        }
    }

    vector<int> work_assignment; // "worker " << i << ", assignment " << work_assignment[i]
    Hungarian HungAlgo(cost_matrix);
    // HungAlgo.print_cost_matrix();
    // cout << "prev cost: " << prev_best_total_distance << endl;
    int cost = HungAlgo.Solve(work_assignment); // 如果后续算拥堵系数, cost和prev_best的类型改成double
    // cout << "new cost: " << cost << endl;

    if (cost != prev_best_total_distance)
    {
        prev_best_total_distance = cost;
        free_agents.clear();
        free_agents.insert(free_agents_and_before_pickup.begin(), free_agents_and_before_pickup.end());
        free_tasks.clear();
        free_tasks.insert(free_tasks_and_before_pickup.begin(), free_tasks_and_before_pickup.end());

        for(int i=0; i < free_agents_and_before_pickup.size(); i++)
        {
            proposed_schedule[free_agents_and_before_pickup[i]] = free_tasks_and_before_pickup[work_assignment[i]];

            // 该工人被分配了任务
            if(work_assignment[i] != -1)
            {
                free_agents.erase(free_agents_and_before_pickup[i]);
                free_tasks.erase(free_tasks_and_before_pickup[work_assignment[i]]);
            }
        }
    }

    /*
    cout << "work assignment: ";
    for(int i=0;i<work_assignment.size();i++)
    {
        cout << work_assignment[i] << " ";
    }
    cout << endl;
     */

    /*
    cout << "proposed schedule: ";
    for(int i=0;i<proposed_schedule.size();i++)
    {
        cout << proposed_schedule[i] << " ";
    }
    cout << endl;
     //*/

    cout << "Time Usage: " <<  ((float)(clock() - start))/CLOCKS_PER_SEC <<endl;
    // cout << "hungarian total distance: " << cost << endl; // 2087, 比默认方法确实缩小了
}

// 匈牙利分配算法, cost使用默认计算方法。
void TaskScheduler::hungarian_sum(int time_limit, std::vector<int> & proposed_schedule)
{
    //use at most half of time_limit to compute schedule, -10 for timing error tolerance
    //so that the remainning time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;
    clock_t start = clock();

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    if(free_agents.empty())
    {
        return;
    }

    std::vector<int> free_agents_vec;
    free_agents_vec.assign(free_agents.begin(), free_agents.end());

    std::vector<int> free_tasks_vec;
    free_tasks_vec.assign(free_tasks.begin(), free_tasks.end());

    // 每个时间步，空闲agent数量等于新出现任务的数量。
    // cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    vector< vector<double> > cost_matrix;
    cost_matrix.resize(free_agents.size());
    for(int i=0;i<cost_matrix.size();i++)
    {
        auto agent_id = free_agents_vec[i];

        cost_matrix[i].resize(free_tasks.size(), 0);
        for(int j=0;j<free_tasks.size();j++)
        {
            auto task_id = free_tasks_vec[j];

            int dist = 0;
            int curr_loc = env->curr_states.at(agent_id).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[task_id].locations){
                dist += DefaultPlanner::get_h(env, curr_loc, loc);
                curr_loc = loc;
            }

            // 计算agent id完成task id的成本
            cost_matrix[i][j] = dist;
        }
    }

    vector<int> work_assignment; // "worker " << i << ", assignment " << work_assignment[i]
    Hungarian HungAlgo(cost_matrix);
    // HungAlgo.print_cost_matrix();
    double cost = HungAlgo.Solve(work_assignment);
    for(int i=0;i<free_agents_vec.size();i++)
    {
        // 该工人被分配了任务
        if(work_assignment[i] != -1)
        {
            free_agents.erase(free_agents_vec[i]);
            free_tasks.erase(free_tasks_vec[work_assignment[i]]);
        }

        proposed_schedule[free_agents_vec[i]] = free_tasks_vec[work_assignment[i]];
    }

    cout << "Time Usage: " <<  ((float)(clock() - start))/CLOCKS_PER_SEC <<endl;
}

// 匈牙利分配算法，一次性把任务长度计算完储存在unordered_map。
void TaskScheduler::hungarian_sum_at_once(int time_limit, std::vector<int> & proposed_schedule)
{
    //use at most half of time_limit to compute schedule, -10 for timing error tolerance
    //so that the remainning time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;
    clock_t start = clock();

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    if(free_agents.empty())
    {
        return;
    }

    int counter = 0;
    for (const int& free_task_id : free_tasks)
    {
        if (counter % 10 == 0 && std::chrono::steady_clock::now() > endtime)
        {
            break;
        }

        // this task distance has been calculated
        if (task_distances.find(free_task_id) == task_distances.end())
        {
            int total_dist = 0;
            int curr_loc = env->task_pool[free_task_id].locations[0];

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[free_task_id].locations)
            {
                total_dist += DefaultPlanner::get_h(env, curr_loc, loc);
                curr_loc = loc;
            }

            task_distances[free_task_id] = total_dist;
            counter++;
            // cout << counter << endl;
        }
        else
        {
            // cout << "already in" << endl;
        }
    }

    std::vector<int> free_agents_vec;
    free_agents_vec.assign(free_agents.begin(), free_agents.end());

    std::vector<int> free_tasks_vec;
    free_tasks_vec.assign(free_tasks.begin(), free_tasks.end());

    // 每个时间步，空闲agent数量等于新出现任务的数量。
    // cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    vector< vector<double> > cost_matrix;
    cost_matrix.resize(free_agents.size());
    for(int i=0;i<cost_matrix.size();i++)
    {
        auto agent_id = free_agents_vec[i];

        cost_matrix[i].resize(free_tasks.size(), 0);
        for(int j=0;j<free_tasks.size();j++)
        {
            auto task_id = free_tasks_vec[j];

            int dist = 0;
            int curr_loc = env->curr_states.at(agent_id).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[task_id].locations){
                dist += DefaultPlanner::get_h(env, curr_loc, loc);
                dist += task_distances[task_id];
                curr_loc = loc;
                break;
            }

            // 计算agent id完成task id的成本
            cost_matrix[i][j] = dist;
        }
    }

    vector<int> work_assignment; // "worker " << i << ", assignment " << work_assignment[i]
    Hungarian HungAlgo(cost_matrix);
    // HungAlgo.print_cost_matrix();
    double cost = HungAlgo.Solve(work_assignment);
    for(int i=0;i<free_agents_vec.size();i++)
    {
        // 该工人被分配了任务
        if(work_assignment[i] != -1)
        {
            free_agents.erase(free_agents_vec[i]);
            free_tasks.erase(free_tasks_vec[work_assignment[i]]);
        }

        proposed_schedule[free_agents_vec[i]] = free_tasks_vec[work_assignment[i]];
    }

    cout << "Time Usage: " <<  ((float)(clock() - start))/CLOCKS_PER_SEC <<endl;
    // cout << "hungarian total distance: " << cost << endl; // 2087, 比默认方法确实缩小了
}

// hungarian schedule sum at once and snatch order
void TaskScheduler::hungarian_sum_snatch(int time_limit, std::vector<int> & proposed_schedule)
{
    //use at most half of time_limit to compute schedule, -10 for timing error tolerance
    //so that the remainning time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;
    clock_t start = clock();

    // 没有新agent就不用抢单了
    if(env->new_freeagents.empty())
    {
        return;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    int counter = 0;
    for (const int& free_task_id : free_tasks)
    {
        if (counter % 10 == 0 && std::chrono::steady_clock::now() > endtime)
        {
            break;
        }

        // this task distance has been calculated
        if (task_distances.find(free_task_id) == task_distances.end())
        {
            int total_dist = 0;
            int curr_loc = env->task_pool[free_task_id].locations[0];

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[free_task_id].locations)
            {
                total_dist += DefaultPlanner::get_h(env, curr_loc, loc);
                curr_loc = loc;
            }

            task_distances[free_task_id] = total_dist;
            counter++;
            // cout << counter << endl;
        }
        else
        {
            // cout << "already in" << endl;
        }
    }

    // free agent and agent with task but before pickup
    std::vector<int> free_agents_and_before_pickup;
    free_agents_and_before_pickup.assign(free_agents.begin(), free_agents.end());

    // free tasks and tasks already assigned but before pickup
    std::vector<int> free_tasks_and_before_pickup;
    free_tasks_and_before_pickup.assign(free_tasks.begin(), free_tasks.end());

    for(const auto& element : env->task_pool)
    {
        if(element.second.agent_assigned != -1 && element.second.idx_next_loc == 0)
        {
            free_agents_and_before_pickup.emplace_back(element.second.agent_assigned);
            free_tasks_and_before_pickup.emplace_back(element.second.task_id);
        }
    }

    // 每个时间步，空闲agent数量等于新出现任务的数量。
    // cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    vector< vector<double> > cost_matrix;
    cost_matrix.resize(free_agents_and_before_pickup.size());
    for(int i=0;i<cost_matrix.size();i++)
    {
        auto agent_id = free_agents_and_before_pickup[i];

        cost_matrix[i].resize(free_tasks_and_before_pickup.size(), 0);
        for(int j=0;j<free_tasks_and_before_pickup.size();j++)
        {
            auto task_id = free_tasks_and_before_pickup[j];
            int curr_loc = env->curr_states.at(agent_id).location;

            // 计算agent id完成task id的成本
            cost_matrix[i][j] = DefaultPlanner::get_h(env, curr_loc,
                                  env->task_pool[task_id].locations[0]) + task_distances[task_id];
        }
    }

    vector<int> work_assignment; // "worker " << i << ", assignment " << work_assignment[i]
    Hungarian HungAlgo(cost_matrix);
    // HungAlgo.print_cost_matrix();
    // cout << "prev cost: " << prev_best_total_distance << endl;
    int cost = HungAlgo.Solve(work_assignment); // 如果后续算拥堵系数, cost和prev_best的类型改成double
    // cout << "new cost: " << cost << endl;

    if (cost != prev_best_total_distance)
    {
        prev_best_total_distance = cost;
        free_agents.clear();
        free_agents.insert(free_agents_and_before_pickup.begin(), free_agents_and_before_pickup.end());
        free_tasks.clear();
        free_tasks.insert(free_tasks_and_before_pickup.begin(), free_tasks_and_before_pickup.end());

        for(int i=0; i < free_agents_and_before_pickup.size(); i++)
        {
            proposed_schedule[free_agents_and_before_pickup[i]] = free_tasks_and_before_pickup[work_assignment[i]];

            // 该工人被分配了任务
            if(work_assignment[i] != -1)
            {
                free_agents.erase(free_agents_and_before_pickup[i]);
                free_tasks.erase(free_tasks_and_before_pickup[work_assignment[i]]);
            }
        }
    }

    /*
    cout << "work assignment: ";
    for(int i=0;i<work_assignment.size();i++)
    {
        cout << work_assignment[i] << " ";
    }
    cout << endl;
     */

    /*
    cout << "proposed schedule: ";
    for(int i=0;i<proposed_schedule.size();i++)
    {
        cout << proposed_schedule[i] << " ";
    }
    cout << endl;
     //*/

    cout << "Time Usage: " <<  ((float)(clock() - start))/CLOCKS_PER_SEC <<endl;
    // cout << "hungarian total distance: " << cost << endl; // 2087, 比默认方法确实缩小了
}

// 来不及完成的任务就不接了
void TaskScheduler::hungarian_sum_snatch_not_get(int time_limit, std::vector<int>& proposed_schedule)
{
    cout << "hungarian sum snatch not get" << endl;
    //use at most half of time_limit to compute schedule, -10 for timing error tolerance
    //so that the remainning time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;
    clock_t start = clock();

    // 没有新agent就不用抢单了
    if (env->new_freeagents.empty())
    {
        return;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    int counter = 0;
    for (const int& free_task_id : free_tasks)
    {
        if (counter % 10 == 0 && std::chrono::steady_clock::now() > endtime)
        {
            break;
        }

        // this task distance has been calculated
        if (task_distances.find(free_task_id) == task_distances.end())
        {
            int total_dist = 0;
            int curr_loc = env->task_pool[free_task_id].locations[0];

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[free_task_id].locations)
            {
                total_dist += DefaultPlanner::get_h(env, curr_loc, loc);
                curr_loc = loc;
            }

            task_distances[free_task_id] = total_dist;
            counter++;
            // cout << counter << endl;
        }
        else
        {
            // cout << "already in" << endl;
        }
    }

    // free agent and agent with task but before pickup
    std::vector<int> free_agents_and_before_pickup;
    free_agents_and_before_pickup.assign(free_agents.begin(), free_agents.end());

    // free tasks and tasks already assigned but before pickup
    std::vector<int> free_tasks_and_before_pickup;
    free_tasks_and_before_pickup.assign(free_tasks.begin(), free_tasks.end());

    for (const auto& element : env->task_pool)
    {
        if (element.second.agent_assigned != -1 && element.second.idx_next_loc == 0)
        {
            free_agents_and_before_pickup.emplace_back(element.second.agent_assigned);
            free_tasks_and_before_pickup.emplace_back(element.second.task_id);
        }
    }

    // 每个时间步，空闲agent数量等于新出现任务的数量。
    // cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    vector< vector<double> > cost_matrix;
    cost_matrix.resize(free_agents_and_before_pickup.size());
    for (int i = 0; i < cost_matrix.size(); i++)
    {
        auto agent_id = free_agents_and_before_pickup[i];

        cost_matrix[i].resize(free_tasks_and_before_pickup.size(), 0);
        for (int j = 0; j < free_tasks_and_before_pickup.size(); j++)
        {
            auto task_id = free_tasks_and_before_pickup[j];
            int curr_loc = env->curr_states.at(agent_id).location;

            // 计算agent id完成task id的成本
            cost_matrix[i][j] = DefaultPlanner::get_h(env, curr_loc,
                env->task_pool[task_id].locations[0]) + task_distances[task_id];
        }
    }

    vector<int> work_assignment; // "worker " << i << ", assignment " << work_assignment[i]
    Hungarian HungAlgo(cost_matrix);
    // HungAlgo.print_cost_matrix();
    // cout << "prev cost: " << prev_best_total_distance << endl;
    int cost = HungAlgo.Solve(work_assignment); // 如果后续算拥堵系数, cost和prev_best的类型改成double
    // cout << "new cost: " << cost << endl;

    if (cost != prev_best_total_distance)
    {
        prev_best_total_distance = cost;
        free_agents.clear();
        free_agents.insert(free_agents_and_before_pickup.begin(), free_agents_and_before_pickup.end());
        free_tasks.clear();
        free_tasks.insert(free_tasks_and_before_pickup.begin(), free_tasks_and_before_pickup.end());

        for (int i = 0; i < free_agents_and_before_pickup.size(); i++) // cost matrix i;
        {
            // cout << "cost matrix i cost: " << cost_matrix[i][work_assignment[i]] << endl;

            proposed_schedule[free_agents_and_before_pickup[i]] = free_tasks_and_before_pickup[work_assignment[i]];

            // 该工人被分配了任务
            if (work_assignment[i] != -1 && cost_matrix[i][work_assignment[i]] < 4995 - env->curr_timestep)
            {
                free_agents.erase(free_agents_and_before_pickup[i]);
                free_tasks.erase(free_tasks_and_before_pickup[work_assignment[i]]);
            }
        }
    }

    /*
    cout << "work assignment: ";
    for(int i=0;i<work_assignment.size();i++)
    {
        cout << work_assignment[i] << " ";
    }
    cout << endl;
     */

     /*
     cout << "proposed schedule: ";
     for(int i=0;i<proposed_schedule.size();i++)
     {
         cout << proposed_schedule[i] << " ";
     }
     cout << endl;
      //*/

    cout << "Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
    // cout << "hungarian total distance: " << cost << endl; // 2087, 比默认方法确实缩小了
}

// combine hungarian schedule sum at once and snatch order and pickup jam based current
void TaskScheduler::hungarian_sum_snatch_and_pickup_jam_based_current(int time_limit, std::vector<int>& proposed_schedule)
{
    cout << "hungarian sum snatch and pickup jam based current" << endl;
    //use at most half of time_limit to compute schedule, -10 for timing error tolerance
    //so that the remainning time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;
    clock_t start = clock();

    // 没有新agent就不用抢单了
    if (env->new_freeagents.empty())
    {
        return;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    int counter = 0;
    for (const int& free_task_id : free_tasks)
    {
        if (counter % 10 == 0 && std::chrono::steady_clock::now() > endtime)
        {
            break;
        }

        // this task distance has been calculated
        if (task_distances.find(free_task_id) == task_distances.end())
        {
            int total_dist = 0;
            int curr_loc = env->task_pool[free_task_id].locations[0];

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[free_task_id].locations)
            {
                total_dist += DefaultPlanner::get_h(env, curr_loc, loc);
                curr_loc = loc;
            }

            task_distances[free_task_id] = total_dist;
            counter++;
            // cout << counter << endl;
        }
        else
        {
            // cout << "already in" << endl;
        }
    }

    // free agent and agent with task but before pickup
    std::vector<int> free_agents_and_before_pickup;
    free_agents_and_before_pickup.assign(free_agents.begin(), free_agents.end());

    // free tasks and tasks already assigned but before pickup
    std::vector<int> free_tasks_and_before_pickup;
    free_tasks_and_before_pickup.assign(free_tasks.begin(), free_tasks.end());

    for (const auto& element : env->task_pool)
    {
        if (element.second.agent_assigned != -1 && element.second.idx_next_loc == 0)
        {
            free_agents_and_before_pickup.emplace_back(element.second.agent_assigned);
            free_tasks_and_before_pickup.emplace_back(element.second.task_id);
        }
    }

    // 每个时间步，空闲agent数量等于新出现任务的数量。
    // cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;
    cout << "free agents and before pickup num: " << free_agents_and_before_pickup.size() << endl;
    cout << "free tasks and before pickup num: " << free_tasks_and_before_pickup.size() << endl;

    if (free_agents_and_before_pickup.size() * free_tasks_and_before_pickup.size() > 400 * 400)
    // if (free_agents_and_before_pickup.size() * free_tasks_and_before_pickup.size() > 40 * 40)
    {
        pickup_jam_based_current_without_newtask(time_limit, proposed_schedule);
        return;
    }

    vector< vector<double> > cost_matrix;
    cost_matrix.resize(free_agents_and_before_pickup.size());
    for (int i = 0; i < cost_matrix.size(); i++)
    {
        auto agent_id = free_agents_and_before_pickup[i];

        cost_matrix[i].resize(free_tasks_and_before_pickup.size(), 0);
        for (int j = 0; j < free_tasks_and_before_pickup.size(); j++)
        {
            auto task_id = free_tasks_and_before_pickup[j];
            int curr_loc = env->curr_states.at(agent_id).location;

            // 计算agent id完成task id的成本
            cost_matrix[i][j] = DefaultPlanner::get_h(env, curr_loc,
                env->task_pool[task_id].locations[0]) + task_distances[task_id];
        }
    }

    vector<int> work_assignment; // "worker " << i << ", assignment " << work_assignment[i]
    Hungarian HungAlgo(cost_matrix);
    // HungAlgo.print_cost_matrix();
    // cout << "prev cost: " << prev_best_total_distance << endl;
    int cost = HungAlgo.Solve(work_assignment); // 如果后续算拥堵系数, cost和prev_best的类型改成double
    // cout << "new cost: " << cost << endl;

    if (cost != prev_best_total_distance)
    {
        prev_best_total_distance = cost;
        free_agents.clear();
        free_agents.insert(free_agents_and_before_pickup.begin(), free_agents_and_before_pickup.end());
        free_tasks.clear();
        free_tasks.insert(free_tasks_and_before_pickup.begin(), free_tasks_and_before_pickup.end());

        for (int i = 0; i < free_agents_and_before_pickup.size(); i++)
        {
            proposed_schedule[free_agents_and_before_pickup[i]] = free_tasks_and_before_pickup[work_assignment[i]];

            // 该工人被分配了任务
            if (work_assignment[i] != -1)
            {
                free_agents.erase(free_agents_and_before_pickup[i]);
                free_tasks.erase(free_tasks_and_before_pickup[work_assignment[i]]);
            }
        }
    }

    /*
    cout << "work assignment: ";
    for(int i=0;i<work_assignment.size();i++)
    {
        cout << work_assignment[i] << " ";
    }
    cout << endl;
     */

     /*
     cout << "proposed schedule: ";
     for(int i=0;i<proposed_schedule.size();i++)
     {
         cout << proposed_schedule[i] << " ";
     }
     cout << endl;
      //*/

    cout << "Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
    // cout << "hungarian total distance: " << cost << endl; // 2087, 比默认方法确实缩小了
}

// 在hungarian_sum_snatch的基础上，考虑了单据不够、单据超出等多种情况。尚且不稳定，official platform测试会失败。
void TaskScheduler::hungarian_sum_snatch_complex(int time_limit, std::vector<int> & proposed_schedule)
{
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    TimePoint task_distance_end_moment = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit / 3);
    // cout<<"schedule plan limit" << time_limit <<endl;
    clock_t start = clock();

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    int num_free_agents_before_allocated = free_agents.size();
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    int counter = 0; // 每处理10个任务, 计算一次时间
    for (const int& free_task_id : free_tasks)
    {
        if (counter % 10 == 0 && std::chrono::steady_clock::now() > task_distance_end_moment)
        {
            // cout << "task distance compute timeout " << task_distances.size() << " been computed" << endl;
            break;
        }

        // this task distance has not been calculated
        if (task_distances.find(free_task_id) == task_distances.end())
        {
            int total_dist = 0;
            int curr_loc = env->task_pool[free_task_id].locations[0];

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[free_task_id].locations)
            {
                total_dist += DefaultPlanner::get_h(env, curr_loc, loc);
                curr_loc = loc;
            }

            task_distances[free_task_id] = total_dist;
            counter++;
            // cout << counter << endl;
        }
        else
        {
            // cout << "already in" << endl;
        }
    }

    // free agents and agents with task but before pickup (only when free agents not enough)
    std::vector<int> free_agents_and_before_pickup;
    if(free_agents.size() <= max_agent_allowed)
    {
        free_agents_and_before_pickup.assign(free_agents.begin(), free_agents.end());
    }
    else
    {
        int count = 0;
        for (auto it = free_agents.begin(); it != free_agents.end() && count < max_agent_allowed; )
        {
            free_agents_and_before_pickup.emplace_back(*it); // 添加到 vector
            it++;
            count++;
        }
    }

    // free tasks and tasks already assigned but before pickup (only when free tasks not enough)
    std::vector<int> free_tasks_and_before_pickup;
    if(free_tasks.size() <= max_task_allowed)
    {
        free_tasks_and_before_pickup.assign(free_tasks.begin(), free_tasks.end());
    }
    else
    {
        int count = 0;
        for (auto it = free_tasks.begin(); it != free_tasks.end()
        && count < max_task_allowed
        && task_distances.find(*it) != task_distances.end();) // 已经计算过任务长度的
        {
            free_tasks_and_before_pickup.emplace_back(*it); // 添加到 vector
            it++;
            count++;
        }
    }

    // 不够才需要补充, 够了就不需要了
    if(free_agents_and_before_pickup.size() < max_agent_allowed
    || free_tasks_and_before_pickup.size() < max_task_allowed)
    {
        for(const auto& element : env->task_pool)
        {
            if(element.second.agent_assigned != -1 && element.second.idx_next_loc == 0)
            {
                if(free_agents_and_before_pickup.size() < max_agent_allowed)
                {
                    free_agents_and_before_pickup.emplace_back(element.second.agent_assigned);
                }

                if(free_tasks_and_before_pickup.size() < max_task_allowed)
                {
                    free_tasks_and_before_pickup.emplace_back(element.second.task_id);
                }
            }
        }
    }

    // 每个时间步，空闲agent数量等于新出现任务的数量。
    //*
    cout << "free agent num: " << free_agents.size() << endl;
    cout << "free task num: " << free_tasks.size() << endl;

    cout << "free and before pickup agent num: " << free_agents_and_before_pickup.size() << endl;
    cout << "free and before pickup task num: " << free_tasks_and_before_pickup.size() << endl;
    //*/

    vector< vector<double> > cost_matrix;
    cost_matrix.resize(free_agents_and_before_pickup.size());
    for(int i=0;i<cost_matrix.size();i++)
    {
        auto agent_id = free_agents_and_before_pickup[i];

        cost_matrix[i].resize(free_tasks_and_before_pickup.size(), 0);
        for(int j=0;j<free_tasks_and_before_pickup.size();j++)
        {
            auto task_id = free_tasks_and_before_pickup[j];

            int curr_loc = env->curr_states.at(agent_id).location;

            if(task_distances.find(task_id) == task_distances.end())
            {
                cerr << "ERROR! use distance not computed" << endl;
                return;
            }

            int dist = DefaultPlanner::get_h(env, curr_loc, env->task_pool[task_id].locations[0])
                    + task_distances[task_id];

            // 计算agent id完成task id的成本
            cost_matrix[i][j] = dist;
        }
    }

    vector<int> work_assignment; // "worker " << i << ", assignment " << work_assignment[i]
    Hungarian HungAlgo(cost_matrix);
    // HungAlgo.print_cost_matrix();
    // cout << "prev cost: " << prev_best_total_distance << endl;
    int cost = HungAlgo.Solve(work_assignment); // 如果后续算拥堵系数, cost和prev_best的类型改成double
    // cout << "new cost: " << cost << endl;

    int num_free_agents_after_allocated = 0;
    if(free_agents.size() < max_agent_allowed)
    {
        for(auto const& element : work_assignment)
        {
            if(element == -1)
            {
                num_free_agents_after_allocated++;
            }
        }
    }
    else
    {
        num_free_agents_after_allocated = free_agents.size() - max_agent_allowed;
    }

    if (num_free_agents_after_allocated < num_free_agents_before_allocated || cost < prev_best_total_distance)
    {
        prev_best_total_distance = cost;
        if(free_agents.size() < max_agent_allowed)
        {
            free_agents.clear();
            free_agents.insert(free_agents_and_before_pickup.begin(), free_agents_and_before_pickup.end());
        }

        if(free_tasks.size() < max_task_allowed)
        {
            free_tasks.clear();
            free_tasks.insert(free_tasks_and_before_pickup.begin(), free_tasks_and_before_pickup.end());
        }

        for(int i=0; i < free_agents_and_before_pickup.size(); i++)
        {
            proposed_schedule[free_agents_and_before_pickup[i]] = free_tasks_and_before_pickup[work_assignment[i]];

            // 该工人被分配了任务
            if(work_assignment[i] != -1)
            {
                free_agents.erase(free_agents_and_before_pickup[i]);
                free_tasks.erase(free_tasks_and_before_pickup[work_assignment[i]]);
            }
        }
    }

    /*
    cout << "work assignment: ";
    for(int i=0;i<work_assignment.size();i++)
    {
        cout << work_assignment[i] << " ";
    }
    cout << endl;
     */

    /*
    cout << "proposed schedule: ";
    for(int i=0;i<proposed_schedule.size();i++)
    {
        cout << proposed_schedule[i] << " ";
    }
    cout << endl;
     //*/

    cout << "Time Usage: " <<  ((float)(clock() - start))/CLOCKS_PER_SEC <<endl;
    // cout << "hungarian total distance: " << cost << endl; // 2087, 比默认方法确实缩小了
}

// 每个任务的拥堵系数在一个时间步对所有agent都是相同的。由所有agent距离该任务的倒数之和决定。
void TaskScheduler::pickup_jam_based_current(int time_limit, std::vector<int> & proposed_schedule)
{
    //use at most half of time_limit to compute schedule, -10 for timing error tolerance
    //so that the remainning time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    TimePoint jam_end_moment = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit / 2);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    // cout << "agent num:" << env->curr_states.size() << endl;
    // cout << "curr time:" << env->curr_timestep << endl;

    clock_t start = clock();

    // compute pickup jam for each free task every timestep
    for (int t_id : free_tasks)
    {
        double pickup_jam = 0;
        int pickup_loc = env->task_pool[t_id].locations[0];
        for(int i=0;i<env->curr_states.size();i++)
        {
            // 上下左右四个格子内的障碍物越多, 对拥堵的影响就越大
            pickup_jam += double(4 - DefaultPlanner::global_neighbors[pickup_loc].size())
                    / DefaultPlanner::get_h(env, pickup_loc, env->curr_states[i].location);
        }

        task_pickup_jams[t_id] = pickup_jam;

        if (std::chrono::steady_clock::now() > jam_end_moment)
        {
            // cout << "jam time not enough" << endl;
            break;
        }
    }

    /*
    for (auto it = task_pickup_jams.begin(); it != task_pickup_jams.end(); ++it) {
        std::cout << "task: " << it->first << ", jam: " << it->second << std::endl;
    }
     */

    // cout << "jam compute duration: " <<  ((float)(clock() - start))/CLOCKS_PER_SEC <<endl;

    int min_task_i, min_task_makespan, c_loc, count;


    // iterate over the free agents to decide which task to assign to each of them
    int best_total_distance = 0;
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        //keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        min_task_makespan = INT_MAX;
        count = 0;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            //check for timeout every 10 task evaluations
            if (count % 10 == 0 && std::chrono::steady_clock::now() > endtime)
            {
                break;
            }

            // distance between current location and task pick up location
            int dist = DefaultPlanner::get_h(env, env->curr_states.at(i).location,
                                          env->task_pool[t_id].locations[0]);
            int temp_dist = dist;

            // TODO: 如果task pickup jams没有来得及算, 这里不要加上去
            dist += int ((task_pickup_jams[t_id] - 1.0 / temp_dist) * jam_coefficient);

            // update the new minimum makespan
            if (dist < min_task_makespan){
                min_task_i = t_id;
                min_task_makespan = dist;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1){
            proposed_schedule[i] = min_task_i;
            best_total_distance += min_task_makespan;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
        }
            // nothing to assign
        else{
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Task assignment duration: " <<  ((float)(clock() - start))/CLOCKS_PER_SEC <<endl;
#ifndef NDEBUG
    cout << "best total distance: " << best_total_distance << endl;
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: "<< env->new_tasks.size() <<  endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 每个任务的拥堵系数在一个时间步对所有agent都是相同的。由所有agent距离该任务的倒数之和决定。
void TaskScheduler::pickup_jam_based_current_without_newtask(int time_limit, std::vector<int>& proposed_schedule)
{
    //use at most half of time_limit to compute schedule, -10 for timing error tolerance
    //so that the remainning time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    TimePoint jam_end_moment = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit / 2);
    // cout<<"schedule plan limit" << time_limit <<endl;

    cout << "free agent num: " << free_agents.size() << endl;
    cout << "free task num: " << free_tasks.size() << endl;

    clock_t start = clock();

    // compute pickup jam for each free task every timestep
    for (int t_id : free_tasks)
    {
        double pickup_jam = 0;
        int pickup_loc = env->task_pool[t_id].locations[0];
        for (int i = 0; i < env->curr_states.size(); i++)
        {
            // 上下左右四个格子内的障碍物越多, 对拥堵的影响就越大
            pickup_jam += double(4 - DefaultPlanner::global_neighbors[pickup_loc].size())
                / DefaultPlanner::get_h(env, pickup_loc, env->curr_states[i].location);
        }

        task_pickup_jams[t_id] = pickup_jam;

        if (std::chrono::steady_clock::now() > jam_end_moment)
        {
            // cout << "jam time not enough" << endl;
            break;
        }
    }

    /*
    for (auto it = task_pickup_jams.begin(); it != task_pickup_jams.end(); ++it) {
        std::cout << "task: " << it->first << ", jam: " << it->second << std::endl;
    }
     */

     // cout << "jam compute duration: " <<  ((float)(clock() - start))/CLOCKS_PER_SEC <<endl;

    int min_task_i, min_task_makespan, c_loc, count;


    // iterate over the free agents to decide which task to assign to each of them
    int best_total_distance = 0;
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        //keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        min_task_makespan = INT_MAX;
        count = 0;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            //check for timeout every 10 task evaluations
            if (count % 10 == 0 && std::chrono::steady_clock::now() > endtime)
            {
                break;
            }

            // distance between current location and task pick up location
            int dist = DefaultPlanner::get_h(env, env->curr_states.at(i).location,
                env->task_pool[t_id].locations[0]);
            int temp_dist = dist;

            // TODO: 如果task pickup jams没有来得及算, 这里不要加上去
            jam_coefficient = 4;
            dist += int((task_pickup_jams[t_id] - 1.0 / temp_dist) * jam_coefficient);

            // update the new minimum makespan
            if (dist < min_task_makespan) {
                min_task_i = t_id;
                min_task_makespan = dist;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1) {
            proposed_schedule[i] = min_task_i;
            best_total_distance += min_task_makespan;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
        }
        // nothing to assign
        else {
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Task assignment duration: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "best total distance: " << best_total_distance << endl;
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 计算adaptive_jam_pickup_current_circle的估计延迟时间
double TaskScheduler::compute_adaptive_jam_pickup_current_circle(int _agent_id, int _agent_loc, int _pickup_loc) const
{
    double sum_jam_weight = 0;

    int agent_loc_x = _agent_loc % env->cols;
    int agent_loc_y = _agent_loc / env->cols;

    int pickup_loc_x = _pickup_loc % env->cols;
    int pickup_loc_y = _pickup_loc / env->cols;
    // cout << "pickup loc " << pickup_loc_x << " " << pickup_loc_y << endl;

    // 当前agent指向某个任务的向量
    int agent_task_direction_x = pickup_loc_x - agent_loc_x;
    int agent_task_direction_y = pickup_loc_y - agent_loc_y;
    int agent_task_direction_square = agent_task_direction_x * agent_task_direction_x +
                                      agent_task_direction_y * agent_task_direction_y;

    for(int j=0;j<env->curr_states.size();j++)
    {
        if (j != _agent_id) // 所有agent都会有任务, 所以都要计入
        {
            int other_agent_loc = env->curr_states.at(j).location;
            int other_agent_loc_x = other_agent_loc % env->cols;
            int other_agent_loc_y = other_agent_loc / env->cols;
            // cout << "other agent loc " << other_agent_loc << " " << other_agent_loc_x << " "
            // << other_agent_loc_y << endl;

            // vector from current agent location to other agent location
            int agent_other_direction_x = other_agent_loc_x - agent_loc_x;
            int agent_other_direction_y = other_agent_loc_y - agent_loc_y;
            // cout << "other agent direction " << agent_other_direction_x << " " << other_agent_loc_y << endl;
            int agent_other_distance_square = agent_other_direction_x * agent_other_direction_x
                                              + agent_other_direction_y * agent_other_direction_y;

            // 只统计agent-task半圆范围内的agent
            if(agent_other_distance_square < agent_task_direction_square)
            {
                // 其他agent方向与task方向的夹角 < 90°才算入拥堵系数
                int inner_product = agent_other_direction_x * agent_task_direction_x
                                    + agent_other_direction_y * agent_task_direction_y;
                if (inner_product > 0)
                {
                    // double task_direction_length = sqrt(agent_task_direction_square);
                    // cout << "task direction: " << agent_task_direction_x << " " << agent_task_direction_y << " "
                    // << task_direction_length << endl;

                    sum_jam_weight += inner_product / (agent_other_distance_square
                                                       * sqrt(agent_task_direction_square));
                }
            }
        }
    }

    return sum_jam_weight;
}

// 以agent为圆心，agent-task为半径朝向task画出一个半圆，位于这个半圆内的other agent计入拥堵系数。jam = cos<ao, at> / |ao| = inner(ao, at) / (|ao||ao||at|) if inner(ao, at) > 0 and |ao| < |at|; =0, otherwise
void TaskScheduler::adaptive_jam_pickup_current_circle(int time_limit, std::vector<int> & proposed_schedule)
{
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for(auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
            << " minDist " << agent_task[element].min_task_dist
            << " heuristic " << agent_task[element].task_heuristic
                 << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                 << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if(numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;
        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            // check for timeout every 10 task evaluations
            if (std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            double sum_jam_weight = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations){
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            int pickup_loc = env->task_pool[t_id].locations.front();

            sum_jam_weight = compute_adaptive_jam_pickup_current_circle(i, agent_loc, pickup_loc);

            // update the new minimum makespan
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic){
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1){
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist  = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
            // nothing to assign
        else{
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Time Usage: " <<  ((float)(clock() - start))/CLOCKS_PER_SEC <<endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: "<< env->new_tasks.size() <<  endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 检索以task为圆心，所有agent距离它的倒数之和
void TaskScheduler::adaptive_jam_task_circle_current(int time_limit, std::vector<int> & proposed_schedule)
{
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for(auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                 << " minDist " << agent_task[element].min_task_dist
                 << " heuristic " << agent_task[element].task_heuristic
                 << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                 << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if(numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;
        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            //check for timeout every 10 task evaluations
            if (std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            double sum_jam_weight = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations){
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            /*
            if(OneDim2TwoDim.find(env->task_pool[t_id].locations[0]) == OneDim2TwoDim.end())
            {
                cerr << "map error!" << endl;
            }
            */

            int pickup_loc = env->task_pool[t_id].locations[0];
            int pickup_loc_x = env->task_pool[t_id].locations[0] % env->cols;
            int pickup_loc_y = env->task_pool[t_id].locations[0] / env->cols;
            // cout << "pickup loc " << pickup_twodim.x << " " << pickup_twodim.y << endl;

            for(int j=0;j<env->curr_states.size();j++)
            {
                if (j != i) // 所有agent都会有任务, 所以都要计入
                {
                    int other_agent_loc = env->curr_states.at(j).location;
                    int other_agent_loc_x = other_agent_loc % env->cols;
                    int other_agent_loc_y = other_agent_loc / env->cols;
                    // cout << "other agent loc " << other_agent_loc << " " << other_agent_loc_x << " "
                    // << other_agent_loc_y << endl;

                    int other_task_direction_x = pickup_loc_x - other_agent_loc_x;
                    int other_task_direction_y = pickup_loc_y - other_agent_loc_y;
                    // cout << "other agent direction " << agent_other_direction_x << " " << other_agent_loc_y << endl;
                    int other_task_distance_square = other_task_direction_x * other_task_direction_x
                                                     + other_task_direction_y * other_task_direction_y;

                    // cout << "task direction: " << agent_task_direction_x << " " << agent_task_direction_y << " "
                    // << task_direction_length << endl;

                    sum_jam_weight += 1 / sqrt(other_task_distance_square);
                }
            }

            // sum_jam_weight * jam_coefficient = guess delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic){
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1){
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist  = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
            // nothing to assign
        else{
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Time Usage: " <<  ((float)(clock() - start))/CLOCKS_PER_SEC <<endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: "<< env->new_tasks.size() <<  endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}


// 检索以task为圆心，所有agent距离它的倒数平方之和
void TaskScheduler::adaptive_jam_task_circle_current_square(int time_limit,
                                                            std::vector<int> & proposed_schedule)
{
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for(auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                 << " minDist " << agent_task[element].min_task_dist
                 << " heuristic " << agent_task[element].task_heuristic
                 << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                 << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if(numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;
        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            //check for timeout every 10 task evaluations
            if (count % 10 == 0 && std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            double sum_jam_weight = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations){
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            /*
            if(OneDim2TwoDim.find(env->task_pool[t_id].locations[0]) == OneDim2TwoDim.end())
            {
                cerr << "map error!" << endl;
            }
            */

            int pickup_loc = env->task_pool[t_id].locations[0];
            int pickup_loc_x = env->task_pool[t_id].locations[0] % env->cols;
            int pickup_loc_y = env->task_pool[t_id].locations[0] / env->cols;
            // cout << "pickup loc " << pickup_twodim.x << " " << pickup_twodim.y << endl;

            for(int j=0;j<env->curr_states.size();j++)
            {
                if (j != i) // 所有agent都会有任务, 所以都要计入
                {
                    int other_agent_loc = env->curr_states.at(j).location;
                    int other_agent_loc_x = other_agent_loc % env->cols;
                    int other_agent_loc_y = other_agent_loc / env->cols;
                    // cout << "other agent loc " << other_agent_loc << " " << other_agent_loc_x << " "
                    // << other_agent_loc_y << endl;

                    int other_task_direction_x = pickup_loc_x - other_agent_loc_x;
                    int other_task_direction_y = pickup_loc_y - other_agent_loc_y;
                    // cout << "other agent direction " << agent_other_direction_x << " " << other_agent_loc_y << endl;
                    int other_task_distance_square = other_task_direction_x * other_task_direction_x
                                                     + other_task_direction_y * other_task_direction_y;

                    // cout << "task direction: " << agent_task_direction_x << " " << agent_task_direction_y << " "
                    // << task_direction_length << endl;

                    // 检索以task为圆心，所有agent距离它的倒数平方之和
                    sum_jam_weight += 1 / double (other_task_distance_square);
                }
            }

            // sum_jam_weight * jam_coefficient = guess delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic){
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1){
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist  = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
            // nothing to assign
        else{
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Time Usage: " <<  ((float)(clock() - start))/CLOCKS_PER_SEC <<endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: "<< env->new_tasks.size() <<  endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

int TaskScheduler::compute_jam_task_circle_count_current(int _agent_id, int _agent_loc_x,
                                                         int _agent_loc_y, int _pickup_loc) const
{
    int sum_jam_weight = 0;

    int pickup_loc_x = _pickup_loc % env->cols;
    int pickup_loc_y = _pickup_loc / env->cols;
    // cout << "pickup loc " << pickup_twodim.x << " " << pickup_twodim.y << endl;

    // 当前agent指向某个任务的向量
    int agent_task_direction_x = pickup_loc_x - _agent_loc_x;
    int agent_task_direction_y = pickup_loc_y - _agent_loc_y;
    int agent_task_direction_square = agent_task_direction_x * agent_task_direction_x +
                                      agent_task_direction_y * agent_task_direction_y;

    for(int j=0;j<env->curr_states.size();j++)
    {
        if (j != _agent_id) // 所有agent都会有任务, 所以都要计入
        {
            int other_agent_loc = env->curr_states.at(j).location;
            int other_agent_loc_x = other_agent_loc % env->cols;
            int other_agent_loc_y = other_agent_loc / env->cols;
            // cout << "other agent loc " << other_agent_loc << " " << other_agent_loc_x << " "
            // << other_agent_loc_y << endl;

            int other_task_direction_x = pickup_loc_x - other_agent_loc_x;
            int other_task_direction_y = pickup_loc_y - other_agent_loc_y;
            // cout << "other agent direction " << agent_other_direction_x << " " << other_agent_loc_y << endl;
            int other_task_distance_square = other_task_direction_x * other_task_direction_x
                                             + other_task_direction_y * other_task_direction_y;

            // 只统计以task为圆心, agent-task范围内的other agent
            if(other_task_distance_square < agent_task_direction_square)
            {
                sum_jam_weight++;
            }
        }
    }

    return sum_jam_weight;
}

// 1: 以task pickup为圆心，agent-task为半径朝向task画出一个圆，位于这个圆内的other agent的数量为拥堵系数。
void TaskScheduler::adaptive_jam_task_circle_count_current(int time_limit, std::vector<int> & proposed_schedule)
{
    cout << "adaptive jam task circle count current with dist agent pickup delivery" << endl;
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for(auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            total_dist_agent_pickup += agent_task[element].dist_agent_pickup;
            total_dist_pickup_delivery += agent_task[element].dist_pickup_delivery;

            average_dist_agent_pickup = static_cast<double>(total_dist_agent_pickup) / numTaskFinished;
            average_dist_pickup_delivery = static_cast<double>(total_dist_pickup_delivery) / numTaskFinished;

            cout << "complete task " << agent_task[element].task_id
                 << " minDist " << agent_task[element].min_task_dist
                 << " heuristic " << agent_task[element].task_heuristic
                 << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                 << " jam " << agent_task[element].jam_when_assign << endl;

            // cout << "total dist agent pickup: " << total_dist_agent_pickup << " "
            //    << "total dist pickup delivery: " << total_dist_pickup_delivery << endl;

            cout << "average dist agent pickup: " << average_dist_agent_pickup << " "
                << "average dist pickup delivery: " << average_dist_pickup_delivery << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if(numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;
        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            //check for timeout every 10 task evaluations
            if (std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations){
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            int pickup_loc = env->task_pool[t_id].locations[0];
            int sum_jam_weight = compute_jam_task_circle_count_current(i, agent_loc_x,
                                                                       agent_loc_y, pickup_loc);

            // sum_jam_weight * jam_coefficient = guess delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic){
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1){
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist  = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].dist_agent_pickup = DefaultPlanner::get_h(env, env->curr_states.at(i).location, env->task_pool[min_task_i].locations[0]);
            agent_task[i].dist_pickup_delivery = DefaultPlanner::get_h(env, env->task_pool[min_task_i].locations[0], env->task_pool[min_task_i].locations[1]);
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
            // nothing to assign
        else{
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Time Usage: " <<  ((float)(clock() - start))/CLOCKS_PER_SEC <<endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: "<< env->new_tasks.size() <<  endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 1: 以task pickup为圆心，agent-task为半径朝向task画出一个圆，位于这个圆内的other agent的数量为拥堵系数。
void TaskScheduler::adaptive_jam_task_circle_count_current_without_newtask(int time_limit, std::vector<int>& proposed_schedule)
{
    cout << "adaptive jam task circle count current without newtask" << endl;
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            // total_dist_agent_pickup += agent_task[element].dist_agent_pickup;
            // total_dist_pickup_delivery += agent_task[element].dist_pickup_delivery;

            // average_dist_agent_pickup = static_cast<double>(total_dist_agent_pickup) / numTaskFinished;
            // average_dist_pickup_delivery = static_cast<double>(total_dist_pickup_delivery) / numTaskFinished;

            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;

            // cout << "total dist agent pickup: " << total_dist_agent_pickup << " "
            //    << "total dist pickup delivery: " << total_dist_pickup_delivery << endl;

            // cout << "average dist agent pickup: " << average_dist_agent_pickup << " "
            //    << "average dist pickup delivery: " << average_dist_pickup_delivery << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;
        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            //check for timeout every 10 task evaluations
            if (std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations) {
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            int pickup_loc = env->task_pool[t_id].locations[0];
            int sum_jam_weight = compute_jam_task_circle_count_current(i, agent_loc_x,
                agent_loc_y, pickup_loc);

            // sum_jam_weight * jam_coefficient = guess delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic) {
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1) {
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            // agent_task[i].dist_agent_pickup = DefaultPlanner::get_h(env, env->curr_states.at(i).location, env->task_pool[min_task_i].locations[0]);
            // agent_task[i].dist_pickup_delivery = DefaultPlanner::get_h(env, env->task_pool[min_task_i].locations[0], env->task_pool[min_task_i].locations[1]);
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
        // nothing to assign
        else {
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 1.1: 预分配初始任务。
void TaskScheduler::adaptive_jam_task_circle_count_current_preassign(int time_limit, std::vector<int> & proposed_schedule)
{
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for(auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                 << " minDist " << agent_task[element].min_task_dist
                 << " heuristic " << agent_task[element].task_heuristic
                 << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                 << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if(numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    if(free_agents.size() > 50)
    {
        if(first_epoch_done_time == -1)
        {
            // 由于大算例初始任务过多, 在初始任务分配完成前采用默认算法
            greedy_sum_without_newtask(time_limit, proposed_schedule);
            return;
        }
    }
    else
    {
        if(first_epoch_done_time == -1)
        {
            first_epoch_done_time = env->curr_timestep; // 初始阶段的任务分配完毕的时间
        }
    }

    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;
        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            //check for timeout every 10 task evaluations
            if (std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations){
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            int pickup_loc = env->task_pool[t_id].locations[0];
            int sum_jam_weight = compute_jam_task_circle_count_current(i, agent_loc_x,
                                                                       agent_loc_y, pickup_loc);

            // sum_jam_weight * jam_coefficient = guess delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic){
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1){
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist  = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
            // nothing to assign
        else{
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Time Usage: " <<  ((float)(clock() - start))/CLOCKS_PER_SEC <<endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: "<< env->new_tasks.size() <<  endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 以task pickup为圆心，agent-task为半径朝向task画出一个圆，位于这个圆内的other agent的数量为拥堵系数。
void TaskScheduler::adaptive_jam_task_circle_count_current_compare_dist(int time_limit,
                                                            std::vector<int> & proposed_schedule)
{
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for(auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                 << " minDist " << agent_task[element].min_task_dist
                 << " heuristic " << agent_task[element].task_heuristic
                 << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                 << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if(numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;
        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            // check for timeout every 10 task evaluations
            if (count % 10 == 0 && std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations){
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            if (dist < min_task_heuristic)
            {
                int pickup_loc = env->task_pool[t_id].locations[0];
                int sum_jam_weight = compute_jam_task_circle_count_current(i, agent_loc_x,
                                                                           agent_loc_y, pickup_loc);

                // sum_jam_weight * jam_coefficient = guess delay time
                if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic){
                    min_task_i = t_id;
                    min_task_dist = dist;
                    min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                    corresponding_traffic_jam = sum_jam_weight;
                }
            }

            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1){
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist  = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
            // nothing to assign
        else{
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Time Usage: " <<  ((float)(clock() - start))/CLOCKS_PER_SEC <<endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: "<< env->new_tasks.size() <<  endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

int TaskScheduler::compute_jam_task_half_circle_count_current(int _agent_id, int _agent_loc_x,
    int _agent_loc_y, int _pickup_loc) const
{
    int sum_jam_weight = 0;

    int pickup_loc_x = _pickup_loc % env->cols;
    int pickup_loc_y = _pickup_loc / env->cols;
    // cout << "pickup loc " << pickup_twodim.x << " " << pickup_twodim.y << endl;

    // 当前agent指向某个任务的向量
    int agent_task_direction_x = pickup_loc_x - _agent_loc_x;
    int agent_task_direction_y = pickup_loc_y - _agent_loc_y;
    int agent_task_direction_square = agent_task_direction_x * agent_task_direction_x +
        agent_task_direction_y * agent_task_direction_y;

    for (int j = 0; j < env->curr_states.size(); j++)
    {
        if (j != _agent_id) // 所有agent都会有任务, 所以都要计入
        {
            int other_agent_loc = env->curr_states.at(j).location;
            int other_agent_loc_x = other_agent_loc % env->cols;
            int other_agent_loc_y = other_agent_loc / env->cols;
            // cout << "other agent loc " << other_agent_loc << " " << other_agent_loc_x << " "
            // << other_agent_loc_y << endl;

            int other_task_direction_x = pickup_loc_x - other_agent_loc_x;
            int other_task_direction_y = pickup_loc_y - other_agent_loc_y;
            // cout << "other agent direction " << agent_other_direction_x << " " << other_agent_loc_y << endl;
            int other_task_distance_square = other_task_direction_x * other_task_direction_x
                + other_task_direction_y * other_task_direction_y;

            // 只统计以task为圆心, |agent-task|/2范围内的other agent
            if (other_task_distance_square < agent_task_direction_square / 4)
            {
                sum_jam_weight++;
            }
        }
    }

    return sum_jam_weight;
}

// 1.1.0: 以task pickup为圆心，|agent-task|/2为半径朝向task画出一个圆，位于这个圆内的other agent的数量为拥堵系数。
void TaskScheduler::adaptive_jam_task_half_circle_count_current(int time_limit, std::vector<int>& proposed_schedule)
{
    cout << "adaptive jam task half circle count current" << endl;
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;
        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            //check for timeout every 10 task evaluations
            if (std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations) {
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            int pickup_loc = env->task_pool[t_id].locations[0];
            int sum_jam_weight = compute_jam_task_half_circle_count_current(i, agent_loc_x,
                agent_loc_y, pickup_loc);

            // sum_jam_weight * jam_coefficient = guess delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic) {
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1) {
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
        // nothing to assign
        else {
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

int TaskScheduler::compute_jam_task_double_circle_count_current(int _agent_id, int _agent_loc_x,
    int _agent_loc_y, int _pickup_loc) const
{
    int sum_jam_weight = 0;

    int pickup_loc_x = _pickup_loc % env->cols;
    int pickup_loc_y = _pickup_loc / env->cols;
    // cout << "pickup loc " << pickup_twodim.x << " " << pickup_twodim.y << endl;

    // 当前agent指向某个任务的向量
    int agent_task_direction_x = pickup_loc_x - _agent_loc_x;
    int agent_task_direction_y = pickup_loc_y - _agent_loc_y;
    int agent_task_direction_square = agent_task_direction_x * agent_task_direction_x +
        agent_task_direction_y * agent_task_direction_y;

    for (int j = 0; j < env->curr_states.size(); j++)
    {
        if (j != _agent_id) // 所有agent都会有任务, 所以都要计入
        {
            int other_agent_loc = env->curr_states.at(j).location;
            int other_agent_loc_x = other_agent_loc % env->cols;
            int other_agent_loc_y = other_agent_loc / env->cols;
            // cout << "other agent loc " << other_agent_loc << " " << other_agent_loc_x << " "
            // << other_agent_loc_y << endl;

            int other_task_direction_x = pickup_loc_x - other_agent_loc_x;
            int other_task_direction_y = pickup_loc_y - other_agent_loc_y;
            // cout << "other agent direction " << agent_other_direction_x << " " << other_agent_loc_y << endl;
            int other_task_distance_square = other_task_direction_x * other_task_direction_x
                + other_task_direction_y * other_task_direction_y;

            // 只统计以task为圆心, |agent-task|*2范围内的other agent
            if (other_task_distance_square < agent_task_direction_square * 4)
            {
                sum_jam_weight++;
            }
        }
    }

    return sum_jam_weight;
}

// 1.1.1: 以task pickup为圆心，|agent-task|*2为半径朝向task画出一个圆，位于这个圆内的other agent的数量为拥堵系数。
void TaskScheduler::adaptive_jam_task_double_circle_count_current(int time_limit, std::vector<int>& proposed_schedule)
{
    cout << "adaptive jam task double circle count current" << endl;
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;
        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            //check for timeout every 10 task evaluations
            if (std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations) {
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            int pickup_loc = env->task_pool[t_id].locations[0];
            int sum_jam_weight = compute_jam_task_double_circle_count_current(i, agent_loc_x,
                agent_loc_y, pickup_loc);

            // sum_jam_weight * jam_coefficient = guess delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic) {
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1) {
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
        // nothing to assign
        else {
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 1.1.1.1
void TaskScheduler::hungarian_sum_snatch_adaptive_jam_task_double_circle_count_current(int time_limit,
    std::vector<int>& proposed_schedule)
{
    //use at most half of time_limit to compute schedule, -10 for timing error tolerance
    //so that the remainning time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;
    clock_t start = clock();

    // 没有新agent就不用抢单了
    if (env->new_freeagents.empty())
    {
        return;
    }

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    int counter = 0;
    for (const int& free_task_id : free_tasks)
    {
        if (counter % 10 == 0 && std::chrono::steady_clock::now() > endtime)
        {
            break;
        }

        // this task distance has been calculated
        if (task_distances.find(free_task_id) == task_distances.end())
        {
            int total_dist = 0;
            int curr_loc = env->task_pool[free_task_id].locations[0];

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[free_task_id].locations)
            {
                total_dist += DefaultPlanner::get_h(env, curr_loc, loc);
                curr_loc = loc;
            }

            task_distances[free_task_id] = total_dist;
            counter++;
            // cout << counter << endl;
        }
        else
        {
            // cout << "already in" << endl;
        }
    }

    // free agent and agent with task but before pickup
    std::vector<int> free_agents_and_before_pickup;
    free_agents_and_before_pickup.assign(free_agents.begin(), free_agents.end());

    // free tasks and tasks already assigned but before pickup
    std::vector<int> free_tasks_and_before_pickup;
    free_tasks_and_before_pickup.assign(free_tasks.begin(), free_tasks.end());

    for (const auto& element : env->task_pool)
    {
        if (element.second.agent_assigned != -1 && element.second.idx_next_loc == 0)
        {
            free_agents_and_before_pickup.emplace_back(element.second.agent_assigned);
            free_tasks_and_before_pickup.emplace_back(element.second.task_id);
        }
    }

    // 每个时间步，空闲agent数量等于新出现任务的数量。
    // cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    vector< vector<int> > dist_matrix;
    dist_matrix.resize(free_agents_and_before_pickup.size());
    vector< vector<double> > jam_matrix;
    jam_matrix.resize(free_agents_and_before_pickup.size());
    vector< vector<double> > cost_matrix;
    cost_matrix.resize(free_agents_and_before_pickup.size());
    for (int i = 0; i < cost_matrix.size(); i++)
    {
        auto agent_id = free_agents_and_before_pickup[i];
        int curr_loc = env->curr_states.at(agent_id).location;
        int agent_loc_x = curr_loc % env->cols;
        int agent_loc_y = curr_loc / env->cols;

        dist_matrix[i].resize(free_tasks_and_before_pickup.size(), 0);
        jam_matrix[i].resize(free_tasks_and_before_pickup.size(), 0);
        cost_matrix[i].resize(free_tasks_and_before_pickup.size(), 0);

        for (int j = 0; j < free_tasks_and_before_pickup.size(); j++)
        {
            auto task_id = free_tasks_and_before_pickup[j];
            int pickup_loc = env->task_pool[task_id].locations[0];

            int sum_jam_weight = compute_jam_task_double_circle_count_current(agent_id, agent_loc_x,
                agent_loc_y, pickup_loc);
            // cout << "traffic jam: " << sum_jam_weight << endl;

            int dist = DefaultPlanner::get_h(env, curr_loc, pickup_loc) + task_distances[task_id];
            dist_matrix[i][j] = dist;
            // 在算代价时, sum_jam_weight要乘以系数; 记录时, 不乘系数
            jam_matrix[i][j] = sum_jam_weight;
            // 计算agent id完成task id的成本
            cost_matrix[i][j] = dist + sum_jam_weight * jam_coefficient;
        }
    }

    /*
    cout << "jam matrix: " << endl;
    for (int i = 0; i < jam_matrix.size(); i++)
    {
        for (int j = 0; j < jam_matrix[i].size(); j++)
        {
            cout << jam_matrix[i][j] << " ";
        }
        cout << endl;
    }
    cout << endl;
    */

    vector<int> work_assignment; // "worker " << i << ", assignment " << work_assignment[i]
    Hungarian HungAlgo(cost_matrix);
    // HungAlgo.print_cost_matrix();
    // cout << "prev cost: " << prev_best_total_distance << endl;
    int cost = HungAlgo.Solve(work_assignment); // 如果后续算拥堵系数, cost和prev_best的类型改成double
    // cout << "new cost: " << cost << endl;

    if (cost != prev_best_total_distance)
    {
        prev_best_total_distance = cost;
        free_agents.clear();
        free_agents.insert(free_agents_and_before_pickup.begin(), free_agents_and_before_pickup.end());
        free_tasks.clear();
        free_tasks.insert(free_tasks_and_before_pickup.begin(), free_tasks_and_before_pickup.end());

        for (int i = 0; i < free_agents_and_before_pickup.size(); i++)
        {
            int assigned_agent = free_agents_and_before_pickup[i];
            int assigned_task = free_tasks_and_before_pickup[work_assignment[i]];

            proposed_schedule[assigned_agent] = assigned_task;

            // 该工人被分配了任务
            if (work_assignment[i] != -1)
            {
                free_agents.erase(free_agents_and_before_pickup[i]);
                free_tasks.erase(free_tasks_and_before_pickup[work_assignment[i]]);

                agent_task[assigned_agent].task_id = assigned_task;
                agent_task[assigned_agent].min_task_dist = dist_matrix[i][work_assignment[i]];
                agent_task[assigned_agent].task_heuristic = cost_matrix[i][work_assignment[i]];
                agent_task[assigned_agent].assign_moment = env->curr_timestep; // assign task moment
                agent_task[assigned_agent].jam_when_assign = jam_matrix[i][work_assignment[i]];
                // cout << "jam when assign: " << agent_task[assigned_agent].jam_when_assign << endl;
            }
        }
    }

    /*
    cout << "work assignment: ";
    for(int i=0;i<work_assignment.size();i++)
    {
        cout << work_assignment[i] << " ";
    }
    cout << endl;
     */

     /*
     cout << "proposed schedule: ";
     for(int i=0;i<proposed_schedule.size();i++)
     {
         cout << proposed_schedule[i] << " ";
     }
     cout << endl;
      //*/

    cout << "Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
    // cout << "hungarian total distance: " << cost << endl; // 2087, 比默认方法确实缩小了
}


void TaskScheduler::hungarian_sum_snatch_adaptive_jam_task_circle_count_current(int time_limit,
                                                                 std::vector<int> & proposed_schedule)
{
    //use at most half of time_limit to compute schedule, -10 for timing error tolerance
    //so that the remainning time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;
    clock_t start = clock();

    // 没有新agent就不用抢单了
    if(env->new_freeagents.empty())
    {
        return;
    }

    //*
    for(auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                 << " minDist " << agent_task[element].min_task_dist
                 << " heuristic " << agent_task[element].task_heuristic
                 << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                 << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if(numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    int counter = 0;
    for (const int& free_task_id : free_tasks)
    {
        if (counter % 10 == 0 && std::chrono::steady_clock::now() > endtime)
        {
            break;
        }

        // this task distance has been calculated
        if (task_distances.find(free_task_id) == task_distances.end())
        {
            int total_dist = 0;
            int curr_loc = env->task_pool[free_task_id].locations[0];

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[free_task_id].locations)
            {
                total_dist += DefaultPlanner::get_h(env, curr_loc, loc);
                curr_loc = loc;
            }

            task_distances[free_task_id] = total_dist;
            counter++;
            // cout << counter << endl;
        }
        else
        {
            // cout << "already in" << endl;
        }
    }

    // free agent and agent with task but before pickup
    std::vector<int> free_agents_and_before_pickup;
    free_agents_and_before_pickup.assign(free_agents.begin(), free_agents.end());

    // free tasks and tasks already assigned but before pickup
    std::vector<int> free_tasks_and_before_pickup;
    free_tasks_and_before_pickup.assign(free_tasks.begin(), free_tasks.end());

    for(const auto& element : env->task_pool)
    {
        if(element.second.agent_assigned != -1 && element.second.idx_next_loc == 0)
        {
            free_agents_and_before_pickup.emplace_back(element.second.agent_assigned);
            free_tasks_and_before_pickup.emplace_back(element.second.task_id);
        }
    }

    // 每个时间步，空闲agent数量等于新出现任务的数量。
    // cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    vector< vector<int> > dist_matrix;
    dist_matrix.resize(free_agents_and_before_pickup.size());
    vector< vector<double> > jam_matrix;
    jam_matrix.resize(free_agents_and_before_pickup.size());
    vector< vector<double> > cost_matrix;
    cost_matrix.resize(free_agents_and_before_pickup.size());
    for(int i=0;i<cost_matrix.size();i++)
    {
        auto agent_id = free_agents_and_before_pickup[i];
        int curr_loc = env->curr_states.at(agent_id).location;
        int agent_loc_x = curr_loc % env->cols;
        int agent_loc_y = curr_loc / env->cols;

        dist_matrix[i].resize(free_tasks_and_before_pickup.size(), 0);
        jam_matrix[i].resize(free_tasks_and_before_pickup.size(), 0);
        cost_matrix[i].resize(free_tasks_and_before_pickup.size(), 0);

        for(int j=0;j<free_tasks_and_before_pickup.size();j++)
        {
            auto task_id = free_tasks_and_before_pickup[j];
            int pickup_loc = env->task_pool[task_id].locations[0];

            int sum_jam_weight = compute_jam_task_circle_count_current(agent_id, agent_loc_x,
                                                                       agent_loc_y, pickup_loc);
            // cout << "traffic jam: " << sum_jam_weight << endl;

            int dist = DefaultPlanner::get_h(env, curr_loc, pickup_loc) + task_distances[task_id];
            dist_matrix[i][j] = dist;
            // 在算代价时, sum_jam_weight要乘以系数; 记录时, 不乘系数
            jam_matrix[i][j] = sum_jam_weight;
            // 计算agent id完成task id的成本
            cost_matrix[i][j] = dist + sum_jam_weight * jam_coefficient;
        }
    }

    vector<int> work_assignment; // "worker " << i << ", assignment " << work_assignment[i]
    Hungarian HungAlgo(cost_matrix);
    // HungAlgo.print_cost_matrix();
    // cout << "prev cost: " << prev_best_total_distance << endl;
    int cost = HungAlgo.Solve(work_assignment); // 如果后续算拥堵系数, cost和prev_best的类型改成double
    // cout << "new cost: " << cost << endl;

    if (cost != prev_best_total_distance)
    {
        prev_best_total_distance = cost;
        free_agents.clear();
        free_agents.insert(free_agents_and_before_pickup.begin(), free_agents_and_before_pickup.end());
        free_tasks.clear();
        free_tasks.insert(free_tasks_and_before_pickup.begin(), free_tasks_and_before_pickup.end());

        for(int i=0; i < free_agents_and_before_pickup.size(); i++)
        {
            int assigned_agent = free_agents_and_before_pickup[i];
            int assigned_task = free_tasks_and_before_pickup[work_assignment[i]];

            proposed_schedule[assigned_agent] = assigned_task;

            // 该工人被分配了任务
            if(work_assignment[i] != -1)
            {
                free_agents.erase(free_agents_and_before_pickup[i]);
                free_tasks.erase(free_tasks_and_before_pickup[work_assignment[i]]);

                agent_task[assigned_agent].task_id = assigned_task;
                agent_task[assigned_agent].min_task_dist  = dist_matrix[i][work_assignment[i]];
                agent_task[assigned_agent].task_heuristic = cost_matrix[i][work_assignment[i]];
                agent_task[assigned_agent].assign_moment = env->curr_timestep; // assign task moment
                agent_task[assigned_agent].jam_when_assign = jam_matrix[i][work_assignment[i]];
                // cout << "jam when assign: " << agent_task[assigned_agent].jam_when_assign << endl;
            }
        }
    }

    /*
    cout << "work assignment: ";
    for(int i=0;i<work_assignment.size();i++)
    {
        cout << work_assignment[i] << " ";
    }
    cout << endl;
     */

    /*
    cout << "proposed schedule: ";
    for(int i=0;i<proposed_schedule.size();i++)
    {
        cout << proposed_schedule[i] << " ";
    }
    cout << endl;
     //*/

    cout << "Time Usage: " <<  ((float)(clock() - start))/CLOCKS_PER_SEC <<endl;
    // cout << "hungarian total distance: " << cost << endl; // 2087, 比默认方法确实缩小了
}

int TaskScheduler::compute_jam_task_circle_count_current_busy(int _agent_id, int _agent_loc_x,
                       int _agent_loc_y, int _pickup_loc, std::vector<int> & proposed_schedule) const
{
    int sum_jam_weight = 0;

    int pickup_loc_x = _pickup_loc % env->cols;
    int pickup_loc_y = _pickup_loc / env->cols;
    // cout << "pickup loc " << pickup_twodim.x << " " << pickup_twodim.y << endl;

    // 当前agent指向某个任务的向量
    int agent_task_direction_x = pickup_loc_x - _agent_loc_x;
    int agent_task_direction_y = pickup_loc_y - _agent_loc_y;
    int agent_task_direction_square = agent_task_direction_x * agent_task_direction_x +
                                      agent_task_direction_y * agent_task_direction_y;

    for(int j=0;j<env->curr_states.size();j++)
    {
        if (j != _agent_id && proposed_schedule[j] != -1) // 只统计有任务的agent
        {
            int other_agent_loc = env->curr_states.at(j).location;
            int other_agent_loc_x = other_agent_loc % env->cols;
            int other_agent_loc_y = other_agent_loc / env->cols;
            // cout << "other agent loc " << other_agent_loc << " " << other_agent_loc_x << " "
            // << other_agent_loc_y << endl;

            int other_task_direction_x = pickup_loc_x - other_agent_loc_x;
            int other_task_direction_y = pickup_loc_y - other_agent_loc_y;
            // cout << "other agent direction " << agent_other_direction_x << " " << other_agent_loc_y << endl;
            int other_task_distance_square = other_task_direction_x * other_task_direction_x
                                             + other_task_direction_y * other_task_direction_y;

            // 只统计以task为圆心, agent-task范围内的other agent
            if(other_task_distance_square < agent_task_direction_square)
            {
                sum_jam_weight++;
            }
        }
    }

    return sum_jam_weight;
}

// 以task pickup为圆心，agent-task为半径朝向task画出一个圆，位于这个圆内有任务的other agent的数量为拥堵系数。
void TaskScheduler::adaptive_jam_task_circle_count_current_busy(int time_limit, std::vector<int> & proposed_schedule)
{
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for(auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                 << " minDist " << agent_task[element].min_task_dist
                 << " heuristic " << agent_task[element].task_heuristic
                 << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                 << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if(numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;
        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            //check for timeout every 10 task evaluations
            if (count % 10 == 0 && std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;

            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations){
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            int pickup_loc = env->task_pool[t_id].locations[0];
            int sum_jam_weight = compute_jam_task_circle_count_current_busy(i, agent_loc_x,
                                                agent_loc_y, pickup_loc, proposed_schedule);

            // sum_jam_weight * jam_coefficient = guess delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic){
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1){
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist  = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
            // nothing to assign
        else{
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Time Usage: " <<  ((float)(clock() - start))/CLOCKS_PER_SEC <<endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: "<< env->new_tasks.size() <<  endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}


// 以task pickup为圆心，agent-task为半径朝向task画出一个圆，位于这个圆内的other agent的数量（只考察前2048个agent）为拥堵系数。
void TaskScheduler::adaptive_jam_task_circle_count_current_sample(int time_limit,
                                                                  std::vector<int> & proposed_schedule, int _num_sample)
{
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for(auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                 << " minDist " << agent_task[element].min_task_dist
                 << " heuristic " << agent_task[element].task_heuristic
                 << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                 << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if(numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    int min_task_i, dist, c_loc;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    int count = 0;
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (count % 10 == 0 && std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // the theoretical lower bound of accomplishing this task
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;
        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            //check for timeout every 10 task evaluations
            if (std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            int sum_jam_weight = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations){
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            /*
            if(OneDim2TwoDim.find(env->task_pool[t_id].locations[0]) == OneDim2TwoDim.end())
            {
                cerr << "map error!" << endl;
            }
            */

            int pickup_loc = env->task_pool[t_id].locations[0];
            int pickup_loc_x = env->task_pool[t_id].locations[0] % env->cols;
            int pickup_loc_y = env->task_pool[t_id].locations[0] / env->cols;
            // cout << "pickup loc " << pickup_twodim.x << " " << pickup_twodim.y << endl;

            // the vector from an agent to its task
            int agent_task_direction_x = pickup_loc_x - agent_loc_x;
            int agent_task_direction_y = pickup_loc_y - agent_loc_y;
            int agent_task_direction_square = agent_task_direction_x * agent_task_direction_x +
                                              agent_task_direction_y * agent_task_direction_y;

            for(int j=0;j<env->curr_states.size();j++)
            {
                if (j != i && j < _num_sample) // 所有agent都会有任务, 所以都要计入
                {
                    int other_agent_loc = env->curr_states.at(j).location;
                    int other_agent_loc_x = other_agent_loc % env->cols;
                    int other_agent_loc_y = other_agent_loc / env->cols;
                    // cout << "other agent loc " << other_agent_loc << " " << other_agent_loc_x << " "
                    // << other_agent_loc_y << endl;

                    int other_task_direction_x = pickup_loc_x - other_agent_loc_x;
                    int other_task_direction_y = pickup_loc_y - other_agent_loc_y;
                    // cout << "other agent direction " << agent_other_direction_x << " " << other_agent_loc_y << endl;
                    int other_task_distance_square = other_task_direction_x * other_task_direction_x
                                                     + other_task_direction_y * other_task_direction_y;

                    // 只统计以task为圆心, agent-task范围内的other agent
                    if(other_task_distance_square < agent_task_direction_square)
                    {
                        sum_jam_weight++;
                    }
                }
            }

            // sum_jam_weight * jam_coefficient = guess delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic){
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1){
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist  = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
            // nothing to assign
        else{
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Time Usage: " <<  ((float)(clock() - start))/CLOCKS_PER_SEC <<endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: "<< env->new_tasks.size() <<  endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}


// 以task pickup为圆心，agent-task为半径朝向task画出一个圆，位于这个圆内的other agent的数量为拥堵系数。
void TaskScheduler::adaptive_jam_task_circle_count_current_extrapolation(int time_limit, std::vector<int> & proposed_schedule)
{
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for(auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                 << " minDist " << agent_task[element].min_task_dist
                 << " heuristic " << agent_task[element].task_heuristic
                 << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                 << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if(numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;
        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            //check for timeout every 10 task evaluations
            if (std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            int sum_jam_weight = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations){
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            /*
            if(OneDim2TwoDim.find(env->task_pool[t_id].locations[0]) == OneDim2TwoDim.end())
            {
                cerr << "map error!" << endl;
            }
            */

            int pickup_loc = env->task_pool[t_id].locations[0];
            int pickup_loc_x = env->task_pool[t_id].locations[0] % env->cols;
            int pickup_loc_y = env->task_pool[t_id].locations[0] / env->cols;
            // cout << "pickup loc " << pickup_twodim.x << " " << pickup_twodim.y << endl;

            // 当前agent指向某个任务的向量
            int agent_task_direction_x = pickup_loc_x - agent_loc_x;
            int agent_task_direction_y = pickup_loc_y - agent_loc_y;
            int agent_task_direction_square = agent_task_direction_x * agent_task_direction_x +
                                              agent_task_direction_y * agent_task_direction_y;

            for(int j=0;j<env->curr_states.size();j++)
            {
                if (j != i) // 所有agent都会有任务, 所以都要计入
                {
                    int other_agent_loc = env->curr_states.at(j).location;
                    int other_agent_loc_x = other_agent_loc % env->cols;
                    int other_agent_loc_y = other_agent_loc / env->cols;
                    // cout << "other agent loc " << other_agent_loc << " " << other_agent_loc_x << " "
                    // << other_agent_loc_y << endl;

                    int other_task_direction_x = pickup_loc_x - other_agent_loc_x;
                    int other_task_direction_y = pickup_loc_y - other_agent_loc_y;
                    // cout << "other agent direction " << agent_other_direction_x << " " << other_agent_loc_y << endl;
                    int other_task_distance_square = other_task_direction_x * other_task_direction_x
                                                     + other_task_direction_y * other_task_direction_y;

                    // 只统计以task为圆心, agent-task范围内的other agent
                    if(other_task_distance_square < agent_task_direction_square)
                    {
                        sum_jam_weight++;
                    }
                }
            }

            // sum_jam_weight * jam_coefficient * extrapolation = guess delay time
            if (dist + sum_jam_weight * jam_coefficient * dist /
                    DefaultPlanner::get_h(env, agent_loc, pickup_loc) < min_task_heuristic)
            {
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1){
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist  = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
            // nothing to assign
        else{
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Time Usage: " <<  ((float)(clock() - start))/CLOCKS_PER_SEC <<endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: "<< env->new_tasks.size() <<  endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

int TaskScheduler::compute_jam_pickup_delivery_circle_count_current(int _agent_id, int _pickup_loc_x, int _pickup_loc_y, 
    int _dist_pickup_delivery_square) const
{
    int sum_jam_weight = 0;

    // cout << "pickup loc " << pickup_twodim.x << " " << pickup_twodim.y << endl;

    for (int j = 0; j < env->curr_states.size(); j++)
    {
        if (j != _agent_id) // 所有agent都会有任务, 所以都要计入
        {
            int other_agent_loc = env->curr_states.at(j).location;
            int other_agent_loc_x = other_agent_loc % env->cols;
            int other_agent_loc_y = other_agent_loc / env->cols;
            // cout << "other agent loc " << other_agent_loc << " " << other_agent_loc_x << " "
            // << other_agent_loc_y << endl;

            int other_task_direction_x = _pickup_loc_x - other_agent_loc_x;
            int other_task_direction_y = _pickup_loc_y - other_agent_loc_y;
            // cout << "other agent direction " << agent_other_direction_x << " " << other_agent_loc_y << endl;
            int other_task_distance_square = other_task_direction_x * other_task_direction_x
                + other_task_direction_y * other_task_direction_y;

            // 只统计以pickup为圆心, pickup-delivery范围内的other agent
            if (other_task_distance_square < _dist_pickup_delivery_square)
            {
                sum_jam_weight++;
            }
        }
    }

    return sum_jam_weight;
}

// 1.1.4: 统计以pickup为圆心，|pickup-delivery|为半径的圆中other agent的数量作为jam
void TaskScheduler::adaptive_jam_pickup_delivery_circle_count_current(int time_limit, std::vector<int>& proposed_schedule)
{
    cout << "adaptive jam task circle count current with dist agent pickup delivery" << endl;
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            total_dist_agent_pickup += agent_task[element].dist_agent_pickup;
            total_dist_pickup_delivery += agent_task[element].dist_pickup_delivery;

            average_dist_agent_pickup = static_cast<double>(total_dist_agent_pickup) / numTaskFinished;
            average_dist_pickup_delivery = static_cast<double>(total_dist_pickup_delivery) / numTaskFinished;

            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;

            // cout << "total dist agent pickup: " << total_dist_agent_pickup << " "
            //    << "total dist pickup delivery: " << total_dist_pickup_delivery << endl;

            cout << "average dist agent pickup: " << average_dist_agent_pickup << " "
                << "average dist pickup delivery: " << average_dist_pickup_delivery << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        // int agent_loc = env->curr_states.at(i).location;
        // int agent_loc_x = agent_loc % env->cols;
        // int agent_loc_y = agent_loc / env->cols;
        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            //check for timeout every 10 task evaluations
            if (std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations) {
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            int pickup_loc = env->task_pool[t_id].locations[0];
            int pickup_loc_x = pickup_loc % env->cols;
            int pickup_loc_y = pickup_loc / env->cols;

            int delivery_loc = env->task_pool[t_id].locations[1];
            int delivery_loc_x = delivery_loc % env->cols;
            int delivery_loc_y = delivery_loc / env->cols;

            int dist_pickup_delivery_square = (pickup_loc_x - delivery_loc_x) * (pickup_loc_x - delivery_loc_x)
                + (pickup_loc_y - delivery_loc_y) * (pickup_loc_y - delivery_loc_y);
            
            int sum_jam_weight = compute_jam_pickup_delivery_circle_count_current(i, pickup_loc_x,
                pickup_loc_y, dist_pickup_delivery_square);

            // sum_jam_weight * jam_coefficient = guess delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic) {
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1) {
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].dist_agent_pickup = DefaultPlanner::get_h(env, env->curr_states.at(i).location, env->task_pool[min_task_i].locations[0]);
            agent_task[i].dist_pickup_delivery = DefaultPlanner::get_h(env, env->task_pool[min_task_i].locations[0], env->task_pool[min_task_i].locations[1]);
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
        // nothing to assign
        else {
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

int TaskScheduler::compute_jam_both_circle_count_current(int _agent_id, int _pickup_loc_x, int _pickup_loc_y,
    int _dist_pickup_delivery_square) const
{
    int sum_jam_weight = 0;

    // cout << "pickup loc " << pickup_twodim.x << " " << pickup_twodim.y << endl;

    for (int j = 0; j < env->curr_states.size(); j++)
    {
        if (j != _agent_id) // 所有agent都会有任务, 所以都要计入
        {
            int other_agent_loc = env->curr_states.at(j).location;
            int other_agent_loc_x = other_agent_loc % env->cols;
            int other_agent_loc_y = other_agent_loc / env->cols;
            // cout << "other agent loc " << other_agent_loc << " " << other_agent_loc_x << " "
            // << other_agent_loc_y << endl;

            int other_task_direction_x = _pickup_loc_x - other_agent_loc_x;
            int other_task_direction_y = _pickup_loc_y - other_agent_loc_y;
            // cout << "other agent direction " << agent_other_direction_x << " " << other_agent_loc_y << endl;
            int other_task_distance_square = other_task_direction_x * other_task_direction_x
                + other_task_direction_y * other_task_direction_y;

            // 只统计以pickup为圆心, pickup-delivery范围内的other agent
            if (other_task_distance_square < _dist_pickup_delivery_square)
            {
                sum_jam_weight++;
            }
        }
    }

    return sum_jam_weight;
}

// 1.1.5: 统计以pickup为圆心，|agent-pickup|和|pickup-delivery|为半径的圆中other agent的数量作为jam
void TaskScheduler::adaptive_jam_both_circle_count_current(int time_limit, std::vector<int>& proposed_schedule)
{
    cout << "adaptive jam task circle count current with dist agent pickup delivery" << endl;
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            total_dist_agent_pickup += agent_task[element].dist_agent_pickup;
            total_dist_pickup_delivery += agent_task[element].dist_pickup_delivery;

            average_dist_agent_pickup = static_cast<double>(total_dist_agent_pickup) / numTaskFinished;
            average_dist_pickup_delivery = static_cast<double>(total_dist_pickup_delivery) / numTaskFinished;

            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;

            // cout << "total dist agent pickup: " << total_dist_agent_pickup << " "
            //    << "total dist pickup delivery: " << total_dist_pickup_delivery << endl;

            cout << "average dist agent pickup: " << average_dist_agent_pickup << " "
                << "average dist pickup delivery: " << average_dist_pickup_delivery << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        // int agent_loc = env->curr_states.at(i).location;
        // int agent_loc_x = agent_loc % env->cols;
        // int agent_loc_y = agent_loc / env->cols;
        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            //check for timeout every 10 task evaluations
            if (std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations) {
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            int pickup_loc = env->task_pool[t_id].locations[0];
            int pickup_loc_x = pickup_loc % env->cols;
            int pickup_loc_y = pickup_loc / env->cols;

            int delivery_loc = env->task_pool[t_id].locations[1];
            int delivery_loc_x = delivery_loc % env->cols;
            int delivery_loc_y = delivery_loc / env->cols;

            int dist_pickup_delivery_square = (pickup_loc_x - delivery_loc_x) * (pickup_loc_x - delivery_loc_x)
                + (pickup_loc_y - delivery_loc_y) * (pickup_loc_y - delivery_loc_y);

            int sum_jam_weight = compute_jam_both_circle_count_current(i, pickup_loc_x,
                pickup_loc_y, dist_pickup_delivery_square);

            // sum_jam_weight * jam_coefficient = guess delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic) {
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1) {
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].dist_agent_pickup = DefaultPlanner::get_h(env, env->curr_states.at(i).location, env->task_pool[min_task_i].locations[0]);
            agent_task[i].dist_pickup_delivery = DefaultPlanner::get_h(env, env->task_pool[min_task_i].locations[0], env->task_pool[min_task_i].locations[1]);
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
        // nothing to assign
        else {
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 1.2: 用地图以12x12方形分割区域, task所在区域中agent的数量作为jam
void TaskScheduler::adaptive_jam_task_pickup_region_count_current(int time_limit, std::vector<int> & proposed_schedule)
{
    cout << "adaptive jam task pickup region count current" << endl;
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for(auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                 << " minDist " << agent_task[element].min_task_dist
                 << " heuristic " << agent_task[element].task_heuristic
                 << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                 << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if(numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    if(free_agents.size() > 50)
    {
        if(first_epoch_done_time == -1)
        {
            // 由于大算例初始任务过多, 在初始任务分配完成前采用默认算法
            greedy_sum_without_newtask(time_limit, proposed_schedule);
            return;
        }
    }
    else
    {
        if(first_epoch_done_time == -1)
        {
            first_epoch_done_time = env->curr_timestep; // 初始阶段的任务分配完毕的时间
        }
    }

    int region_column = 12; // 每个region所占的列数
    int region_row = 12; // 每个region所占的行数

    // 地图有几列region
    int num_region_column = std::ceil((double)env->cols / region_column);
    // 地图有几行region
    int num_region_row = std::ceil((double)env->rows / region_row);

    // 将map分为若干区域, 统计每个区域agent的数量
    vector<int> region_agent_num(num_region_column * num_region_row, 0);

    for (int i=0;i<env->num_of_agents;i++)
    {
        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;

        int agent_region_x = agent_loc_x / region_column;
        int agent_region_y = agent_loc_y / region_row;

        region_agent_num[agent_region_y * num_region_column + agent_region_x]++;
    }

    /*
    cout << "region agent num: ";
    for(int i : region_agent_num)
    {
        cout << i << " ";
    }
    cout << endl;
     //*/

    if(env->num_of_agents <= 500) // 小算例直接算
    {
        for (int t_id : env->new_tasks)
        {
            int pickup_loc = env->task_pool[t_id].locations[0];
            int pickup_loc_x = pickup_loc % env->cols;
            int pickup_loc_y = pickup_loc / env->cols;

            int pickup_region_x = pickup_loc_x / region_column;
            int pickup_region_y = pickup_loc_y / region_row;

            task_region[t_id] = pickup_region_y * num_region_column + pickup_region_x;
        }
    }
    else // 大算例
    {
        if(env->curr_timestep == first_epoch_done_time) // 在first_epoch_done_time计算完此时的free tasks
        {
            for (int t_id : free_tasks)
            {
                int pickup_loc = env->task_pool[t_id].locations[0];
                int pickup_loc_x = pickup_loc % env->cols;
                int pickup_loc_y = pickup_loc / env->cols;

                int pickup_region_x = pickup_loc_x / region_column;
                int pickup_region_y = pickup_loc_y / region_row;

                task_region[t_id] = pickup_region_y * num_region_column + pickup_region_x;
            }
        }
        else // first_epoch_done_time之后就只计算新任务
        {
            for (int t_id : env->new_tasks)
            {
                int pickup_loc = env->task_pool[t_id].locations[0];
                int pickup_loc_x = pickup_loc % env->cols;
                int pickup_loc_y = pickup_loc / env->cols;

                int pickup_region_x = pickup_loc_x / region_column;
                int pickup_region_y = pickup_loc_y / region_row;

                task_region[t_id] = pickup_region_y * num_region_column + pickup_region_x;
            }
        }
    }


    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            // check for timeout every 10 task evaluations
            if (std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations){
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            int sum_jam_weight = region_agent_num[task_region[t_id]];

            // cout << "sum jam weight " << sum_jam_weight << endl;

            // sum_jam_weight * jam_coefficient = estimated delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic){
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1){
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist  = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
            // nothing to assign
        else{
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Task Time Usage: " <<  ((float)(clock() - start))/CLOCKS_PER_SEC <<endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: "<< env->new_tasks.size() <<  endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 1.2.-3: 用地图以12x12方形分割区域, task所在区域中agent goal的数量作为jam
void TaskScheduler::adaptive_jam_task_pickup_region_count_goal(int time_limit, std::vector<int>& proposed_schedule)
{
    cout << "adaptive jam task pickup region count goal" << endl;
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    if (free_agents.size() > 50)
    {
        if (first_epoch_done_time == -1)
        {
            // 由于大算例初始任务过多, 在初始任务分配完成前采用默认算法
            greedy_sum_without_newtask(time_limit, proposed_schedule);
            return;
        }
    }
    else
    {
        if (first_epoch_done_time == -1)
        {
            first_epoch_done_time = env->curr_timestep; // 初始阶段的任务分配完毕的时间
        }
    }

    int region_column = 12; // 每个region所占的列数
    int region_row = 12; // 每个region所占的行数

    // 地图有几列region
    int num_region_column = std::ceil((double)env->cols / region_column);
    // 地图有几行region
    int num_region_row = std::ceil((double)env->rows / region_row);

    // Step 1: 将map分为若干区域, 统计每个区域agent goal的数量
    vector<int> region_goal_num(num_region_column * num_region_row, 0);

    for (int i = 0; i < env->goal_locations.size(); i++)
    {
        if (!env->goal_locations[i].empty()) // 这里goal_locations.size()==1, for循环用不用都无所谓
        {
            for (auto const& goal : env->goal_locations[i])
            {
                int agent_goal = goal.first;
                int agent_goal_x = agent_goal % env->cols;
                int agent_goal_y = agent_goal / env->cols;

                int agent_region_x = agent_goal_x / region_column;
                int agent_region_y = agent_goal_y / region_row;

                region_goal_num[agent_region_y * num_region_column + agent_region_x]++;
            }
        }
    }

    /*
    cout << "region goal num: ";
    for(int i : region_goal_num)
    {
        cout << i << " ";
    }
    cout << endl;
     //*/

    // Step 2: 计算每个task归属于哪个区域。
    if (env->curr_timestep == first_epoch_done_time) // 在first_epoch_done_time计算完此时的free tasks
    {
        for (int t_id : free_tasks)
        {
            int pickup_loc = env->task_pool[t_id].locations[0];
            int pickup_loc_x = pickup_loc % env->cols;
            int pickup_loc_y = pickup_loc / env->cols;

            int pickup_region_x = pickup_loc_x / region_column;
            int pickup_region_y = pickup_loc_y / region_row;

            task_region[t_id] = pickup_region_y * num_region_column + pickup_region_x;
        }
    }
    else // first_epoch_done_time之后就只计算新任务
    {
        for (int t_id : env->new_tasks)
        {
            int pickup_loc = env->task_pool[t_id].locations[0];
            int pickup_loc_x = pickup_loc % env->cols;
            int pickup_loc_y = pickup_loc / env->cols;

            int pickup_region_x = pickup_loc_x / region_column;
            int pickup_region_y = pickup_loc_y / region_row;

            task_region[t_id] = pickup_region_y * num_region_column + pickup_region_x;
        }
    }

    /*
    for (const auto& pair : task_region)
    {
        std::cout << "Task ID: " << pair.first << " -> Errand Regions: " << pair.second << endl;
    }
    //*/

    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            // check for timeout every 10 task evaluations
            if (std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations) {
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            // Step 3: 根据task所属区域估计执行成本。
            int sum_jam_weight = region_goal_num[task_region[t_id]];

            // cout << "sum jam weight " << sum_jam_weight << endl;

            // sum_jam_weight * jam_coefficient = estimated delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic) {
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1) {
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
        // nothing to assign
        else {
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Task Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 1.2.-2: 将地图分成12x12的区域, task所在区域中agent的数量作为sum jam weight. 用agent区域数量修正估计
void TaskScheduler::adaptive_jam_agent_pickup_region_count_current(int time_limit, std::vector<int>& proposed_schedule)
{
    cout << "adaptive jam agent pickup region count current" << endl;
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    if (free_agents.size() > 50)
    {
        if (first_epoch_done_time == -1)
        {
            // 由于大算例初始任务过多, 在初始任务分配完成前采用默认算法
            greedy_sum_without_newtask(time_limit, proposed_schedule);
            return;
        }
    }
    else
    {
        if (first_epoch_done_time == -1)
        {
            first_epoch_done_time = env->curr_timestep; // 初始阶段的任务分配完毕的时间
        }
    }

    int region_column = 12; // 每个region所占的列数
    int region_row = 12; // 每个region所占的行数

    // 地图有几列region
    int num_region_column = std::ceil((double)env->cols / region_column);
    // 地图有几行region
    int num_region_row = std::ceil((double)env->rows / region_row);

    // 将map分为若干区域, 统计每个区域agent的数量
    vector<int> region_agent_num(num_region_column * num_region_row, 0);

    for (int i = 0; i < env->num_of_agents; i++)
    {
        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;

        int agent_region_x = agent_loc_x / region_column;
        int agent_region_y = agent_loc_y / region_row;

        region_agent_num[agent_region_y * num_region_column + agent_region_x]++;
    }

    /*
    cout << "region agent num: ";
    for(int i : region_agent_num)
    {
        cout << i << " ";
    }
    cout << endl;
     //*/


    if (env->curr_timestep == first_epoch_done_time) // 在first_epoch_done_time计算完此时的free tasks
    {
        for (int t_id : free_tasks)
        {
            int pickup_loc = env->task_pool[t_id].locations[0];
            int pickup_loc_x = pickup_loc % env->cols;
            int pickup_loc_y = pickup_loc / env->cols;

            int pickup_region_x = pickup_loc_x / region_column;
            int pickup_region_y = pickup_loc_y / region_row;

            task_region[t_id] = pickup_region_y * num_region_column + pickup_region_x;
        }
    }
    else // first_epoch_done_time之后就只计算新任务
    {
        for (int t_id : env->new_tasks)
        {
            int pickup_loc = env->task_pool[t_id].locations[0];
            int pickup_loc_x = pickup_loc % env->cols;
            int pickup_loc_y = pickup_loc / env->cols;

            int pickup_region_x = pickup_loc_x / region_column;
            int pickup_region_y = pickup_loc_y / region_row;

            task_region[t_id] = pickup_region_y * num_region_column + pickup_region_x;
        }
    }

    /*
    for (const auto& pair : task_region) 
    {
        std::cout << "Task ID: " << pair.first << " -> Errand Regions: " << pair.second << endl;
    }
    */

    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            // check for timeout every 10 task evaluations
            if (std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations) {
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            int sum_jam_weight = region_agent_num[task_region[t_id]];

            // cout << "sum jam weight " << sum_jam_weight << endl;

            // sum_jam_weight * jam_coefficient = estimated delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic) {
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1) {
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist = min_task_dist;

            // 用agent所在region的agent数量修正task_heuristic
            int agent_loc = env->curr_states.at(i).location;
            int agent_loc_x = agent_loc % env->cols;
            int agent_loc_y = agent_loc / env->cols;

            int agent_region_x = agent_loc_x / region_column;
            int agent_region_y = agent_loc_y / region_row;
            int agent_region = agent_region_y * num_region_column + agent_region_x;

            if (agent_region != task_region[min_task_i])
            {
                // region_agent_num[agent_region] - 1是为了排除掉自己
                min_task_heuristic += (region_agent_num[agent_region] - 1) * jam_coefficient / 2;
            }
            else
            {
                // cout << "agent pickup same region" << endl;
            }

            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
        // nothing to assign
        else {
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Task Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 1.2.-1: 将地图分成大小可变的方块区域, 边长为|agent-pickup|均值, pickup所在区域中agent的数量作为sum jam weight
void TaskScheduler::adaptive_jam_adaptive_pickup_region_count_current(int time_limit, std::vector<int>& proposed_schedule)
{
    cout << "adaptive jam adaptive pickup region count current" << endl;
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            total_dist_agent_pickup += agent_task[element].dist_agent_pickup;

            small_region_column = total_dist_agent_pickup / numTaskFinished;
            small_region_row = total_dist_agent_pickup / numTaskFinished;

            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;
            
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;        
    }

    cout << "current jam coefficient: " << jam_coefficient << endl;
    cout << "region length: " << small_region_column << endl;

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    if (free_agents.size() > 50)
    {
        if (first_epoch_done_time == -1)
        {
            // 由于大算例初始任务过多, 在初始任务分配完成前采用默认算法
            greedy_sum_without_newtask(time_limit, proposed_schedule);
            return;
        }
    }
    else
    {
        if (first_epoch_done_time == -1)
        {
            first_epoch_done_time = env->curr_timestep; // 初始阶段的任务分配完毕的时间
        }
    }

    // 地图有几列region
    num_small_region_column = std::ceil((double)env->cols / small_region_column);
    // 地图有几行region
    num_small_region_row = std::ceil((double)env->rows / small_region_row);

    // 将map分为若干区域, 统计每个区域agent的数量
    vector<int> region_agent_num(num_small_region_column * num_small_region_row, 0);

    for (int i = 0; i < env->num_of_agents; i++)
    {
        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;

        int agent_region_x = agent_loc_x / small_region_column;
        int agent_region_y = agent_loc_y / small_region_row;

        region_agent_num[agent_region_y * num_small_region_column + agent_region_x]++;
    }

    /*
    cout << "region agent num: ";
    for(int i : region_agent_num)
    {
        cout << i << " ";
    }
    cout << endl;
     //*/


    if (env->curr_timestep == first_epoch_done_time) // 在first_epoch_done_time计算完此时的free tasks
    {
        for (int t_id : free_tasks)
        {
            int pickup_loc = env->task_pool[t_id].locations[0];
            int pickup_loc_x = pickup_loc % env->cols;
            int pickup_loc_y = pickup_loc / env->cols;

            int pickup_region_x = pickup_loc_x / small_region_column;
            int pickup_region_y = pickup_loc_y / small_region_row;

            task_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;
        }
    }
    else // first_epoch_done_time之后就只计算新任务
    {
        for (int t_id : env->new_tasks)
        {
            int pickup_loc = env->task_pool[t_id].locations[0];
            int pickup_loc_x = pickup_loc % env->cols;
            int pickup_loc_y = pickup_loc / env->cols;

            int pickup_region_x = pickup_loc_x / small_region_column;
            int pickup_region_y = pickup_loc_y / small_region_row;

            task_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;
        }
    }


    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            // check for timeout every 10 task evaluations
            if (std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations) {
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            int sum_jam_weight = region_agent_num[task_region[t_id]];

            // cout << "sum jam weight " << sum_jam_weight << endl;

            // sum_jam_weight * jam_coefficient = estimated delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic) {
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1) {
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].dist_agent_pickup = DefaultPlanner::get_h(env, env->curr_states.at(i).location, env->task_pool[min_task_i].locations[0]);
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
        // nothing to assign
        else {
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Task Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 1.2.0: 将地图分成8x8的区域, task pickup区域agent数量作为sum jam weight, 叠加匈牙利抢单算法
void TaskScheduler::hungarian_sum_snatch_adaptive_jam_task_pickup_region_count_current(int time_limit,
    std::vector<int>& proposed_schedule)
{
    cout << "hungarian sum snatch adaptive jam task pickup region count current" << endl;
    //use at most half of time_limit to compute schedule, -10 for timing error tolerance
    //so that the remainning time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;
    clock_t start = clock();

    // 没有新agent就不用抢单了
    if (env->new_freeagents.empty())
    {
        return;
    }

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    int counter = 0;
    for (const int& free_task_id : free_tasks)
    {
        if (counter % 10 == 0 && std::chrono::steady_clock::now() > endtime)
        {
            break;
        }

        // this task distance has been calculated
        if (task_distances.find(free_task_id) == task_distances.end())
        {
            int total_dist = 0;
            int curr_loc = env->task_pool[free_task_id].locations[0];

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[free_task_id].locations)
            {
                total_dist += DefaultPlanner::get_h(env, curr_loc, loc);
                curr_loc = loc;
            }

            task_distances[free_task_id] = total_dist;
            counter++;
            // cout << counter << endl;
        }
        else
        {
            // cout << "already in" << endl;
        }
    }

    // free agent and agent with task but before pickup
    std::vector<int> free_agents_and_before_pickup;
    free_agents_and_before_pickup.assign(free_agents.begin(), free_agents.end());

    // free tasks and tasks already assigned but before pickup
    std::vector<int> free_tasks_and_before_pickup;
    free_tasks_and_before_pickup.assign(free_tasks.begin(), free_tasks.end());

    for (const auto& element : env->task_pool)
    {
        if (element.second.agent_assigned != -1 && element.second.idx_next_loc == 0)
        {
            free_agents_and_before_pickup.emplace_back(element.second.agent_assigned);
            free_tasks_and_before_pickup.emplace_back(element.second.task_id);
        }
    }

    // 每个时间步，空闲agent数量等于新出现任务的数量。
    // cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    int region_column = 12; // 每个region所占的列数
    int region_row = 12; // 每个region所占的行数

    // 地图有几列region
    int num_region_column = std::ceil((double)env->cols / region_column);
    // 地图有几行region
    int num_region_row = std::ceil((double)env->rows / region_row);

    // 将map分为若干区域, 统计每个区域agent的数量
    vector<int> region_agent_num(num_region_column * num_region_row, 0);

    // 每个时间步更新区域密度
    for (int i = 0; i < env->num_of_agents; i++)
    {
        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;

        int agent_region_x = agent_loc_x / region_column;
        int agent_region_y = agent_loc_y / region_row;

        region_agent_num[agent_region_y * num_region_column + agent_region_x]++;
    }

    /*
    cout << "region agent num: ";
    for(int i : region_agent_num)
    {
        cout << i << " ";
    }
    cout << endl;
     //*/

     // 更新每个可分配任务pickup点所属的区域。
     // 这个是不变的, 所以在env->new_tasks出现时计算一次就可以
    for (int t_id : env->new_tasks)
    {
        int pickup_loc = env->task_pool[t_id].locations[0];
        int pickup_loc_x = pickup_loc % env->cols;
        int pickup_loc_y = pickup_loc / env->cols;

        int pickup_region_x = pickup_loc_x / region_column;
        int pickup_region_y = pickup_loc_y / region_row;

        task_region[t_id] = pickup_region_y * num_region_column + pickup_region_x;
    }

    vector< vector<int> > dist_matrix;
    dist_matrix.resize(free_agents_and_before_pickup.size());
    vector< vector<double> > jam_matrix;
    jam_matrix.resize(free_agents_and_before_pickup.size());
    vector< vector<double> > cost_matrix;
    cost_matrix.resize(free_agents_and_before_pickup.size());
    for (int i = 0; i < cost_matrix.size(); i++)
    {
        auto agent_id = free_agents_and_before_pickup[i];
        int curr_loc = env->curr_states.at(agent_id).location;
        int agent_loc_x = curr_loc % env->cols;
        int agent_loc_y = curr_loc / env->cols;

        dist_matrix[i].resize(free_tasks_and_before_pickup.size(), 0);
        jam_matrix[i].resize(free_tasks_and_before_pickup.size(), 0);
        cost_matrix[i].resize(free_tasks_and_before_pickup.size(), 0);

        for (int j = 0; j < free_tasks_and_before_pickup.size(); j++)
        {
            auto task_id = free_tasks_and_before_pickup[j];
            int pickup_loc = env->task_pool[task_id].locations[0];

            int sum_jam_weight = region_agent_num[task_region[task_id]];;
            // cout << "traffic jam: " << sum_jam_weight << endl;

            int dist = DefaultPlanner::get_h(env, curr_loc, pickup_loc) + task_distances[task_id];
            dist_matrix[i][j] = dist;
            // 在算代价时, sum_jam_weight要乘以系数; 记录时, 不乘系数
            jam_matrix[i][j] = sum_jam_weight;
            // 计算agent id完成task id的成本
            cost_matrix[i][j] = dist + sum_jam_weight * jam_coefficient;
        }
    }

    vector<int> work_assignment; // "worker " << i << ", assignment " << work_assignment[i]
    Hungarian HungAlgo(cost_matrix);
    // HungAlgo.print_cost_matrix();
    // cout << "prev cost: " << prev_best_total_distance << endl;
    int cost = HungAlgo.Solve(work_assignment); // 如果后续算拥堵系数, cost和prev_best的类型改成double
    // cout << "new cost: " << cost << endl;

    if (cost != prev_best_total_distance)
    {
        prev_best_total_distance = cost;
        free_agents.clear();
        free_agents.insert(free_agents_and_before_pickup.begin(), free_agents_and_before_pickup.end());
        free_tasks.clear();
        free_tasks.insert(free_tasks_and_before_pickup.begin(), free_tasks_and_before_pickup.end());

        for (int i = 0; i < free_agents_and_before_pickup.size(); i++)
        {
            int assigned_agent = free_agents_and_before_pickup[i];
            int assigned_task = free_tasks_and_before_pickup[work_assignment[i]];

            proposed_schedule[assigned_agent] = assigned_task;

            // 该工人被分配了任务
            if (work_assignment[i] != -1)
            {
                free_agents.erase(free_agents_and_before_pickup[i]);
                free_tasks.erase(free_tasks_and_before_pickup[work_assignment[i]]);

                agent_task[assigned_agent].task_id = assigned_task;
                agent_task[assigned_agent].min_task_dist = dist_matrix[i][work_assignment[i]];
                agent_task[assigned_agent].task_heuristic = cost_matrix[i][work_assignment[i]];
                agent_task[assigned_agent].assign_moment = env->curr_timestep; // assign task moment
                agent_task[assigned_agent].jam_when_assign = jam_matrix[i][work_assignment[i]];
                // cout << "jam when assign: " << agent_task[assigned_agent].jam_when_assign << endl;
            }
        }
    }

    /*
    cout << "work assignment: ";
    for(int i=0;i<work_assignment.size();i++)
    {
        cout << work_assignment[i] << " ";
    }
    cout << endl;
     */

     /*
     cout << "proposed schedule: ";
     for(int i=0;i<proposed_schedule.size();i++)
     {
         cout << proposed_schedule[i] << " ";
     }
     cout << endl;
      //*/

    cout << "Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
    // cout << "hungarian total distance: " << cost << endl; // 2087, 比默认方法确实缩小了
}

// 1.2.0.1: 将地图分成8x8的区域, task pickup区域agent数量作为sum jam weight, 叠加匈牙利抢单算法
void TaskScheduler::hungarian_sum_snatch_adaptive_jam_task_pickup_region_current_density(int time_limit,
    std::vector<int>& proposed_schedule)
{
    //use at most half of time_limit to compute schedule, -10 for timing error tolerance
    //so that the remainning time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;
    clock_t start = clock();

    // 没有新agent就不用抢单了
    if (env->new_freeagents.empty())
    {
        return;
    }

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    int counter = 0;
    for (const int& free_task_id : free_tasks)
    {
        if (counter % 10 == 0 && std::chrono::steady_clock::now() > endtime)
        {
            break;
        }

        // this task distance has been calculated
        if (task_distances.find(free_task_id) == task_distances.end())
        {
            int total_dist = 0;
            int curr_loc = env->task_pool[free_task_id].locations[0];

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[free_task_id].locations)
            {
                total_dist += DefaultPlanner::get_h(env, curr_loc, loc);
                curr_loc = loc;
            }

            task_distances[free_task_id] = total_dist;
            counter++;
            // cout << counter << endl;
        }
        else
        {
            // cout << "already in" << endl;
        }
    }

    // free agent and agent with task but before pickup
    std::vector<int> free_agents_and_before_pickup;
    free_agents_and_before_pickup.assign(free_agents.begin(), free_agents.end());

    // free tasks and tasks already assigned but before pickup
    std::vector<int> free_tasks_and_before_pickup;
    free_tasks_and_before_pickup.assign(free_tasks.begin(), free_tasks.end());

    for (const auto& element : env->task_pool)
    {
        if (element.second.agent_assigned != -1 && element.second.idx_next_loc == 0)
        {
            free_agents_and_before_pickup.emplace_back(element.second.agent_assigned);
            free_tasks_and_before_pickup.emplace_back(element.second.task_id);
        }
    }

    // 每个时间步，空闲agent数量等于新出现任务的数量。
    // cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    int region_column = 8; // 每个region所占的列数
    int region_row = 8; // 每个region所占的行数

    // 地图有几列region
    int num_region_column = std::ceil((double)env->cols / region_column);
    // 地图有几行region
    int num_region_row = std::ceil((double)env->rows / region_row);

    // 将map分为若干区域, 统计每个区域agent的数量
    vector<int> region_agent_num(num_region_column * num_region_row, 0);

    // 每个时间步更新区域密度
    for (int i = 0; i < env->num_of_agents; i++)
    {
        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;

        int agent_region_x = agent_loc_x / region_column;
        int agent_region_y = agent_loc_y / region_row;

        region_agent_num[agent_region_y * num_region_column + agent_region_x]++;
    }

    /*
    cout << "region agent num: ";
    for(int i : region_agent_num)
    {
        cout << i << " ";
    }
    cout << endl;
     //*/

     // 更新每个可分配任务pickup点所属的区域。
     // 这个是不变的, 所以在env->new_tasks出现时计算一次就可以
    for (int t_id : env->new_tasks)
    {
        int pickup_loc = env->task_pool[t_id].locations[0];
        int pickup_loc_x = pickup_loc % env->cols;
        int pickup_loc_y = pickup_loc / env->cols;

        int pickup_region_x = pickup_loc_x / region_column;
        int pickup_region_y = pickup_loc_y / region_row;

        task_region[t_id] = pickup_region_y * num_region_column + pickup_region_x;
    }

    vector< vector<int> > dist_matrix;
    dist_matrix.resize(free_agents_and_before_pickup.size());
    vector< vector<double> > jam_matrix;
    jam_matrix.resize(free_agents_and_before_pickup.size());
    vector< vector<double> > cost_matrix;
    cost_matrix.resize(free_agents_and_before_pickup.size());
    for (int i = 0; i < cost_matrix.size(); i++)
    {
        auto agent_id = free_agents_and_before_pickup[i];
        int curr_loc = env->curr_states.at(agent_id).location;
        int agent_loc_x = curr_loc % env->cols;
        int agent_loc_y = curr_loc / env->cols;

        dist_matrix[i].resize(free_tasks_and_before_pickup.size(), 0);
        jam_matrix[i].resize(free_tasks_and_before_pickup.size(), 0);
        cost_matrix[i].resize(free_tasks_and_before_pickup.size(), 0);

        for (int j = 0; j < free_tasks_and_before_pickup.size(); j++)
        {
            auto task_id = free_tasks_and_before_pickup[j];
            int pickup_loc = env->task_pool[task_id].locations[0];

            double sum_jam_weight = 0;
            if (small_region_blank_num[task_region[task_id]] != 0)
            {
                sum_jam_weight = (double)region_agent_num[task_region[task_id]] / small_region_blank_num[task_region[task_id]];
            }
            // cout << "traffic jam: " << sum_jam_weight << endl;

            int dist = DefaultPlanner::get_h(env, curr_loc, pickup_loc) + task_distances[task_id];
            dist_matrix[i][j] = dist;
            // 在算代价时, sum_jam_weight要乘以系数; 记录时, 不乘系数
            jam_matrix[i][j] = sum_jam_weight;
            // 计算agent id完成task id的成本
            cost_matrix[i][j] = dist + sum_jam_weight * jam_coefficient;
        }
    }

    vector<int> work_assignment; // "worker " << i << ", assignment " << work_assignment[i]
    Hungarian HungAlgo(cost_matrix);
    // HungAlgo.print_cost_matrix();
    // cout << "prev cost: " << prev_best_total_distance << endl;
    int cost = HungAlgo.Solve(work_assignment); // 如果后续算拥堵系数, cost和prev_best的类型改成double
    // cout << "new cost: " << cost << endl;

    if (cost != prev_best_total_distance)
    {
        prev_best_total_distance = cost;
        free_agents.clear();
        free_agents.insert(free_agents_and_before_pickup.begin(), free_agents_and_before_pickup.end());
        free_tasks.clear();
        free_tasks.insert(free_tasks_and_before_pickup.begin(), free_tasks_and_before_pickup.end());

        for (int i = 0; i < free_agents_and_before_pickup.size(); i++)
        {
            int assigned_agent = free_agents_and_before_pickup[i];
            int assigned_task = free_tasks_and_before_pickup[work_assignment[i]];

            proposed_schedule[assigned_agent] = assigned_task;

            // 该工人被分配了任务
            if (work_assignment[i] != -1)
            {
                free_agents.erase(free_agents_and_before_pickup[i]);
                free_tasks.erase(free_tasks_and_before_pickup[work_assignment[i]]);

                agent_task[assigned_agent].task_id = assigned_task;
                agent_task[assigned_agent].min_task_dist = dist_matrix[i][work_assignment[i]];
                agent_task[assigned_agent].task_heuristic = cost_matrix[i][work_assignment[i]];
                agent_task[assigned_agent].assign_moment = env->curr_timestep; // assign task moment
                agent_task[assigned_agent].jam_when_assign = jam_matrix[i][work_assignment[i]];
                // cout << "jam when assign: " << agent_task[assigned_agent].jam_when_assign << endl;
            }
        }
    }

    /*
    cout << "work assignment: ";
    for(int i=0;i<work_assignment.size();i++)
    {
        cout << work_assignment[i] << " ";
    }
    cout << endl;
     */

     /*
     cout << "proposed schedule: ";
     for(int i=0;i<proposed_schedule.size();i++)
     {
         cout << proposed_schedule[i] << " ";
     }
     cout << endl;
      //*/

    cout << "Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
    // cout << "hungarian total distance: " << cost << endl; // 2087, 比默认方法确实缩小了
}

// 1.2.0.2: 将地图分成8x8的区域, task pickup区域agent密度x |agent pickup|作为sum jam weight, 叠加匈牙利抢单算法
void TaskScheduler::hungarian_sum_snatch_adaptive_jam_task_pickup_region_current_density_times_agent_pickup(int time_limit,
    std::vector<int>& proposed_schedule)
{
    //use at most half of time_limit to compute schedule, -10 for timing error tolerance
    //so that the remainning time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;
    clock_t start = clock();

    // 没有新agent就不用抢单了
    if (env->new_freeagents.empty())
    {
        return;
    }

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    int counter = 0;
    for (const int& free_task_id : free_tasks)
    {
        if (counter % 10 == 0 && std::chrono::steady_clock::now() > endtime)
        {
            break;
        }

        // this task distance has been calculated
        if (task_distances.find(free_task_id) == task_distances.end())
        {
            int total_dist = 0;
            int curr_loc = env->task_pool[free_task_id].locations[0];

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[free_task_id].locations)
            {
                total_dist += DefaultPlanner::get_h(env, curr_loc, loc);
                curr_loc = loc;
            }

            task_distances[free_task_id] = total_dist;
            counter++;
            // cout << counter << endl;
        }
        else
        {
            // cout << "already in" << endl;
        }
    }

    // free agent and agent with task but before pickup
    std::vector<int> free_agents_and_before_pickup;
    free_agents_and_before_pickup.assign(free_agents.begin(), free_agents.end());

    // free tasks and tasks already assigned but before pickup
    std::vector<int> free_tasks_and_before_pickup;
    free_tasks_and_before_pickup.assign(free_tasks.begin(), free_tasks.end());

    for (const auto& element : env->task_pool)
    {
        if (element.second.agent_assigned != -1 && element.second.idx_next_loc == 0)
        {
            free_agents_and_before_pickup.emplace_back(element.second.agent_assigned);
            free_tasks_and_before_pickup.emplace_back(element.second.task_id);
        }
    }

    // 每个时间步，空闲agent数量等于新出现任务的数量。
    // cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    int region_column = 8; // 每个region所占的列数
    int region_row = 8; // 每个region所占的行数

    // 地图有几列region
    int num_region_column = std::ceil((double)env->cols / region_column);
    // 地图有几行region
    int num_region_row = std::ceil((double)env->rows / region_row);

    // 将map分为若干区域, 统计每个区域agent的数量
    vector<int> region_agent_num(num_region_column * num_region_row, 0);

    // 每个时间步更新区域密度
    for (int i = 0; i < env->num_of_agents; i++)
    {
        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;

        int agent_region_x = agent_loc_x / region_column;
        int agent_region_y = agent_loc_y / region_row;

        region_agent_num[agent_region_y * num_region_column + agent_region_x]++;
    }

    /*
    cout << "region agent num: ";
    for(int i : region_agent_num)
    {
        cout << i << " ";
    }
    cout << endl;
     //*/

     // 更新每个可分配任务pickup点所属的区域。
     // 这个是不变的, 所以在env->new_tasks出现时计算一次就可以
    for (int t_id : env->new_tasks)
    {
        int pickup_loc = env->task_pool[t_id].locations[0];
        int pickup_loc_x = pickup_loc % env->cols;
        int pickup_loc_y = pickup_loc / env->cols;

        int pickup_region_x = pickup_loc_x / region_column;
        int pickup_region_y = pickup_loc_y / region_row;

        task_region[t_id] = pickup_region_y * num_region_column + pickup_region_x;
    }

    vector< vector<int> > dist_matrix;
    dist_matrix.resize(free_agents_and_before_pickup.size());
    vector< vector<double> > jam_matrix;
    jam_matrix.resize(free_agents_and_before_pickup.size());
    vector< vector<double> > cost_matrix;
    cost_matrix.resize(free_agents_and_before_pickup.size());
    for (int i = 0; i < cost_matrix.size(); i++)
    {
        auto agent_id = free_agents_and_before_pickup[i];
        int curr_loc = env->curr_states.at(agent_id).location;
        int agent_loc_x = curr_loc % env->cols;
        int agent_loc_y = curr_loc / env->cols;

        dist_matrix[i].resize(free_tasks_and_before_pickup.size(), 0);
        jam_matrix[i].resize(free_tasks_and_before_pickup.size(), 0);
        cost_matrix[i].resize(free_tasks_and_before_pickup.size(), 0);

        for (int j = 0; j < free_tasks_and_before_pickup.size(); j++)
        {
            auto task_id = free_tasks_and_before_pickup[j];
            int pickup_loc = env->task_pool[task_id].locations[0];

            double sum_jam_weight = 0;
            if (small_region_blank_num[task_region[task_id]] != 0)
            {
                sum_jam_weight = (double)region_agent_num[task_region[task_id]] / small_region_blank_num[task_region[task_id]];
                sum_jam_weight *= DefaultPlanner::get_h(env, curr_loc, pickup_loc);
            }
            // cout << "traffic jam: " << sum_jam_weight << endl;

            int dist = DefaultPlanner::get_h(env, curr_loc, pickup_loc) + task_distances[task_id];
            dist_matrix[i][j] = dist;
            // 在算代价时, sum_jam_weight要乘以系数; 记录时, 不乘系数
            jam_matrix[i][j] = sum_jam_weight;
            // 计算agent id完成task id的成本
            cost_matrix[i][j] = dist + sum_jam_weight * jam_coefficient;
        }
    }

    vector<int> work_assignment; // "worker " << i << ", assignment " << work_assignment[i]
    Hungarian HungAlgo(cost_matrix);
    // HungAlgo.print_cost_matrix();
    // cout << "prev cost: " << prev_best_total_distance << endl;
    int cost = HungAlgo.Solve(work_assignment); // 如果后续算拥堵系数, cost和prev_best的类型改成double
    // cout << "new cost: " << cost << endl;

    if (cost != prev_best_total_distance)
    {
        prev_best_total_distance = cost;
        free_agents.clear();
        free_agents.insert(free_agents_and_before_pickup.begin(), free_agents_and_before_pickup.end());
        free_tasks.clear();
        free_tasks.insert(free_tasks_and_before_pickup.begin(), free_tasks_and_before_pickup.end());

        for (int i = 0; i < free_agents_and_before_pickup.size(); i++)
        {
            int assigned_agent = free_agents_and_before_pickup[i];
            int assigned_task = free_tasks_and_before_pickup[work_assignment[i]];

            proposed_schedule[assigned_agent] = assigned_task;

            // 该工人被分配了任务
            if (work_assignment[i] != -1)
            {
                free_agents.erase(free_agents_and_before_pickup[i]);
                free_tasks.erase(free_tasks_and_before_pickup[work_assignment[i]]);

                agent_task[assigned_agent].task_id = assigned_task;
                agent_task[assigned_agent].min_task_dist = dist_matrix[i][work_assignment[i]];
                agent_task[assigned_agent].task_heuristic = cost_matrix[i][work_assignment[i]];
                agent_task[assigned_agent].assign_moment = env->curr_timestep; // assign task moment
                agent_task[assigned_agent].jam_when_assign = jam_matrix[i][work_assignment[i]];
                // cout << "jam when assign: " << agent_task[assigned_agent].jam_when_assign << endl;
            }
        }
    }

    /*
    cout << "work assignment: ";
    for(int i=0;i<work_assignment.size();i++)
    {
        cout << work_assignment[i] << " ";
    }
    cout << endl;
     */

     /*
     cout << "proposed schedule: ";
     for(int i=0;i<proposed_schedule.size();i++)
     {
         cout << proposed_schedule[i] << " ";
     }
     cout << endl;
      //*/

    cout << "Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
    // cout << "hungarian total distance: " << cost << endl; // 2087, 比默认方法确实缩小了
}

// 1.2.1: 将地图分成16x16的区域, task所在区域agent密度作为sum jam weight
void TaskScheduler::adaptive_jam_task_region_current_density(int time_limit, std::vector<int>& proposed_schedule)
{
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    if (free_agents.size() > 50)
    {
        if (first_epoch_done_time == -1)
        {
            // 由于大算例初始任务过多, 在初始任务分配完成前采用默认算法
            greedy_sum_without_newtask(time_limit, proposed_schedule);
            return;
        }
    }
    else
    {
        if (first_epoch_done_time == -1)
        {
            first_epoch_done_time = env->curr_timestep; // 初始阶段的任务分配完毕的时间
        }
    }

    small_region_wait_num.assign(small_region_wait_num.size(), 0); // 每次清空

    for (int i = 0; i < env->num_of_agents; i++)
    {
        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;

        int agent_region_x = agent_loc_x / small_region_column;
        int agent_region_y = agent_loc_y / small_region_row;

        small_region_wait_num[agent_region_y * num_small_region_column + agent_region_x]++;
    }

    /*
    cout << "region agent num: ";
    for(int i : small_region_wait_num)
    {
        cout << i << " ";
    }
    cout << endl;
     //*/

    if (env->num_of_agents <= 500) // 小算例直接算
    {
        for (int t_id : env->new_tasks)
        {
            int pickup_loc = env->task_pool[t_id].locations[0];
            int pickup_loc_x = pickup_loc % env->cols;
            int pickup_loc_y = pickup_loc / env->cols;

            int pickup_region_x = pickup_loc_x / small_region_column;
            int pickup_region_y = pickup_loc_y / small_region_row;

            task_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;
        }
    }
    else // 大算例
    {
        if (env->curr_timestep == first_epoch_done_time) // 在first_epoch_done_time计算完此时的free tasks
        {
            for (int t_id : free_tasks)
            {
                int pickup_loc = env->task_pool[t_id].locations[0];
                int pickup_loc_x = pickup_loc % env->cols;
                int pickup_loc_y = pickup_loc / env->cols;

                int pickup_region_x = pickup_loc_x / small_region_column;
                int pickup_region_y = pickup_loc_y / small_region_row;

                task_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;
            }
        }
        else // first_epoch_done_time之后就只计算新任务
        {
            for (int t_id : env->new_tasks)
            {
                int pickup_loc = env->task_pool[t_id].locations[0];
                int pickup_loc_x = pickup_loc % env->cols;
                int pickup_loc_y = pickup_loc / env->cols;

                int pickup_region_x = pickup_loc_x / small_region_column;
                int pickup_region_y = pickup_loc_y / small_region_row;

                task_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;
            }
        }
    }


    int min_task_i, dist, c_loc, count;
    clock_t start = clock();
    // cout << "small_region_wait_num size: " << small_region_wait_num.size() << endl;

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            // check for timeout every 10 task evaluations
            if (std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations) {
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            int pickup_loc = env->task_pool[t_id].locations[0];
            // double sum_jam_weight = (double) small_region_wait_num[task_region[t_id]] / small_region_blank_num[task_region[t_id]];
            double sum_jam_weight = (double)(small_region_wait_num[task_region[t_id]] + small_region_obstacle_num[task_region[t_id]]) / small_region_cell_num[task_region[t_id]];

            // cout << "task region " << task_region[t_id] << endl;
            // cout << "sum jam weight " << small_region_wait_num[task_region[t_id]] << " " << small_region_blank_num[task_region[t_id]] << endl;
            // cout << "sum jam weight: " << sum_jam_weight << endl;

            // sum_jam_weight * jam_coefficient = estimated delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic) {
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1) {
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
        // nothing to assign
        else {
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Task Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 1.2.2: 将地图分成16x16的区域, task所在区域agent密度 x agent-pickup距离作为sum jam weight
void TaskScheduler::adaptive_jam_task_region_current_density_times_agent_pickup(int time_limit, std::vector<int>& proposed_schedule)
{
    cout << "task region current density times distance" << endl;
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    if (free_agents.size() > 50)
    {
        if (first_epoch_done_time == -1)
        {
            // 由于大算例初始任务过多, 在初始任务分配完成前采用默认算法
            greedy_sum_without_newtask(time_limit, proposed_schedule);
            return;
        }
    }
    else
    {
        if (first_epoch_done_time == -1)
        {
            first_epoch_done_time = env->curr_timestep; // 初始阶段的任务分配完毕的时间
        }
    }

    small_region_wait_num.assign(small_region_wait_num.size(), 0); // 每次清空

    for (int i = 0; i < env->num_of_agents; i++)
    {
        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;

        int agent_region_x = agent_loc_x / small_region_column;
        int agent_region_y = agent_loc_y / small_region_row;

        small_region_wait_num[agent_region_y * num_small_region_column + agent_region_x]++;
    }

    /*
    cout << "region agent num: ";
    for(int i : small_region_wait_num)
    {
        cout << i << " ";
    }
    cout << endl;
     //*/

    if (env->num_of_agents <= 500) // 小算例直接算
    {
        for (int t_id : env->new_tasks)
        {
            int pickup_loc = env->task_pool[t_id].locations[0];
            int pickup_loc_x = pickup_loc % env->cols;
            int pickup_loc_y = pickup_loc / env->cols;

            int pickup_region_x = pickup_loc_x / small_region_column;
            int pickup_region_y = pickup_loc_y / small_region_row;

            task_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;
        }
    }
    else // 大算例
    {
        if (env->curr_timestep == first_epoch_done_time) // 在first_epoch_done_time计算完此时的free tasks
        {
            for (int t_id : free_tasks)
            {
                int pickup_loc = env->task_pool[t_id].locations[0];
                int pickup_loc_x = pickup_loc % env->cols;
                int pickup_loc_y = pickup_loc / env->cols;

                int pickup_region_x = pickup_loc_x / small_region_column;
                int pickup_region_y = pickup_loc_y / small_region_row;

                task_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;
            }
        }
        else // first_epoch_done_time之后就只计算新任务
        {
            for (int t_id : env->new_tasks)
            {
                int pickup_loc = env->task_pool[t_id].locations[0];
                int pickup_loc_x = pickup_loc % env->cols;
                int pickup_loc_y = pickup_loc / env->cols;

                int pickup_region_x = pickup_loc_x / small_region_column;
                int pickup_region_y = pickup_loc_y / small_region_row;

                task_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;
            }
        }
    }


    int min_task_i, dist, c_loc, count;
    clock_t start = clock();
    // cout << "small_region_wait_num size: " << small_region_wait_num.size() << endl;

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            // check for timeout every 10 task evaluations
            if (std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations) {
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            int curr_loc = env->curr_states.at(i).location;
            int pickup_loc = env->task_pool[t_id].locations[0];
            double pickup_agent_density = (double) small_region_wait_num[task_region[t_id]] / small_region_blank_num[task_region[t_id]];
            double sum_jam_weight = pickup_agent_density * DefaultPlanner::get_h(env, curr_loc, pickup_loc);
            // double sum_jam_weight = (double)(small_region_wait_num[task_region[t_id]] + small_region_obstacle_num[task_region[t_id]]) / small_region_cell_num[task_region[t_id]];

            // cout << "task region " << task_region[t_id] << endl;
            // cout << "sum jam weight " << small_region_wait_num[task_region[t_id]] << " " << small_region_blank_num[task_region[t_id]] << endl;
            // cout << "sum jam weight: " << sum_jam_weight << endl;

            // sum_jam_weight * jam_coefficient = estimated delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic) {
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1) {
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
        // nothing to assign
        else {
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Task Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 1.2.2.-1: 来不及算的就不算了
void TaskScheduler::adaptive_jam_task_region_current_density_times_agent_pickup_not_get(int time_limit, std::vector<int>& proposed_schedule)
{
    cout << "task region current density times distance not get" << endl;
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            /*
            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;
                */
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    if (free_agents.size() > 50)
    {
        if (first_epoch_done_time == -1)
        {
            // 由于大算例初始任务过多, 在初始任务分配完成前采用默认算法
            greedy_sum_without_newtask(time_limit, proposed_schedule);
            return;
        }
    }
    else
    {
        if (first_epoch_done_time == -1)
        {
            first_epoch_done_time = env->curr_timestep; // 初始阶段的任务分配完毕的时间
        }
    }

    small_region_wait_num.assign(small_region_wait_num.size(), 0); // 每次清空

    for (int i = 0; i < env->num_of_agents; i++)
    {
        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;

        int agent_region_x = agent_loc_x / small_region_column;
        int agent_region_y = agent_loc_y / small_region_row;

        small_region_wait_num[agent_region_y * num_small_region_column + agent_region_x]++;
    }

    /*
    cout << "region agent num: ";
    for(int i : small_region_wait_num)
    {
        cout << i << " ";
    }
    cout << endl;
     //*/

    if (env->num_of_agents <= 500) // 小算例直接算
    {
        for (int t_id : env->new_tasks)
        {
            int pickup_loc = env->task_pool[t_id].locations[0];
            int pickup_loc_x = pickup_loc % env->cols;
            int pickup_loc_y = pickup_loc / env->cols;

            int pickup_region_x = pickup_loc_x / small_region_column;
            int pickup_region_y = pickup_loc_y / small_region_row;

            task_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;
        }
    }
    else // 大算例
    {
        if (env->curr_timestep == first_epoch_done_time) // 在first_epoch_done_time计算完此时的free tasks
        {
            for (int t_id : free_tasks)
            {
                int pickup_loc = env->task_pool[t_id].locations[0];
                int pickup_loc_x = pickup_loc % env->cols;
                int pickup_loc_y = pickup_loc / env->cols;

                int pickup_region_x = pickup_loc_x / small_region_column;
                int pickup_region_y = pickup_loc_y / small_region_row;

                task_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;
            }
        }
        else // first_epoch_done_time之后就只计算新任务
        {
            for (int t_id : env->new_tasks)
            {
                int pickup_loc = env->task_pool[t_id].locations[0];
                int pickup_loc_x = pickup_loc % env->cols;
                int pickup_loc_y = pickup_loc / env->cols;

                int pickup_region_x = pickup_loc_x / small_region_column;
                int pickup_region_y = pickup_loc_y / small_region_row;

                task_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;
            }
        }
    }


    int min_task_i, dist, c_loc, count;
    clock_t start = clock();
    // cout << "small_region_wait_num size: " << small_region_wait_num.size() << endl;

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            // check for timeout every 10 task evaluations
            if (std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations) {
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            int curr_loc = env->curr_states.at(i).location;
            int pickup_loc = env->task_pool[t_id].locations[0];
            double pickup_agent_density = (double)small_region_wait_num[task_region[t_id]] / small_region_blank_num[task_region[t_id]];
            double sum_jam_weight = pickup_agent_density * DefaultPlanner::get_h(env, curr_loc, pickup_loc);
            // double sum_jam_weight = (double)(small_region_wait_num[task_region[t_id]] + small_region_obstacle_num[task_region[t_id]]) / small_region_cell_num[task_region[t_id]];

            // cout << "task region " << task_region[t_id] << endl;
            // cout << "sum jam weight " << small_region_wait_num[task_region[t_id]] << " " << small_region_blank_num[task_region[t_id]] << endl;
            // cout << "sum jam weight: " << sum_jam_weight << endl;

            // sum_jam_weight * jam_coefficient = estimated delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic) {
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1 && min_task_dist < 4995 - env->curr_timestep) 
        {
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
        // nothing to assign
        else {
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Task Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}


// 1.2.2.-1.1: 来不及做的任务就不算了+最小延迟
void TaskScheduler::adaptive_jam_task_region_current_density_times_agent_pickup_not_get_delay(int time_limit, std::vector<int>& proposed_schedule)
{
    cout << "task region current density times distance not get delay" << endl;
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            int delay = agent_task[element].complete_moment - agent_task[element].assign_moment - agent_task[element].min_task_dist;

            if (delay < min_delay)
            {
                min_delay = delay;
            }

            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
        cout << "min delay: " << min_delay << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    if (free_agents.size() > 50)
    {
        if (first_epoch_done_time == -1)
        {
            // 由于大算例初始任务过多, 在初始任务分配完成前采用默认算法
            greedy_sum_without_newtask(time_limit, proposed_schedule);
            return;
        }
    }
    else
    {
        if (first_epoch_done_time == -1)
        {
            first_epoch_done_time = env->curr_timestep; // 初始阶段的任务分配完毕的时间
        }
    }

    small_region_wait_num.assign(small_region_wait_num.size(), 0); // 每次清空

    for (int i = 0; i < env->num_of_agents; i++)
    {
        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;

        int agent_region_x = agent_loc_x / small_region_column;
        int agent_region_y = agent_loc_y / small_region_row;

        small_region_wait_num[agent_region_y * num_small_region_column + agent_region_x]++;
    }

    /*
    cout << "region agent num: ";
    for(int i : small_region_wait_num)
    {
        cout << i << " ";
    }
    cout << endl;
     //*/

    if (env->num_of_agents <= 500) // 小算例直接算
    {
        for (int t_id : env->new_tasks)
        {
            int pickup_loc = env->task_pool[t_id].locations[0];
            int pickup_loc_x = pickup_loc % env->cols;
            int pickup_loc_y = pickup_loc / env->cols;

            int pickup_region_x = pickup_loc_x / small_region_column;
            int pickup_region_y = pickup_loc_y / small_region_row;

            task_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;
        }
    }
    else // 大算例
    {
        if (env->curr_timestep == first_epoch_done_time) // 在first_epoch_done_time计算完此时的free tasks
        {
            for (int t_id : free_tasks)
            {
                int pickup_loc = env->task_pool[t_id].locations[0];
                int pickup_loc_x = pickup_loc % env->cols;
                int pickup_loc_y = pickup_loc / env->cols;

                int pickup_region_x = pickup_loc_x / small_region_column;
                int pickup_region_y = pickup_loc_y / small_region_row;

                task_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;
            }
        }
        else // first_epoch_done_time之后就只计算新任务
        {
            for (int t_id : env->new_tasks)
            {
                int pickup_loc = env->task_pool[t_id].locations[0];
                int pickup_loc_x = pickup_loc % env->cols;
                int pickup_loc_y = pickup_loc / env->cols;

                int pickup_region_x = pickup_loc_x / small_region_column;
                int pickup_region_y = pickup_loc_y / small_region_row;

                task_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;
            }
        }
    }


    int min_task_i, dist, c_loc, count;
    clock_t start = clock();
    // cout << "small_region_wait_num size: " << small_region_wait_num.size() << endl;

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            // check for timeout every 10 task evaluations
            if (std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations) {
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            int curr_loc = env->curr_states.at(i).location;
            int pickup_loc = env->task_pool[t_id].locations[0];
            double pickup_agent_density = (double)small_region_wait_num[task_region[t_id]] / small_region_blank_num[task_region[t_id]];
            double sum_jam_weight = pickup_agent_density * DefaultPlanner::get_h(env, curr_loc, pickup_loc);
            // double sum_jam_weight = (double)(small_region_wait_num[task_region[t_id]] + small_region_obstacle_num[task_region[t_id]]) / small_region_cell_num[task_region[t_id]];

            // cout << "task region " << task_region[t_id] << endl;
            // cout << "sum jam weight " << small_region_wait_num[task_region[t_id]] << " " << small_region_blank_num[task_region[t_id]] << endl;
            // cout << "sum jam weight: " << sum_jam_weight << endl;

            // sum_jam_weight * jam_coefficient = estimated delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic) {
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1 && min_task_dist + min_delay < 5000 - env->curr_timestep)
        {
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
        // nothing to assign
        else {
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Task Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}


// 1.2.2.0: 将地图分成16x16的区域, task所在区域agent密度 x agent-pickup距离作为sum jam weight
void TaskScheduler::adaptive_jam_task_region_current_density_times_agent_pickup_at_once(int time_limit, std::vector<int>& proposed_schedule)
{
    cout << "task region current density times agent pickup at once" << endl;
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // 在开始前一口气把新任务长度算完
    for (const int& new_task_id : env->new_tasks)
    {
        // this task distance has been calculated
        int total_dist = 0;
        int curr_loc = env->task_pool[new_task_id].locations[0];

        // iterate over the locations (errands) of the task to compute the makespan to finish the task
        // makespan: the time for the agent to complete all the errands of the task t_id in order
        for (int loc : env->task_pool[new_task_id].locations)
        {
            total_dist += DefaultPlanner::get_h(env, curr_loc, loc);
            curr_loc = loc;
        }

        task_distances[new_task_id] = total_dist;
        // cout << counter << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    if (free_agents.size() > 50)
    {
        if (first_epoch_done_time == -1)
        {
            // 由于大算例初始任务过多, 在初始任务分配完成前采用默认算法
            greedy_sum_at_once_without_newtask(time_limit, proposed_schedule);
            return;
        }
    }
    else
    {
        if (first_epoch_done_time == -1)
        {
            first_epoch_done_time = env->curr_timestep; // 初始阶段的任务分配完毕的时间
        }
    }

    small_region_wait_num.assign(small_region_wait_num.size(), 0); // 每次清空

    for (int i = 0; i < env->num_of_agents; i++)
    {
        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;

        int agent_region_x = agent_loc_x / small_region_column;
        int agent_region_y = agent_loc_y / small_region_row;

        small_region_wait_num[agent_region_y * num_small_region_column + agent_region_x]++;
    }

    /*
    cout << "region agent num: ";
    for(int i : small_region_wait_num)
    {
        cout << i << " ";
    }
    cout << endl;
     //*/

    if (env->num_of_agents <= 500) // 小算例直接算
    {
        for (int t_id : env->new_tasks)
        {
            int pickup_loc = env->task_pool[t_id].locations[0];
            int pickup_loc_x = pickup_loc % env->cols;
            int pickup_loc_y = pickup_loc / env->cols;

            int pickup_region_x = pickup_loc_x / small_region_column;
            int pickup_region_y = pickup_loc_y / small_region_row;

            task_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;
        }
    }
    else // 大算例
    {
        if (env->curr_timestep == first_epoch_done_time) // 在first_epoch_done_time计算完此时的free tasks
        {
            for (int t_id : free_tasks)
            {
                int pickup_loc = env->task_pool[t_id].locations[0];
                int pickup_loc_x = pickup_loc % env->cols;
                int pickup_loc_y = pickup_loc / env->cols;

                int pickup_region_x = pickup_loc_x / small_region_column;
                int pickup_region_y = pickup_loc_y / small_region_row;

                task_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;
            }
        }
        else // first_epoch_done_time之后就只计算新任务
        {
            for (int t_id : env->new_tasks)
            {
                int pickup_loc = env->task_pool[t_id].locations[0];
                int pickup_loc_x = pickup_loc % env->cols;
                int pickup_loc_y = pickup_loc / env->cols;

                int pickup_region_x = pickup_loc_x / small_region_column;
                int pickup_region_y = pickup_loc_y / small_region_row;

                task_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;
            }
        }
    }


    int min_task_i, dist, c_loc, count;
    clock_t start = clock();
    // cout << "small_region_wait_num size: " << small_region_wait_num.size() << endl;

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            // check for timeout every 10 task evaluations
            if (std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations) {
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                dist += task_distances[t_id];
                c_loc = loc;
                break;
            }

            int curr_loc = env->curr_states.at(i).location;
            int pickup_loc = env->task_pool[t_id].locations[0];
            double pickup_agent_density = (double)small_region_wait_num[task_region[t_id]] / small_region_blank_num[task_region[t_id]];
            double sum_jam_weight = pickup_agent_density * DefaultPlanner::get_h(env, curr_loc, pickup_loc);
            // double sum_jam_weight = (double)(small_region_wait_num[task_region[t_id]] + small_region_obstacle_num[task_region[t_id]]) / small_region_cell_num[task_region[t_id]];

            // cout << "task region " << task_region[t_id] << endl;
            // cout << "sum jam weight " << small_region_wait_num[task_region[t_id]] << " " << small_region_blank_num[task_region[t_id]] << endl;
            // cout << "sum jam weight: " << sum_jam_weight << endl;

            // sum_jam_weight * jam_coefficient = estimated delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic) {
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1) {
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
        // nothing to assign
        else {
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Task Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 1.2.2.2: 将地图分成16x16的区域, task所在区域agent密度 x agent-pickup距离作为sum jam weight
void TaskScheduler::adaptive_jam_task_region_current_density_times_agent_pickup_delivery(int time_limit, std::vector<int>& proposed_schedule)
{
    cout << "task region current density times agent pickup delivery" << endl;
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    if (free_agents.size() > 50)
    {
        if (first_epoch_done_time == -1)
        {
            // 由于大算例初始任务过多, 在初始任务分配完成前采用默认算法
            greedy_sum_without_newtask(time_limit, proposed_schedule);
            return;
        }
    }
    else
    {
        if (first_epoch_done_time == -1)
        {
            first_epoch_done_time = env->curr_timestep; // 初始阶段的任务分配完毕的时间
        }
    }

    small_region_wait_num.assign(small_region_wait_num.size(), 0); // 每次清空

    for (int i = 0; i < env->num_of_agents; i++)
    {
        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;

        int agent_region_x = agent_loc_x / small_region_column;
        int agent_region_y = agent_loc_y / small_region_row;

        small_region_wait_num[agent_region_y * num_small_region_column + agent_region_x]++;
    }

    /*
    cout << "region agent num: ";
    for(int i : small_region_wait_num)
    {
        cout << i << " ";
    }
    cout << endl;
     //*/

    if (env->num_of_agents <= 500) // 小算例直接算
    {
        for (int t_id : env->new_tasks)
        {
            int pickup_loc = env->task_pool[t_id].locations[0];
            int pickup_loc_x = pickup_loc % env->cols;
            int pickup_loc_y = pickup_loc / env->cols;

            int pickup_region_x = pickup_loc_x / small_region_column;
            int pickup_region_y = pickup_loc_y / small_region_row;

            task_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;
        }
    }
    else // 大算例
    {
        if (env->curr_timestep == first_epoch_done_time) // 在first_epoch_done_time计算完此时的free tasks
        {
            for (int t_id : free_tasks)
            {
                int pickup_loc = env->task_pool[t_id].locations[0];
                int pickup_loc_x = pickup_loc % env->cols;
                int pickup_loc_y = pickup_loc / env->cols;

                int pickup_region_x = pickup_loc_x / small_region_column;
                int pickup_region_y = pickup_loc_y / small_region_row;

                task_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;
            }
        }
        else // first_epoch_done_time之后就只计算新任务
        {
            for (int t_id : env->new_tasks)
            {
                int pickup_loc = env->task_pool[t_id].locations[0];
                int pickup_loc_x = pickup_loc % env->cols;
                int pickup_loc_y = pickup_loc / env->cols;

                int pickup_region_x = pickup_loc_x / small_region_column;
                int pickup_region_y = pickup_loc_y / small_region_row;

                task_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;
            }
        }
    }


    int min_task_i, dist, c_loc, count;
    clock_t start = clock();
    // cout << "small_region_wait_num size: " << small_region_wait_num.size() << endl;

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            // check for timeout every 10 task evaluations
            if (std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations) {
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            int curr_loc = env->curr_states.at(i).location;
            int pickup_loc = env->task_pool[t_id].locations[0];
            double pickup_agent_density = (double)small_region_wait_num[task_region[t_id]] / small_region_blank_num[task_region[t_id]];
            double sum_jam_weight = pickup_agent_density * dist;
            
            // cout << "task region " << task_region[t_id] << endl;
            // cout << "sum jam weight " << small_region_wait_num[task_region[t_id]] << " " << small_region_blank_num[task_region[t_id]] << endl;
            // cout << "sum jam weight: " << sum_jam_weight << endl;

            // sum_jam_weight * jam_coefficient = estimated delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic) {
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1) {
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
        // nothing to assign
        else {
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Task Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 1.2.3: 将地图分成16x16的区域, task所在区域时间平均agent密度作为sum jam weight
void TaskScheduler::adaptive_jam_task_region_all_time_average_density(int time_limit, std::vector<int>& proposed_schedule)
{
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    if (free_agents.size() > 50)
    {
        if (first_epoch_done_time == -1)
        {
            // 由于大算例初始任务过多, 在初始任务分配完成前采用默认算法
            greedy_sum_without_newtask(time_limit, proposed_schedule);
            return;
        }
    }
    else
    {
        if (first_epoch_done_time == -1)
        {
            first_epoch_done_time = env->curr_timestep; // 初始阶段的任务分配完毕的时间
        }
    }

    // 因为算的是历史平均, 所以这里不清零。
    // small_region_wait_num.assign(small_region_wait_num.size(), 0); // 每次清空

    for (int i = 0; i < env->num_of_agents; i++)
    {
        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;

        int agent_region_x = agent_loc_x / small_region_column;
        int agent_region_y = agent_loc_y / small_region_row;

        small_region_wait_num[agent_region_y * num_small_region_column + agent_region_x]++;
    }

    /*
    cout << "region agent num: ";
    for(int i : small_region_wait_num)
    {
        cout << i << " ";
    }
    cout << endl;
     //*/

    if (env->num_of_agents <= 500) // 小算例直接算
    {
        for (int t_id : env->new_tasks)
        {
            int pickup_loc = env->task_pool[t_id].locations[0];
            int pickup_loc_x = pickup_loc % env->cols;
            int pickup_loc_y = pickup_loc / env->cols;

            int pickup_region_x = pickup_loc_x / small_region_column;
            int pickup_region_y = pickup_loc_y / small_region_row;

            task_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;
        }
    }
    else // 大算例
    {
        if (env->curr_timestep == first_epoch_done_time) // 在first_epoch_done_time计算完此时的free tasks
        {
            for (int t_id : free_tasks)
            {
                int pickup_loc = env->task_pool[t_id].locations[0];
                int pickup_loc_x = pickup_loc % env->cols;
                int pickup_loc_y = pickup_loc / env->cols;

                int pickup_region_x = pickup_loc_x / small_region_column;
                int pickup_region_y = pickup_loc_y / small_region_row;

                task_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;
            }
        }
        else // first_epoch_done_time之后就只计算新任务
        {
            for (int t_id : env->new_tasks)
            {
                int pickup_loc = env->task_pool[t_id].locations[0];
                int pickup_loc_x = pickup_loc % env->cols;
                int pickup_loc_y = pickup_loc / env->cols;

                int pickup_region_x = pickup_loc_x / small_region_column;
                int pickup_region_y = pickup_loc_y / small_region_row;

                task_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;
            }
        }
    }


    int min_task_i, dist, c_loc, count;
    clock_t start = clock();
    // cout << "small_region_wait_num size: " << small_region_wait_num.size() << endl;

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            // check for timeout every 10 task evaluations
            if (std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations) {
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            int pickup_loc = env->task_pool[t_id].locations[0];
            double sum_jam_weight = (double) small_region_wait_num[task_region[t_id]] / (small_region_blank_num[task_region[t_id]] * env->curr_timestep + 1);            

            // cout << "task region " << task_region[t_id] << endl;
            // cout << "sum jam weight " << small_region_wait_num[task_region[t_id]] << " " << small_region_blank_num[task_region[t_id]] << endl;
            // cout << "sum jam weight: " << sum_jam_weight << endl;

            // sum_jam_weight * jam_coefficient = estimated delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic) {
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1) {
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
        // nothing to assign
        else {
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Task Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 1.2.4: 将地图分成12x12的区域, task所在区域时间窗平均agent密度作为sum jam weight
void TaskScheduler::adaptive_jam_task_region_time_window_density(int time_limit, std::vector<int>& proposed_schedule)
{
    cout << "adaptive jam task region time window density" << endl;
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    if (free_agents.size() > 50)
    {
        if (first_epoch_done_time == -1)
        {
            // 由于大算例初始任务过多, 在初始任务分配完成前采用默认算法
            greedy_sum_without_newtask(time_limit, proposed_schedule);
            return;
        }
    }
    else
    {
        if (first_epoch_done_time == -1)
        {
            first_epoch_done_time = env->curr_timestep; // 初始阶段的任务分配完毕的时间
        }
    }

    // 因为算的是历史平均, 所以这里不清零。
    // small_region_wait_num.assign(small_region_wait_num.size(), 0); // 每次清空
    // 在当前时间步, 每个region有多少个agent
    vector<int> current_region_agent_num(small_region_wait_num.size(), 0);

    for (int i = 0; i < env->num_of_agents; i++)
    {
        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;

        int agent_region_x = agent_loc_x / small_region_column;
        int agent_region_y = agent_loc_y / small_region_row;

        int agent_region_index = agent_region_y * num_small_region_column + agent_region_x;
        small_region_wait_num[agent_region_index]++;
        current_region_agent_num[agent_region_index]++;
    }

    auto removed_region_wait_num = period_small_region_wait_num.push(current_region_agent_num); // 添加元素，可能移除旧元素
    if (!removed_region_wait_num.empty())
    {
        // cout << "removed previous region agent num: ";
        for (int i=0;i< removed_region_wait_num.size();i++)
        {
            // cout << removed_small_region_wait_num[i] << " ";
            small_region_wait_num[i] -= removed_region_wait_num[i];
        }
        // cout << endl;
    }

    /*
    cout << "history total region agent num: ";
    for(int i : small_region_wait_num)
    {
        cout << i << " ";
    }
    cout << endl;
    cout << "current region agent num: ";
    for (int i : current_small_region_agent_num)
    {
        cout << i << " ";
    }
    cout << endl;
     //*/

    if (env->num_of_agents <= 500) // 小算例直接算
    {
        for (int t_id : env->new_tasks)
        {
            int pickup_loc = env->task_pool[t_id].locations[0];
            int pickup_loc_x = pickup_loc % env->cols;
            int pickup_loc_y = pickup_loc / env->cols;

            int pickup_region_x = pickup_loc_x / small_region_column;
            int pickup_region_y = pickup_loc_y / small_region_row;

            task_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;
        }
    }
    else // 大算例
    {
        if (env->curr_timestep == first_epoch_done_time) // 在first_epoch_done_time计算完此时的free tasks
        {
            for (int t_id : free_tasks)
            {
                int pickup_loc = env->task_pool[t_id].locations[0];
                int pickup_loc_x = pickup_loc % env->cols;
                int pickup_loc_y = pickup_loc / env->cols;

                int pickup_region_x = pickup_loc_x / small_region_column;
                int pickup_region_y = pickup_loc_y / small_region_row;

                task_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;
            }
        }
        else // first_epoch_done_time之后就只计算新任务
        {
            for (int t_id : env->new_tasks)
            {
                int pickup_loc = env->task_pool[t_id].locations[0];
                int pickup_loc_x = pickup_loc % env->cols;
                int pickup_loc_y = pickup_loc / env->cols;

                int pickup_region_x = pickup_loc_x / small_region_column;
                int pickup_region_y = pickup_loc_y / small_region_row;

                task_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;
            }
        }
    }


    int min_task_i, dist, c_loc, count;
    clock_t start = clock();
    // cout << "small_region_wait_num size: " << small_region_wait_num.size() << endl;

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            // check for timeout every 10 task evaluations
            if (std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations) {
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            int pickup_loc = env->task_pool[t_id].locations[0];
            double sum_jam_weight = (double)small_region_wait_num[task_region[t_id]] / (small_region_blank_num[task_region[t_id]] * period_small_region_wait_num.get_size() + 1);

            // cout << "task region " << task_region[t_id] << endl;
            // cout << "sum jam weight " << small_region_wait_num[task_region[t_id]] << " " << small_region_blank_num[task_region[t_id]] << endl;
            // cout << "sum jam weight: " << sum_jam_weight << endl;

            // sum_jam_weight * jam_coefficient = estimated delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic) {
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1) {
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
        // nothing to assign
        else {
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Task Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 1.2.4.1: 将地图分成12x12的区域, task所在区域时间窗平均agent密度作为sum jam weight
void TaskScheduler::adaptive_jam_task_region_time_window_density_times_agent_pickup(int time_limit, std::vector<int>& proposed_schedule)
{
    cout << "adaptive jam task region time window average density times agent pickup" << endl;
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    if (free_agents.size() > 50)
    {
        if (first_epoch_done_time == -1)
        {
            // 由于大算例初始任务过多, 在初始任务分配完成前采用默认算法
            greedy_sum_without_newtask(time_limit, proposed_schedule);
            return;
        }
    }
    else
    {
        if (first_epoch_done_time == -1)
        {
            first_epoch_done_time = env->curr_timestep; // 初始阶段的任务分配完毕的时间
        }
    }

    // 因为算的是历史平均, 所以这里不清零。
    // small_region_wait_num.assign(small_region_wait_num.size(), 0); // 每次清空
    // 在当前时间步, 每个region有多少个agent
    vector<int> current_region_agent_num(small_region_wait_num.size(), 0);

    for (int i = 0; i < env->num_of_agents; i++)
    {
        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;

        int agent_region_x = agent_loc_x / small_region_column;
        int agent_region_y = agent_loc_y / small_region_row;

        int agent_region_index = agent_region_y * num_small_region_column + agent_region_x;
        small_region_wait_num[agent_region_index]++;
        current_region_agent_num[agent_region_index]++;
    }

    auto removed_region_wait_num = period_small_region_wait_num.push(current_region_agent_num); // 添加元素，可能移除旧元素
    if (!removed_region_wait_num.empty())
    {
        // cout << "removed previous region agent num: ";
        for (int i = 0; i < removed_region_wait_num.size(); i++)
        {
            // cout << removed_small_region_wait_num[i] << " ";
            small_region_wait_num[i] -= removed_region_wait_num[i];
        }
        // cout << endl;
    }

    /*
    cout << "history total region agent num: ";
    for(int i : small_region_wait_num)
    {
        cout << i << " ";
    }
    cout << endl;
    cout << "current region agent num: ";
    for (int i : current_small_region_agent_num)
    {
        cout << i << " ";
    }
    cout << endl;
     //*/

    if (env->num_of_agents <= 500) // 小算例直接算
    {
        for (int t_id : env->new_tasks)
        {
            int pickup_loc = env->task_pool[t_id].locations[0];
            int pickup_loc_x = pickup_loc % env->cols;
            int pickup_loc_y = pickup_loc / env->cols;

            int pickup_region_x = pickup_loc_x / small_region_column;
            int pickup_region_y = pickup_loc_y / small_region_row;

            task_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;
        }
    }
    else // 大算例
    {
        if (env->curr_timestep == first_epoch_done_time) // 在first_epoch_done_time计算完此时的free tasks
        {
            for (int t_id : free_tasks)
            {
                int pickup_loc = env->task_pool[t_id].locations[0];
                int pickup_loc_x = pickup_loc % env->cols;
                int pickup_loc_y = pickup_loc / env->cols;

                int pickup_region_x = pickup_loc_x / small_region_column;
                int pickup_region_y = pickup_loc_y / small_region_row;

                task_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;
            }
        }
        else // first_epoch_done_time之后就只计算新任务
        {
            for (int t_id : env->new_tasks)
            {
                int pickup_loc = env->task_pool[t_id].locations[0];
                int pickup_loc_x = pickup_loc % env->cols;
                int pickup_loc_y = pickup_loc / env->cols;

                int pickup_region_x = pickup_loc_x / small_region_column;
                int pickup_region_y = pickup_loc_y / small_region_row;

                task_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;
            }
        }
    }


    int min_task_i, dist, c_loc, count;
    clock_t start = clock();
    // cout << "small_region_wait_num size: " << small_region_wait_num.size() << endl;

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            // check for timeout every 10 task evaluations
            if (std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations) {
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            int curr_loc = env->curr_states.at(i).location;
            int pickup_loc = env->task_pool[t_id].locations[0];
            double time_average_density = (double)small_region_wait_num[task_region[t_id]] / (small_region_blank_num[task_region[t_id]] * period_small_region_wait_num.get_size() + 1);
            double sum_jam_weight = time_average_density * DefaultPlanner::get_h(env, curr_loc, pickup_loc);

            // cout << "task region " << task_region[t_id] << endl;
            // cout << "sum jam weight " << small_region_wait_num[task_region[t_id]] << " " << small_region_blank_num[task_region[t_id]] << endl;
            // cout << "sum jam weight: " << sum_jam_weight << endl;

            // sum_jam_weight * jam_coefficient = estimated delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic) {
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1) {
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
        // nothing to assign
        else {
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Task Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 1.2.4.2.0: 将地图进行12x12和32x32两次划分, task所在两次划分的agent数量加权和作为sum jam weight
void TaskScheduler::adaptive_jam_pickup_region_large_small_partition_count(int time_limit, std::vector<int>& proposed_schedule)
{
    cout << "adaptive jam task region large small partition count" << endl;
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    if (free_agents.size() > 50)
    {
        if (first_epoch_done_time == -1)
        {
            // 由于大算例初始任务过多, 在初始任务分配完成前采用默认算法
            greedy_sum_without_newtask(time_limit, proposed_schedule);
            return;
        }
    }
    else
    {
        if (first_epoch_done_time == -1)
        {
            first_epoch_done_time = env->curr_timestep; // 初始阶段的任务分配完毕的时间
        }
    }

    // Step 1: 统计每个区域agent的数量。
    // small_region_wait_num.assign(small_region_wait_num.size(), 0); // 每次清空
    // 在当前时间步, 每个region有多少个agent
    vector<int> current_large_region_agent_num(small_region_wait_num.size(), 0);
    vector<int> current_small_region_agent_num(num_large_region_column * num_large_region_row, 0);

    for (int i = 0; i < env->num_of_agents; i++)
    {
        // time window large region num
        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;

        int agent_region_x = agent_loc_x / small_region_column;
        int agent_region_y = agent_loc_y / small_region_row;

        int agent_region_index = agent_region_y * num_small_region_column + agent_region_x;
        current_large_region_agent_num[agent_region_index]++;

        // current small region num
        int agent_small_region_x = agent_loc_x / large_region_column;
        int agent_small_region_y = agent_loc_y / large_region_row;

        int agent_small_region_index = agent_small_region_y * num_large_region_column + agent_small_region_x;
        current_small_region_agent_num[agent_small_region_index]++;
    }

    /*
    cout << "current large region agent num: ";
    for(int i : current_large_region_agent_num)
    {
        cout << i << " ";
    }
    cout << endl;
    cout << "current small region agent num: ";
    for (int i : current_small_region_agent_num)
    {
        cout << i << " ";
    }
    cout << endl;
     //*/

    // Step 2: 计算每个task归属于哪个区域。
    if (env->curr_timestep == first_epoch_done_time) // 在first_epoch_done_time计算完此时的free tasks
    {
        for (int t_id : free_tasks)
        {
            int pickup_loc = env->task_pool[t_id].locations[0];
            int pickup_loc_x = pickup_loc % env->cols;
            int pickup_loc_y = pickup_loc / env->cols;

            // history (large) region
            int pickup_region_x = pickup_loc_x / small_region_column;
            int pickup_region_y = pickup_loc_y / small_region_row;

            task_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x; // large

            // current (small) region
            int current_pickup_region_x = pickup_loc_x / large_region_column;
            int current_pickup_region_y = pickup_loc_y / large_region_row;

            task_current_region[t_id] = current_pickup_region_y * num_large_region_column + current_pickup_region_x;
        }
    }
    else // first_epoch_done_time之后就只计算新任务
    {
        for (int t_id : env->new_tasks)
        {
            int pickup_loc = env->task_pool[t_id].locations[0];
            int pickup_loc_x = pickup_loc % env->cols;
            int pickup_loc_y = pickup_loc / env->cols;

            // history (large) region
            int pickup_region_x = pickup_loc_x / small_region_column;
            int pickup_region_y = pickup_loc_y / small_region_row;

            task_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x; // large

            // current (small) region
            int current_pickup_region_x = pickup_loc_x / large_region_column;
            int current_pickup_region_y = pickup_loc_y / large_region_row;

            task_current_region[t_id] = current_pickup_region_y * num_large_region_column + current_pickup_region_x;
        }
    }

    // 遍历并输出task所在region
    /*
    for (const auto& pair : task_region) 
    {
        std::cout << "Task ID: " << pair.first << " -> large Regions: " << pair.second << endl;
    }

    for (const auto& pair : task_current_region)
    {
        std::cout << "Task ID: " << pair.first << " -> small Regions: " << pair.second << endl;
    }
    //*/

    int min_task_i, dist, c_loc, count;
    clock_t start = clock();
    // cout << "small_region_wait_num size: " << small_region_wait_num.size() << endl;

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            // check for timeout every 10 task evaluations
            if (std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations) {
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            int pickup_loc = env->task_pool[t_id].locations[0];
            int large_agent_count = current_large_region_agent_num[task_region[t_id]];
            int small_agent_count = current_small_region_agent_num[task_current_region[t_id]];

            // cout << "task region " << task_region[t_id] << endl;
            // cout << "sum jam weight " << small_region_wait_num[task_region[t_id]] << " " << small_region_blank_num[task_region[t_id]] << endl;
            // cout << "large agent count: " << large_agent_count << endl;
            // cout << "small agent count: " << small_agent_count << endl;
            double short_term_ratio = 0.9;
            double sum_jam_weight = small_agent_count * short_term_ratio + large_agent_count * (1 - short_term_ratio);
            // cout << "sum jam weight: " << sum_jam_weight << endl;

            // sum_jam_weight * jam_coefficient = estimated delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic) {
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1) {
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
        // nothing to assign
        else {
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Task Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 1.2.4.2: 将地图分成12x12的区域, task所在区域长短时平均agent数量之和作为sum jam weight
void TaskScheduler::adaptive_jam_task_region_long_short_term_count(int time_limit, std::vector<int>& proposed_schedule)
{
    cout << "adaptive jam task region long short term count" << endl;
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    if (free_agents.size() > 50)
    {
        if (first_epoch_done_time == -1)
        {
            // 由于大算例初始任务过多, 在初始任务分配完成前采用默认算法
            greedy_sum_without_newtask(time_limit, proposed_schedule);
            return;
        }
    }
    else
    {
        if (first_epoch_done_time == -1)
        {
            first_epoch_done_time = env->curr_timestep; // 初始阶段的任务分配完毕的时间
        }
    }

    // 因为算的是历史平均, 所以这里不清零。
    // small_region_wait_num.assign(small_region_wait_num.size(), 0); // 每次清空
    // 在当前时间步, 每个region有多少个agent
    vector<int> current_region_agent_num(small_region_wait_num.size(), 0);

    for (int i = 0; i < env->num_of_agents; i++)
    {
        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;

        int agent_region_x = agent_loc_x / small_region_column;
        int agent_region_y = agent_loc_y / small_region_row;

        int agent_region_index = agent_region_y * num_small_region_column + agent_region_x;
        small_region_wait_num[agent_region_index]++;
        current_region_agent_num[agent_region_index]++;
    }

    auto removed_region_wait_num = period_small_region_wait_num.push(current_region_agent_num); // 添加元素，可能移除旧元素
    if (!removed_region_wait_num.empty())
    {
        // cout << "removed previous region agent num: ";
        for (int i = 0; i < removed_region_wait_num.size(); i++)
        {
            // cout << removed_small_region_wait_num[i] << " ";
            small_region_wait_num[i] -= removed_region_wait_num[i];
        }
        // cout << endl;
    }

    /*
    cout << "history total region agent num: ";
    for(int i : small_region_wait_num)
    {
        cout << i << " ";
    }
    cout << endl;
    cout << "current region agent num: ";
    for (int i : current_small_region_agent_num)
    {
        cout << i << " ";
    }
    cout << endl;
     //*/

    if (env->num_of_agents <= 500) // 小算例直接算
    {
        for (int t_id : env->new_tasks)
        {
            int pickup_loc = env->task_pool[t_id].locations[0];
            int pickup_loc_x = pickup_loc % env->cols;
            int pickup_loc_y = pickup_loc / env->cols;

            int pickup_region_x = pickup_loc_x / small_region_column;
            int pickup_region_y = pickup_loc_y / small_region_row;

            task_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;
        }
    }
    else // 大算例
    {
        if (env->curr_timestep == first_epoch_done_time) // 在first_epoch_done_time计算完此时的free tasks
        {
            for (int t_id : free_tasks)
            {
                int pickup_loc = env->task_pool[t_id].locations[0];
                int pickup_loc_x = pickup_loc % env->cols;
                int pickup_loc_y = pickup_loc / env->cols;

                int pickup_region_x = pickup_loc_x / small_region_column;
                int pickup_region_y = pickup_loc_y / small_region_row;

                task_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;
            }
        }
        else // first_epoch_done_time之后就只计算新任务
        {
            for (int t_id : env->new_tasks)
            {
                int pickup_loc = env->task_pool[t_id].locations[0];
                int pickup_loc_x = pickup_loc % env->cols;
                int pickup_loc_y = pickup_loc / env->cols;

                int pickup_region_x = pickup_loc_x / small_region_column;
                int pickup_region_y = pickup_loc_y / small_region_row;

                task_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;
            }
        }
    }


    int min_task_i, dist, c_loc, count;
    clock_t start = clock();
    // cout << "small_region_wait_num size: " << small_region_wait_num.size() << endl;

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            // check for timeout every 10 task evaluations
            if (std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations) {
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            // int pickup_loc = env->task_pool[t_id].locations[0];
            double long_term_count = (double)small_region_wait_num[task_region[t_id]] / (period_small_region_wait_num.get_size() + 1);
            int short_term_count = current_region_agent_num[task_region[t_id]];

            // cout << "task region " << task_region[t_id] << endl;
            // cout << "sum jam weight " << small_region_wait_num[task_region[t_id]] << " " << small_region_blank_num[task_region[t_id]] << endl;
            // cout << "long term density: " << long_term_density << endl;
            // cout << "short term density: " << short_term_density << endl;
            int short_term_ratio = 0.7;
            double sum_jam_weight = short_term_count * short_term_ratio + long_term_count * (1 - short_term_ratio);

            // sum_jam_weight * jam_coefficient = estimated delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic) {
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1) {
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
        // nothing to assign
        else {
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Task Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 1.2.4.3: 将地图分成12x12的区域, task所在区域长短时平均agent密度作为sum jam weight
void TaskScheduler::adaptive_jam_task_region_long_short_term_density(int time_limit, std::vector<int>& proposed_schedule)
{
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    if (free_agents.size() > 50)
    {
        if (first_epoch_done_time == -1)
        {
            // 由于大算例初始任务过多, 在初始任务分配完成前采用默认算法
            greedy_sum_without_newtask(time_limit, proposed_schedule);
            return;
        }
    }
    else
    {
        if (first_epoch_done_time == -1)
        {
            first_epoch_done_time = env->curr_timestep; // 初始阶段的任务分配完毕的时间
        }
    }

    // 因为算的是历史平均, 所以这里不清零。
    // small_region_wait_num.assign(small_region_wait_num.size(), 0); // 每次清空
    // 在当前时间步, 每个region有多少个agent
    vector<int> current_region_agent_num(small_region_wait_num.size(), 0);

    for (int i = 0; i < env->num_of_agents; i++)
    {
        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;

        int agent_region_x = agent_loc_x / small_region_column;
        int agent_region_y = agent_loc_y / small_region_row;

        int agent_region_index = agent_region_y * num_small_region_column + agent_region_x;
        small_region_wait_num[agent_region_index]++;
        current_region_agent_num[agent_region_index]++;
    }

    auto removed_region_wait_num = period_small_region_wait_num.push(current_region_agent_num); // 添加元素，可能移除旧元素
    if (!removed_region_wait_num.empty())
    {
        // cout << "removed previous region agent num: ";
        for (int i = 0; i < removed_region_wait_num.size(); i++)
        {
            // cout << removed_small_region_wait_num[i] << " ";
            small_region_wait_num[i] -= removed_region_wait_num[i];
        }
        // cout << endl;
    }

    /*
    cout << "history total region agent num: ";
    for(int i : small_region_wait_num)
    {
        cout << i << " ";
    }
    cout << endl;
    cout << "current region agent num: ";
    for (int i : current_small_region_agent_num)
    {
        cout << i << " ";
    }
    cout << endl;
     //*/

    if (env->num_of_agents <= 500) // 小算例直接算
    {
        for (int t_id : env->new_tasks)
        {
            int pickup_loc = env->task_pool[t_id].locations[0];
            int pickup_loc_x = pickup_loc % env->cols;
            int pickup_loc_y = pickup_loc / env->cols;

            int pickup_region_x = pickup_loc_x / small_region_column;
            int pickup_region_y = pickup_loc_y / small_region_row;

            task_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;
        }
    }
    else // 大算例
    {
        if (env->curr_timestep == first_epoch_done_time) // 在first_epoch_done_time计算完此时的free tasks
        {
            for (int t_id : free_tasks)
            {
                int pickup_loc = env->task_pool[t_id].locations[0];
                int pickup_loc_x = pickup_loc % env->cols;
                int pickup_loc_y = pickup_loc / env->cols;

                int pickup_region_x = pickup_loc_x / small_region_column;
                int pickup_region_y = pickup_loc_y / small_region_row;

                task_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;
            }
        }
        else // first_epoch_done_time之后就只计算新任务
        {
            for (int t_id : env->new_tasks)
            {
                int pickup_loc = env->task_pool[t_id].locations[0];
                int pickup_loc_x = pickup_loc % env->cols;
                int pickup_loc_y = pickup_loc / env->cols;

                int pickup_region_x = pickup_loc_x / small_region_column;
                int pickup_region_y = pickup_loc_y / small_region_row;

                task_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;
            }
        }
    }


    int min_task_i, dist, c_loc, count;
    clock_t start = clock();
    // cout << "small_region_wait_num size: " << small_region_wait_num.size() << endl;

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            // check for timeout every 10 task evaluations
            if (std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations) {
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            int pickup_loc = env->task_pool[t_id].locations[0];
            double long_term_density = (double)small_region_wait_num[task_region[t_id]] / (small_region_blank_num[task_region[t_id]] * period_small_region_wait_num.get_size() + 1);
            double short_term_density = (double)current_region_agent_num[task_region[t_id]] / small_region_blank_num[task_region[t_id]];
            
            // cout << "task region " << task_region[t_id] << endl;
            // cout << "sum jam weight " << small_region_wait_num[task_region[t_id]] << " " << small_region_blank_num[task_region[t_id]] << endl;
            // cout << "long term density: " << long_term_density << endl;
            // cout << "short term density: " << short_term_density << endl;
            int short_term_ratio = 0.7;
            double sum_jam_weight = short_term_density * short_term_ratio + long_term_density * (1 - short_term_ratio);

            // sum_jam_weight * jam_coefficient = estimated delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic) {
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1) {
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
        // nothing to assign
        else {
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Task Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 1.2.4.4: 将地图分成12x12的区域, task所在区域长短时平均agent密度 x |agent-pickup|作为sum jam weight
void TaskScheduler::adaptive_jam_task_region_long_short_term_density_times_agent_pickup(int time_limit, std::vector<int>& proposed_schedule)
{
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    if (free_agents.size() > 50)
    {
        if (first_epoch_done_time == -1)
        {
            // 由于大算例初始任务过多, 在初始任务分配完成前采用默认算法
            greedy_sum_without_newtask(time_limit, proposed_schedule);
            return;
        }
    }
    else
    {
        if (first_epoch_done_time == -1)
        {
            first_epoch_done_time = env->curr_timestep; // 初始阶段的任务分配完毕的时间
        }
    }

    // 因为算的是历史平均, 所以这里不清零。
    // small_region_wait_num.assign(small_region_wait_num.size(), 0); // 每次清空
    // 在当前时间步, 每个region有多少个agent
    vector<int> current_region_agent_num(small_region_wait_num.size(), 0);

    for (int i = 0; i < env->num_of_agents; i++)
    {
        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;

        int agent_region_x = agent_loc_x / small_region_column;
        int agent_region_y = agent_loc_y / small_region_row;

        int agent_region_index = agent_region_y * num_small_region_column + agent_region_x;
        small_region_wait_num[agent_region_index]++;
        current_region_agent_num[agent_region_index]++;
    }

    auto removed_region_wait_num = period_small_region_wait_num.push(current_region_agent_num); // 添加元素，可能移除旧元素
    if (!removed_region_wait_num.empty())
    {
        // cout << "removed previous region agent num: ";
        for (int i = 0; i < removed_region_wait_num.size(); i++)
        {
            // cout << removed_small_region_wait_num[i] << " ";
            small_region_wait_num[i] -= removed_region_wait_num[i];
        }
        // cout << endl;
    }

    /*
    cout << "history total region agent num: ";
    for(int i : small_region_wait_num)
    {
        cout << i << " ";
    }
    cout << endl;
    cout << "current region agent num: ";
    for (int i : current_small_region_agent_num)
    {
        cout << i << " ";
    }
    cout << endl;
     //*/

    if (env->num_of_agents <= 500) // 小算例直接算
    {
        for (int t_id : env->new_tasks)
        {
            int pickup_loc = env->task_pool[t_id].locations[0];
            int pickup_loc_x = pickup_loc % env->cols;
            int pickup_loc_y = pickup_loc / env->cols;

            int pickup_region_x = pickup_loc_x / small_region_column;
            int pickup_region_y = pickup_loc_y / small_region_row;

            task_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;
        }
    }
    else // 大算例
    {
        if (env->curr_timestep == first_epoch_done_time) // 在first_epoch_done_time计算完此时的free tasks
        {
            for (int t_id : free_tasks)
            {
                int pickup_loc = env->task_pool[t_id].locations[0];
                int pickup_loc_x = pickup_loc % env->cols;
                int pickup_loc_y = pickup_loc / env->cols;

                int pickup_region_x = pickup_loc_x / small_region_column;
                int pickup_region_y = pickup_loc_y / small_region_row;

                task_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;
            }
        }
        else // first_epoch_done_time之后就只计算新任务
        {
            for (int t_id : env->new_tasks)
            {
                int pickup_loc = env->task_pool[t_id].locations[0];
                int pickup_loc_x = pickup_loc % env->cols;
                int pickup_loc_y = pickup_loc / env->cols;

                int pickup_region_x = pickup_loc_x / small_region_column;
                int pickup_region_y = pickup_loc_y / small_region_row;

                task_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;
            }
        }
    }


    int min_task_i, dist, c_loc, count;
    clock_t start = clock();
    // cout << "small_region_wait_num size: " << small_region_wait_num.size() << endl;

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            // check for timeout every 10 task evaluations
            if (std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations) {
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            int curr_loc = env->curr_states.at(i).location;
            int pickup_loc = env->task_pool[t_id].locations[0];
            double long_term_density = (double)small_region_wait_num[task_region[t_id]] / (small_region_blank_num[task_region[t_id]] * period_small_region_wait_num.get_size() + 1);
            double short_term_density = (double)current_region_agent_num[task_region[t_id]] / small_region_blank_num[task_region[t_id]];

            // cout << "task region " << task_region[t_id] << endl;
            // cout << "sum jam weight " << small_region_wait_num[task_region[t_id]] << " " << small_region_blank_num[task_region[t_id]] << endl;
            // cout << "long term density: " << long_term_density << endl;
            // cout << "short term density: " << short_term_density << endl;
            int short_term_ratio = 0.7;
            double pickup_agent_density = short_term_density * short_term_ratio + long_term_density * (1 - short_term_ratio);
            double sum_jam_weight = pickup_agent_density * DefaultPlanner::get_h(env, curr_loc, pickup_loc);

            // sum_jam_weight * jam_coefficient = estimated delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic) {
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1) {
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
        // nothing to assign
        else {
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Task Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 1.2.4.5: 将地图分成12x12的区域, task所在区域历史大面积现在小面积平均agent密度作为sum jam weight
void TaskScheduler::adaptive_jam_pickup_region_long_large_short_small_density(int time_limit, std::vector<int>& proposed_schedule)
{
    cout << "adaptive jam task region long large short small density" << endl;
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    if (free_agents.size() > 50)
    {
        if (first_epoch_done_time == -1)
        {
            // 由于大算例初始任务过多, 在初始任务分配完成前采用默认算法
            greedy_sum_without_newtask(time_limit, proposed_schedule);
            return;
        }
    }
    else
    {
        if (first_epoch_done_time == -1)
        {
            first_epoch_done_time = env->curr_timestep; // 初始阶段的任务分配完毕的时间
        }
    }

    // 因为算的是历史平均, 所以这里不清零。
    // small_region_wait_num.assign(small_region_wait_num.size(), 0); // 每次清空
    // 在当前时间步, 每个region有多少个agent
    vector<int> current_large_region_agent_num(small_region_wait_num.size(), 0);
    vector<int> current_small_region_agent_num(num_large_region_column * num_large_region_row, 0);

    for (int i = 0; i < env->num_of_agents; i++)
    {
        // time window large region num
        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;

        int agent_region_x = agent_loc_x / small_region_column;
        int agent_region_y = agent_loc_y / small_region_row;

        int agent_region_index = agent_region_y * num_small_region_column + agent_region_x;
        small_region_wait_num[agent_region_index]++;
        current_large_region_agent_num[agent_region_index]++;

        // current small region num
        int agent_small_region_x = agent_loc_x / large_region_column;
        int agent_small_region_y = agent_loc_y / large_region_row;

        int agent_small_region_index = agent_small_region_y * num_large_region_column + agent_small_region_x;
        current_small_region_agent_num[agent_small_region_index]++;
    }

    auto removed_region_wait_num = period_small_region_wait_num.push(current_large_region_agent_num); // 添加元素，可能移除旧元素
    if (!removed_region_wait_num.empty())
    {
        // cout << "removed previous region agent num: ";
        for (int i = 0; i < removed_region_wait_num.size(); i++)
        {
            // cout << removed_small_region_wait_num[i] << " ";
            small_region_wait_num[i] -= removed_region_wait_num[i];
        }
        // cout << endl;
    }

    /*
    cout << "history total region agent num: ";
    for(int i : small_region_wait_num)
    {
        cout << i << " ";
    }
    cout << endl;
    cout << "current region agent num: ";
    for (int i : current_large_region_agent_num)
    {
        cout << i << " ";
    }
    cout << endl;
     //*/

    if (env->num_of_agents <= 500) // 小算例直接算
    {
        for (int t_id : env->new_tasks)
        {
            int pickup_loc = env->task_pool[t_id].locations[0];
            int pickup_loc_x = pickup_loc % env->cols;
            int pickup_loc_y = pickup_loc / env->cols;

            int pickup_region_x = pickup_loc_x / small_region_column;
            int pickup_region_y = pickup_loc_y / small_region_row;

            task_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;

            // current region
            int current_pickup_region_x = pickup_loc_x / large_region_column;
            int current_pickup_region_y = pickup_loc_y / large_region_row;

            task_current_region[t_id] = current_pickup_region_y * num_large_region_column + current_pickup_region_x;
        }
    }
    else // 大算例
    {
        if (env->curr_timestep == first_epoch_done_time) // 在first_epoch_done_time计算完此时的free tasks
        {
            for (int t_id : free_tasks)
            {
                int pickup_loc = env->task_pool[t_id].locations[0];
                int pickup_loc_x = pickup_loc % env->cols;
                int pickup_loc_y = pickup_loc / env->cols;

                int pickup_region_x = pickup_loc_x / small_region_column;
                int pickup_region_y = pickup_loc_y / small_region_row;

                task_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;

                // current region
                int current_pickup_region_x = pickup_loc_x / large_region_column;
                int current_pickup_region_y = pickup_loc_y / large_region_row;

                task_current_region[t_id] = current_pickup_region_y * num_large_region_column + current_pickup_region_x;
            }
        }
        else // first_epoch_done_time之后就只计算新任务
        {
            for (int t_id : env->new_tasks)
            {
                int pickup_loc = env->task_pool[t_id].locations[0];
                int pickup_loc_x = pickup_loc % env->cols;
                int pickup_loc_y = pickup_loc / env->cols;

                int pickup_region_x = pickup_loc_x / small_region_column;
                int pickup_region_y = pickup_loc_y / small_region_row;

                task_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;

                // current region
                int current_pickup_region_x = pickup_loc_x / large_region_column;
                int current_pickup_region_y = pickup_loc_y / large_region_row;

                task_current_region[t_id] = current_pickup_region_y * num_large_region_column + current_pickup_region_x;
            }
        }
    }


    int min_task_i, dist, c_loc, count;
    clock_t start = clock();
    // cout << "small_region_wait_num size: " << small_region_wait_num.size() << endl;

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            // check for timeout every 10 task evaluations
            if (std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations) {
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            int pickup_loc = env->task_pool[t_id].locations[0];
            double long_term_density = (double)small_region_wait_num[task_region[t_id]] / (small_region_blank_num[task_region[t_id]] * period_small_region_wait_num.get_size() + 1);
            double short_term_density = (double)current_small_region_agent_num[task_current_region[t_id]] / large_region_blank_num[task_current_region[t_id]];

            // cout << "task region " << task_region[t_id] << endl;
            // cout << "sum jam weight " << small_region_wait_num[task_region[t_id]] << " " << small_region_blank_num[task_region[t_id]] << endl;
            // cout << "long term density: " << long_term_density << endl;
            // cout << "short term density: " << short_term_density << endl;
            int short_term_ratio = 0.7;
            double sum_jam_weight = short_term_density * short_term_ratio + long_term_density * (1 - short_term_ratio);

            // sum_jam_weight * jam_coefficient = estimated delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic) {
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1) {
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
        // nothing to assign
        else {
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Task Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 1.2.5: 将地图分成12x12的区域, agent-pickup经过区域中agent的数量之和作为sum jam weight
void TaskScheduler::adaptive_jam_agent_pickup_crossed_region_count_current(int time_limit, std::vector<int>& proposed_schedule)
{
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    if (env->num_of_agents > 500 && free_agents.size() > 50)
    {
        if (first_epoch_done_time == -1)
        {
            // 由于大算例初始任务过多, 在初始任务分配完成前采用默认算法
            greedy_sum_without_newtask(time_limit, proposed_schedule);
            return;
        }
    }
    else
    {
        if (first_epoch_done_time == -1)
        {
            first_epoch_done_time = env->curr_timestep; // 初始阶段的任务分配完毕的时间
        }
    }

    // 将map分为若干区域, 统计每个区域agent的数量
    vector<int> region_agent_num(num_small_region_column * num_small_region_row, 0);

    for (int i = 0; i < env->num_of_agents; i++)
    {
        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;

        int agent_region_x = agent_loc_x / small_region_column;
        int agent_region_y = agent_loc_y / small_region_row;

        region_agent_num[agent_region_y * num_small_region_column + agent_region_x]++;
    }

    /*
    cout << "region agent num: ";
    for(int i : region_agent_num)
    {
        cout << i << " ";
    }
    cout << endl;
     //*/

    if (env->num_of_agents <= 500) // 小算例直接算
    {
        for (int t_id : env->new_tasks)
        {
            int pickup_loc = env->task_pool[t_id].locations[0];
            int pickup_loc_x = pickup_loc % env->cols;
            int pickup_loc_y = pickup_loc / env->cols;

            int pickup_region_x = pickup_loc_x / small_region_column;
            int pickup_region_y = pickup_loc_y / small_region_row;

            task_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;
        }
    }
    else // 大算例
    {
        if (env->curr_timestep == first_epoch_done_time) // 在first_epoch_done_time计算完此时的free tasks
        {
            for (int t_id : free_tasks)
            {
                int pickup_loc = env->task_pool[t_id].locations[0];
                int pickup_loc_x = pickup_loc % env->cols;
                int pickup_loc_y = pickup_loc / env->cols;

                int pickup_region_x = pickup_loc_x / small_region_column;
                int pickup_region_y = pickup_loc_y / small_region_row;

                task_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;
            }
        }
        else // first_epoch_done_time之后就只计算新任务
        {
            for (int t_id : env->new_tasks)
            {
                int pickup_loc = env->task_pool[t_id].locations[0];
                int pickup_loc_x = pickup_loc % env->cols;
                int pickup_loc_y = pickup_loc / env->cols;

                int pickup_region_x = pickup_loc_x / small_region_column;
                int pickup_region_y = pickup_loc_y / small_region_row;

                task_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;
            }
        }
    }

    // cout << 5036 << endl;

    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            // check for timeout every 10 task evaluations
            if (std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations) {
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            // cout << "from " << env->curr_states.at(i).location << " to " << env->task_pool[t_id].locations[0] << endl;

            int temp_start = env->curr_states.at(i).location;
            int temp_goal = env->task_pool[t_id].locations[0];

            // cout << "temp start " << temp_start << endl;
            // cout << "temp goal " << temp_goal << endl;

            // 获取连线经过的单元格
            vector<Point> crossed_cells = get_line_crossed_cell(temp_start, temp_goal);

            // 计算经过的区域
            vector<int> crossed_regions = get_line_crossed_regions(crossed_cells);

            /*
            std::cout << "To pickup crossed regions: ";
            for (int r : crossed_regions) {
                std::cout << r << " "; 
            }
            std::cout << std::endl;
            //*/            

            /*
            int curr_loc_x = temp_start % env->cols;
            int curr_loc_y = temp_goal / env->cols;

            int curr_region_x = curr_loc_x / small_region_column;
            int curr_region_y = curr_loc_y / small_region_row;

            auto verified_curr_region = curr_region_y * num_small_region_column + curr_region_x;

            cout << "verified start region: " << verified_curr_region << endl;

            int pickup_loc_x = temp_goal % env->cols;
            int pickup_loc_y = temp_goal / env->cols;

            int pickup_region_x = pickup_loc_x / small_region_column;
            int pickup_region_y = pickup_loc_y / small_region_row;

            auto verified_pickup_region = pickup_region_y * num_small_region_column + pickup_region_x;

            cout << "verified pickup region: " << verified_pickup_region << endl;
            cout << "pickup region: " << task_region[t_id] << endl;
            //*/

            // int old_sum_jam_weight = region_agent_num[task_region[t_id]];
            // cout << "pickup sum jam weight: " << old_sum_jam_weight << endl;

            int sum_jam_weight = 0;
            for (int i = 0; i < crossed_regions.size(); i++)
            {
                sum_jam_weight += region_agent_num[crossed_regions[i]];
            }
            // cout << "sum jam weight: " << sum_jam_weight << endl;

            // sum_jam_weight * jam_coefficient = estimated delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic) {
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1) {
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
        // nothing to assign
        else {
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Task Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 1.2.5.1: 将地图分成12x12的区域, agent-pickup经过区域中agent的平均密度作为sum jam weight
void TaskScheduler::adaptive_jam_agent_pickup_crossed_region_current_density(int time_limit, std::vector<int>& proposed_schedule)
{
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    if (env->num_of_agents > 500 && free_agents.size() > 50)
    {
        if (first_epoch_done_time == -1)
        {
            // 由于大算例初始任务过多, 在初始任务分配完成前采用默认算法
            greedy_sum_without_newtask(time_limit, proposed_schedule);
            return;
        }
    }
    else
    {
        if (first_epoch_done_time == -1)
        {
            first_epoch_done_time = env->curr_timestep; // 初始阶段的任务分配完毕的时间
        }
    }

    // 将map分为若干区域, 统计每个区域agent的数量
    small_region_wait_num.assign(small_region_wait_num.size(), 0); // 每次清空

    for (int i = 0; i < env->num_of_agents; i++)
    {
        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;

        int agent_region_x = agent_loc_x / small_region_column;
        int agent_region_y = agent_loc_y / small_region_row;

        small_region_wait_num[agent_region_y * num_small_region_column + agent_region_x]++;
    }

    /*
    cout << "region agent num: ";
    for(int i : region_agent_num)
    {
        cout << i << " ";
    }
    cout << endl;
     //*/

    if (env->num_of_agents <= 500) // 小算例直接算
    {
        for (int t_id : env->new_tasks)
        {
            int pickup_loc = env->task_pool[t_id].locations[0];
            int pickup_loc_x = pickup_loc % env->cols;
            int pickup_loc_y = pickup_loc / env->cols;

            int pickup_region_x = pickup_loc_x / small_region_column;
            int pickup_region_y = pickup_loc_y / small_region_row;

            task_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;
        }
    }
    else // 大算例
    {
        if (env->curr_timestep == first_epoch_done_time) // 在first_epoch_done_time计算完此时的free tasks
        {
            for (int t_id : free_tasks)
            {
                int pickup_loc = env->task_pool[t_id].locations[0];
                int pickup_loc_x = pickup_loc % env->cols;
                int pickup_loc_y = pickup_loc / env->cols;

                int pickup_region_x = pickup_loc_x / small_region_column;
                int pickup_region_y = pickup_loc_y / small_region_row;

                task_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;
            }
        }
        else // first_epoch_done_time之后就只计算新任务
        {
            for (int t_id : env->new_tasks)
            {
                int pickup_loc = env->task_pool[t_id].locations[0];
                int pickup_loc_x = pickup_loc % env->cols;
                int pickup_loc_y = pickup_loc / env->cols;

                int pickup_region_x = pickup_loc_x / small_region_column;
                int pickup_region_y = pickup_loc_y / small_region_row;

                task_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;
            }
        }
    }

    // cout << 5036 << endl;

    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            // check for timeout every 10 task evaluations
            if (std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations) {
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            // cout << "from " << env->curr_states.at(i).location << " to " << env->task_pool[t_id].locations[0] << endl;

            int temp_start = env->curr_states.at(i).location;
            int temp_goal = env->task_pool[t_id].locations[0];

            // cout << "temp start " << temp_start << endl;
            // cout << "temp goal " << temp_goal << endl;

            // 获取连线经过的单元格
            vector<Point> crossed_cells = get_line_crossed_cell(temp_start, temp_goal);

            // 计算经过的区域
            vector<int> crossed_regions = get_line_crossed_regions(crossed_cells);

            /*
            std::cout << "To pickup crossed regions: ";
            for (int r : crossed_regions) {
                std::cout << r << " ";
            }
            std::cout << std::endl;
            //*/

            /*
            int curr_loc_x = temp_start % env->cols;
            int curr_loc_y = temp_goal / env->cols;

            int curr_region_x = curr_loc_x / small_region_column;
            int curr_region_y = curr_loc_y / small_region_row;

            auto verified_curr_region = curr_region_y * num_small_region_column + curr_region_x;

            cout << "verified start region: " << verified_curr_region << endl;

            int pickup_loc_x = temp_goal % env->cols;
            int pickup_loc_y = temp_goal / env->cols;

            int pickup_region_x = pickup_loc_x / small_region_column;
            int pickup_region_y = pickup_loc_y / small_region_row;

            auto verified_pickup_region = pickup_region_y * num_small_region_column + pickup_region_x;

            cout << "verified pickup region: " << verified_pickup_region << endl;
            cout << "pickup region: " << task_region[t_id] << endl;
            //*/

            // int old_sum_jam_weight = region_agent_num[task_region[t_id]];
            // cout << "pickup sum jam weight: " << old_sum_jam_weight << endl;

            double sum_density = 0;
            for (auto crossed_region : crossed_regions)
            {
                if (small_region_blank_num[crossed_region] != 0)
                {
                    sum_density += static_cast<double>(small_region_wait_num[crossed_region]) / small_region_blank_num[crossed_region];
                }                
            }

            double sum_jam_weight = sum_density / crossed_regions.size();

            // cout << "sum jam weight: " << sum_jam_weight << endl;

            // sum_jam_weight * jam_coefficient = estimated delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic) {
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1) {
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
        // nothing to assign
        else {
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Task Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 1.2.5.2: 将地图分成12x12的区域, agent-pickup经过区域中agent的平均密度 x |agent pickup|作为sum jam weight
void TaskScheduler::adaptive_jam_agent_pickup_crossed_region_current_density_times_agent_pickup(int time_limit, std::vector<int>& proposed_schedule)
{
    cout << "agent pickup crossed region current density times agent pickup" << endl;
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    if (env->num_of_agents > 500 && free_agents.size() > 50)
    {
        if (first_epoch_done_time == -1)
        {
            // 由于大算例初始任务过多, 在初始任务分配完成前采用默认算法
            greedy_sum_without_newtask(time_limit, proposed_schedule);
            return;
        }
    }
    else
    {
        if (first_epoch_done_time == -1)
        {
            first_epoch_done_time = env->curr_timestep; // 初始阶段的任务分配完毕的时间
        }
    }

    // 将map分为若干区域, 统计每个区域agent的数量
    small_region_wait_num.assign(small_region_wait_num.size(), 0); // 每次清空

    for (int i = 0; i < env->num_of_agents; i++)
    {
        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;

        int agent_region_x = agent_loc_x / small_region_column;
        int agent_region_y = agent_loc_y / small_region_row;

        small_region_wait_num[agent_region_y * num_small_region_column + agent_region_x]++;
    }

    /*
    cout << "region agent num: ";
    for(int i : region_agent_num)
    {
        cout << i << " ";
    }
    cout << endl;
     //*/

    if (env->num_of_agents <= 500) // 小算例直接算
    {
        for (int t_id : env->new_tasks)
        {
            int pickup_loc = env->task_pool[t_id].locations[0];
            int pickup_loc_x = pickup_loc % env->cols;
            int pickup_loc_y = pickup_loc / env->cols;

            int pickup_region_x = pickup_loc_x / small_region_column;
            int pickup_region_y = pickup_loc_y / small_region_row;

            task_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;
        }
    }
    else // 大算例
    {
        if (env->curr_timestep == first_epoch_done_time) // 在first_epoch_done_time计算完此时的free tasks
        {
            for (int t_id : free_tasks)
            {
                int pickup_loc = env->task_pool[t_id].locations[0];
                int pickup_loc_x = pickup_loc % env->cols;
                int pickup_loc_y = pickup_loc / env->cols;

                int pickup_region_x = pickup_loc_x / small_region_column;
                int pickup_region_y = pickup_loc_y / small_region_row;

                task_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;
            }
        }
        else // first_epoch_done_time之后就只计算新任务
        {
            for (int t_id : env->new_tasks)
            {
                int pickup_loc = env->task_pool[t_id].locations[0];
                int pickup_loc_x = pickup_loc % env->cols;
                int pickup_loc_y = pickup_loc / env->cols;

                int pickup_region_x = pickup_loc_x / small_region_column;
                int pickup_region_y = pickup_loc_y / small_region_row;

                task_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;
            }
        }
    }

    // cout << 5036 << endl;

    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            // check for timeout every 10 task evaluations
            if (std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations) {
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            // cout << "from " << env->curr_states.at(i).location << " to " << env->task_pool[t_id].locations[0] << endl;

            int curr_loc = env->curr_states.at(i).location;
            int pickup_loc = env->task_pool[t_id].locations[0];

            // cout << "temp start " << temp_start << endl;
            // cout << "temp goal " << temp_goal << endl;

            // 获取连线经过的单元格
            vector<Point> crossed_cells = get_line_crossed_cell(curr_loc, pickup_loc);

            // 计算经过的区域
            vector<int> crossed_regions = get_line_crossed_regions(crossed_cells);

            /*
            std::cout << "To pickup crossed regions: ";
            for (int r : crossed_regions) {
                std::cout << r << " ";
            }
            std::cout << std::endl;
            //*/

            /*
            int curr_loc_x = temp_start % env->cols;
            int curr_loc_y = temp_goal / env->cols;

            int curr_region_x = curr_loc_x / small_region_column;
            int curr_region_y = curr_loc_y / small_region_row;

            auto verified_curr_region = curr_region_y * num_small_region_column + curr_region_x;

            cout << "verified start region: " << verified_curr_region << endl;

            int pickup_loc_x = temp_goal % env->cols;
            int pickup_loc_y = temp_goal / env->cols;

            int pickup_region_x = pickup_loc_x / small_region_column;
            int pickup_region_y = pickup_loc_y / small_region_row;

            auto verified_pickup_region = pickup_region_y * num_small_region_column + pickup_region_x;

            cout << "verified pickup region: " << verified_pickup_region << endl;
            cout << "pickup region: " << task_region[t_id] << endl;
            //*/

            // int old_sum_jam_weight = region_agent_num[task_region[t_id]];
            // cout << "pickup sum jam weight: " << old_sum_jam_weight << endl;

            double sum_density = 0;
            for (auto crossed_region : crossed_regions)
            {
                if (small_region_blank_num[crossed_region] != 0)
                {
                    // agent-pickup经过区域的算术平均密度
                    sum_density += static_cast<double>(small_region_wait_num[crossed_region]) / small_region_blank_num[crossed_region];
                }
            }
           
            double sum_jam_weight = (sum_density / crossed_regions.size()) * DefaultPlanner::get_h(env, curr_loc, pickup_loc);

            // cout << "sum jam weight: " << sum_jam_weight << endl;

            // sum_jam_weight * jam_coefficient = estimated delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic) {
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1) {
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
        // nothing to assign
        else {
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Task Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 1.2.5.2.1: 将地图分成12x12的区域, agent-pickup经过区域中agent的加权平均密度 x |agent pickup|作为sum jam weight
void TaskScheduler::adaptive_jam_agent_pickup_crossed_region_current_weighted_density_times_agent_pickup(int time_limit, std::vector<int>& proposed_schedule)
{
    cout << "agent pickup crossed region current weighted density times agent pickup" << endl;
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    if (env->num_of_agents > 500 && free_agents.size() > 50)
    {
        if (first_epoch_done_time == -1)
        {
            // 由于大算例初始任务过多, 在初始任务分配完成前采用默认算法
            greedy_sum_without_newtask(time_limit, proposed_schedule);
            return;
        }
    }
    else
    {
        if (first_epoch_done_time == -1)
        {
            first_epoch_done_time = env->curr_timestep; // 初始阶段的任务分配完毕的时间
        }
    }

    // 将map分为若干区域, 统计每个区域agent的数量
    small_region_wait_num.assign(small_region_wait_num.size(), 0); // 每次清空

    for (int i = 0; i < env->num_of_agents; i++)
    {
        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;

        int agent_region_x = agent_loc_x / small_region_column;
        int agent_region_y = agent_loc_y / small_region_row;

        small_region_wait_num[agent_region_y * num_small_region_column + agent_region_x]++;
    }

    /*
    cout << "region agent num: ";
    for(int i : region_agent_num)
    {
        cout << i << " ";
    }
    cout << endl;
     //*/

    if (env->num_of_agents <= 500) // 小算例直接算
    {
        for (int t_id : env->new_tasks)
        {
            int pickup_loc = env->task_pool[t_id].locations[0];
            int pickup_loc_x = pickup_loc % env->cols;
            int pickup_loc_y = pickup_loc / env->cols;

            int pickup_region_x = pickup_loc_x / small_region_column;
            int pickup_region_y = pickup_loc_y / small_region_row;

            task_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;
        }
    }
    else // 大算例
    {
        if (env->curr_timestep == first_epoch_done_time) // 在first_epoch_done_time计算完此时的free tasks
        {
            for (int t_id : free_tasks)
            {
                int pickup_loc = env->task_pool[t_id].locations[0];
                int pickup_loc_x = pickup_loc % env->cols;
                int pickup_loc_y = pickup_loc / env->cols;

                int pickup_region_x = pickup_loc_x / small_region_column;
                int pickup_region_y = pickup_loc_y / small_region_row;

                task_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;
            }
        }
        else // first_epoch_done_time之后就只计算新任务
        {
            for (int t_id : env->new_tasks)
            {
                int pickup_loc = env->task_pool[t_id].locations[0];
                int pickup_loc_x = pickup_loc % env->cols;
                int pickup_loc_y = pickup_loc / env->cols;

                int pickup_region_x = pickup_loc_x / small_region_column;
                int pickup_region_y = pickup_loc_y / small_region_row;

                task_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;
            }
        }
    }

    // cout << 5036 << endl;

    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            // check for timeout every 10 task evaluations
            if (std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations) {
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            // cout << "from " << env->curr_states.at(i).location << " to " << env->task_pool[t_id].locations[0] << endl;

            int curr_loc = env->curr_states.at(i).location;
            int pickup_loc = env->task_pool[t_id].locations[0];

            // cout << "temp start " << temp_start << endl;
            // cout << "temp goal " << temp_goal << endl;

            // 获取连线经过的单元格
            vector<Point> crossed_cells = get_line_crossed_cell(curr_loc, pickup_loc);

            // 计算经过的区域
            vector<int> crossed_regions = get_line_crossed_regions(crossed_cells);

            /*
            std::cout << "To pickup crossed regions: ";
            for (int r : crossed_regions) {
                std::cout << r << " ";
            }
            std::cout << std::endl;
            //*/

            /*
            int curr_loc_x = temp_start % env->cols;
            int curr_loc_y = temp_goal / env->cols;

            int curr_region_x = curr_loc_x / small_region_column;
            int curr_region_y = curr_loc_y / small_region_row;

            auto verified_curr_region = curr_region_y * num_small_region_column + curr_region_x;

            cout << "verified start region: " << verified_curr_region << endl;

            int pickup_loc_x = temp_goal % env->cols;
            int pickup_loc_y = temp_goal / env->cols;

            int pickup_region_x = pickup_loc_x / small_region_column;
            int pickup_region_y = pickup_loc_y / small_region_row;

            auto verified_pickup_region = pickup_region_y * num_small_region_column + pickup_region_x;

            cout << "verified pickup region: " << verified_pickup_region << endl;
            cout << "pickup region: " << task_region[t_id] << endl;
            //*/

            // int old_sum_jam_weight = region_agent_num[task_region[t_id]];
            // cout << "pickup sum jam weight: " << old_sum_jam_weight << endl;

            double sum_density = 0;
            double weight = 1;
            double common_ratio = 0.8;
            double sum_weight = 0;
            for (auto crossed_region : crossed_regions)
            {
                if (small_region_blank_num[crossed_region] != 0)
                {
                    // agent-pickup经过区域的算术平均密度
                    sum_density += (small_region_wait_num[crossed_region] * weight) / small_region_blank_num[crossed_region];

                    sum_weight += weight;
                    weight *= common_ratio;                    
                }
            }

            // cout << "sum weight: " << sum_weight << endl;

            double sum_jam_weight = (sum_density / sum_weight) * DefaultPlanner::get_h(env, curr_loc, pickup_loc);

            // cout << "sum jam weight: " << sum_jam_weight << endl;

            // sum_jam_weight * jam_coefficient = estimated delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic) {
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1) {
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
        // nothing to assign
        else {
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Task Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 1.2.5.3: 将地图分成12x12的区域, agent-pickup经过区域中agent的平均密度 x |agent pickup delivery|作为sum jam weight
void TaskScheduler::adaptive_jam_agent_pickup_crossed_region_current_density_times_agent_pickup_delivery(int time_limit, std::vector<int>& proposed_schedule)
{
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    if (env->num_of_agents > 500 && free_agents.size() > 50)
    {
        if (first_epoch_done_time == -1)
        {
            // 由于大算例初始任务过多, 在初始任务分配完成前采用默认算法
            greedy_sum_without_newtask(time_limit, proposed_schedule);
            return;
        }
    }
    else
    {
        if (first_epoch_done_time == -1)
        {
            first_epoch_done_time = env->curr_timestep; // 初始阶段的任务分配完毕的时间
        }
    }

    // 将map分为若干区域, 统计每个区域agent的数量
    small_region_wait_num.assign(small_region_wait_num.size(), 0); // 每次清空

    for (int i = 0; i < env->num_of_agents; i++)
    {
        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;

        int agent_region_x = agent_loc_x / small_region_column;
        int agent_region_y = agent_loc_y / small_region_row;

        small_region_wait_num[agent_region_y * num_small_region_column + agent_region_x]++;
    }

    /*
    cout << "region agent num: ";
    for(int i : region_agent_num)
    {
        cout << i << " ";
    }
    cout << endl;
     //*/

    if (env->num_of_agents <= 500) // 小算例直接算
    {
        for (int t_id : env->new_tasks)
        {
            int pickup_loc = env->task_pool[t_id].locations[0];
            int pickup_loc_x = pickup_loc % env->cols;
            int pickup_loc_y = pickup_loc / env->cols;

            int pickup_region_x = pickup_loc_x / small_region_column;
            int pickup_region_y = pickup_loc_y / small_region_row;

            task_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;
        }
    }
    else // 大算例
    {
        if (env->curr_timestep == first_epoch_done_time) // 在first_epoch_done_time计算完此时的free tasks
        {
            for (int t_id : free_tasks)
            {
                int pickup_loc = env->task_pool[t_id].locations[0];
                int pickup_loc_x = pickup_loc % env->cols;
                int pickup_loc_y = pickup_loc / env->cols;

                int pickup_region_x = pickup_loc_x / small_region_column;
                int pickup_region_y = pickup_loc_y / small_region_row;

                task_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;
            }
        }
        else // first_epoch_done_time之后就只计算新任务
        {
            for (int t_id : env->new_tasks)
            {
                int pickup_loc = env->task_pool[t_id].locations[0];
                int pickup_loc_x = pickup_loc % env->cols;
                int pickup_loc_y = pickup_loc / env->cols;

                int pickup_region_x = pickup_loc_x / small_region_column;
                int pickup_region_y = pickup_loc_y / small_region_row;

                task_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;
            }
        }
    }

    // cout << 5036 << endl;

    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            // check for timeout every 10 task evaluations
            if (std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations) {
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            // cout << "from " << env->curr_states.at(i).location << " to " << env->task_pool[t_id].locations[0] << endl;

            int temp_start = env->curr_states.at(i).location;
            int temp_goal = env->task_pool[t_id].locations[0];

            // cout << "temp start " << temp_start << endl;
            // cout << "temp goal " << temp_goal << endl;

            // 获取连线经过的单元格
            vector<Point> crossed_cells = get_line_crossed_cell(temp_start, temp_goal);

            // 计算经过的区域
            vector<int> crossed_regions = get_line_crossed_regions(crossed_cells);

            /*
            std::cout << "To pickup crossed regions: ";
            for (int r : crossed_regions) {
                std::cout << r << " ";
            }
            std::cout << std::endl;
            //*/

            /*
            int curr_loc_x = temp_start % env->cols;
            int curr_loc_y = temp_goal / env->cols;

            int curr_region_x = curr_loc_x / small_region_column;
            int curr_region_y = curr_loc_y / small_region_row;

            auto verified_curr_region = curr_region_y * num_small_region_column + curr_region_x;

            cout << "verified start region: " << verified_curr_region << endl;

            int pickup_loc_x = temp_goal % env->cols;
            int pickup_loc_y = temp_goal / env->cols;

            int pickup_region_x = pickup_loc_x / small_region_column;
            int pickup_region_y = pickup_loc_y / small_region_row;

            auto verified_pickup_region = pickup_region_y * num_small_region_column + pickup_region_x;

            cout << "verified pickup region: " << verified_pickup_region << endl;
            cout << "pickup region: " << task_region[t_id] << endl;
            //*/

            // int old_sum_jam_weight = region_agent_num[task_region[t_id]];
            // cout << "pickup sum jam weight: " << old_sum_jam_weight << endl;

            double sum_density = 0;
            for (auto crossed_region : crossed_regions)
            {
                if (small_region_blank_num[crossed_region] != 0)
                {
                    sum_density += static_cast<double>(small_region_wait_num[crossed_region]) / small_region_blank_num[crossed_region];
                }
            }

            int curr_loc = env->curr_states.at(i).location;
            int pickup_loc = env->task_pool[t_id].locations[0];
            double sum_jam_weight = (sum_density / crossed_regions.size()) * dist;

            // cout << "sum jam weight: " << sum_jam_weight << endl;

            // sum_jam_weight * jam_coefficient = estimated delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic) {
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1) {
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
        // nothing to assign
        else {
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Task Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 1.2.6: 将地图分成12x12的区域, pickup-delivery经过区域中agent的数量之和作为sum jam weight
void TaskScheduler::adaptive_jam_pickup_delivery_crossed_region_count_current(int time_limit, std::vector<int>& proposed_schedule)
{
    cout << "pickup delivery crossed region count current" << endl;
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    if (env->num_of_agents > 500 && free_agents.size() > 50)
    {
        if (first_epoch_done_time == -1)
        {
            // 由于大算例初始任务过多, 在初始任务分配完成前采用默认算法
            greedy_sum_without_newtask(time_limit, proposed_schedule);
            return;
        }
    }
    else
    {
        if (first_epoch_done_time == -1)
        {
            first_epoch_done_time = env->curr_timestep; // 初始阶段的任务分配完毕的时间
        }
    }

    // 将map分为若干区域, 统计每个区域agent的数量
    vector<int> region_agent_num(num_small_region_column * num_small_region_row, 0);

    for (int i = 0; i < env->num_of_agents; i++)
    {
        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;

        int agent_region_x = agent_loc_x / small_region_column;
        int agent_region_y = agent_loc_y / small_region_row;

        region_agent_num[agent_region_y * num_small_region_column + agent_region_x]++;
    }

    /*
    cout << "region agent num: ";
    for(int i : region_agent_num)
    {
        cout << i << " ";
    }
    cout << endl;
     //*/

    std::unordered_map<int, int> task_errand_crossed_region_count_current; // 记录每个task errand连线穿过的区域的agent总数

    if (env->num_of_agents <= 500) // 小算例直接算
    {
        for (int t_id : env->new_tasks)
        {
            vector<int> pickup_delivery_crossed_regions;
            for (int i = 0; i < env->task_pool[t_id].locations.size() - 1; i++)
            {
                // 获取连线经过的单元格
                vector<Point> crossed_cells = get_line_crossed_cell(env->task_pool[t_id].locations[i], 
                    env->task_pool[t_id].locations[i+1]);

                // 计算经过的区域
                vector<int> crossed_regions = get_line_crossed_regions(crossed_cells);

                // 拼接到总区域里
                if (pickup_delivery_crossed_regions.empty())
                {
                    pickup_delivery_crossed_regions = crossed_regions;
                }
                else
                {
                    // 检查 B 是否至少有两个元素
                    if (crossed_regions.size() > 1)
                    {
                        // 将 B 的第一个元素去掉后的部分拼接到 A 的尾部
                        pickup_delivery_crossed_regions.insert(pickup_delivery_crossed_regions.end(),
                            crossed_regions.begin() + 1, crossed_regions.end());
                    }
                }
            }

            task_errand_crossed_region[t_id] = pickup_delivery_crossed_regions;
        }
    }
    else // 大算例
    {
        if (env->curr_timestep == first_epoch_done_time) // 在first_epoch_done_time计算完此时的free tasks
        {
            for (int t_id : free_tasks)
            {
                vector<int> pickup_delivery_crossed_regions;
                for (int i = 0; i < env->task_pool[t_id].locations.size() - 1; i++)
                {
                    // 获取连线经过的单元格
                    vector<Point> crossed_cells = get_line_crossed_cell(env->task_pool[t_id].locations[i],
                        env->task_pool[t_id].locations[i + 1]);

                    // 计算经过的区域
                    vector<int> crossed_regions = get_line_crossed_regions(crossed_cells);

                    // 拼接到总区域里
                    if (pickup_delivery_crossed_regions.empty())
                    {
                        pickup_delivery_crossed_regions = crossed_regions;
                    }
                    else
                    {
                        // 检查 B 是否至少有两个元素
                        if (crossed_regions.size() > 1)
                        {
                            // 将 B 的第一个元素去掉后的部分拼接到 A 的尾部
                            pickup_delivery_crossed_regions.insert(pickup_delivery_crossed_regions.end(),
                                crossed_regions.begin() + 1, crossed_regions.end());
                        }
                    }
                }

                task_errand_crossed_region[t_id] = pickup_delivery_crossed_regions;
            }
        }
        else // first_epoch_done_time之后就只计算新任务
        {
            for (int t_id : env->new_tasks)
            {
                vector<int> pickup_delivery_crossed_regions;
                for (int i = 0; i < env->task_pool[t_id].locations.size() - 1; i++)
                {
                    // 获取连线经过的单元格
                    vector<Point> crossed_cells = get_line_crossed_cell(env->task_pool[t_id].locations[i],
                        env->task_pool[t_id].locations[i + 1]);

                    // 计算经过的区域
                    vector<int> crossed_regions = get_line_crossed_regions(crossed_cells);

                    // 拼接到总区域里
                    if (pickup_delivery_crossed_regions.empty())
                    {
                        pickup_delivery_crossed_regions = crossed_regions;
                    }
                    else
                    {
                        // 检查 B 是否至少有两个元素
                        if (crossed_regions.size() > 1)
                        {
                            // 将 B 的第一个元素去掉后的部分拼接到 A 的尾部
                            pickup_delivery_crossed_regions.insert(pickup_delivery_crossed_regions.end(),
                                crossed_regions.begin() + 1, crossed_regions.end());
                        }
                    }
                }

                task_errand_crossed_region[t_id] = pickup_delivery_crossed_regions;                
            }
        }
    }

    // 每个时间步, 一个任务经过区域的agent数量都会刷新
    for (int t_id : free_tasks)
    {
        int sum_jam_weight = 0;
        for (auto crossed_region : task_errand_crossed_region[t_id])
        {
            sum_jam_weight += region_agent_num[crossed_region];
        }
        task_errand_crossed_region_count_current[t_id] = sum_jam_weight;
    }

    // cout << 5036 << endl;
    
    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            // check for timeout every 10 task evaluations
            if (std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations)
            {
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            // cout << "from " << env->curr_states.at(i).location << " to " << env->task_pool[t_id].locations[0] << endl;

            // int temp_start = env->curr_states.at(i).location;
            // int temp_goal = env->task_pool[t_id].locations[0];

            // cout << "temp start " << temp_start << endl;
            // cout << "temp goal " << temp_goal << endl;

            // 获取连线经过的单元格
            // vector<Point> to_pickup_crossed_cells = get_line_crossed_cell(temp_start, temp_goal);

            // 计算经过的区域
            // vector<int> to_pickup_crossed_regions = get_line_crossed_regions(to_pickup_crossed_cells);

            /*
            std::cout << "pickup delivery crossed regions: ";
            for (int r : task_errand_crossed_region[t_id]) {
                std::cout << r << " ";
            }
            std::cout << std::endl;

            std::cout << "agent pickup delivery crossed regions: ";
            for (int r : agent_pickup_delivery_crossed_regions) {
                std::cout << r << " ";
            }
            std::cout << std::endl;
            //*/

            /*
            int curr_loc_x = temp_start % env->cols;
            int curr_loc_y = temp_goal / env->cols;

            int curr_region_x = curr_loc_x / small_region_column;
            int curr_region_y = curr_loc_y / small_region_row;

            auto verified_curr_region = curr_region_y * num_small_region_column + curr_region_x;

            cout << "verified start region: " << verified_curr_region << endl;

            int pickup_loc_x = temp_goal % env->cols;
            int pickup_loc_y = temp_goal / env->cols;

            int pickup_region_x = pickup_loc_x / small_region_column;
            int pickup_region_y = pickup_loc_y / small_region_row;

            auto verified_pickup_region = pickup_region_y * num_small_region_column + pickup_region_x;

            cout << "verified pickup region: " << verified_pickup_region << endl;
            cout << "pickup region: " << task_region[t_id] << endl;
            //*/

            // int old_sum_jam_weight = region_agent_num[task_region[t_id]];
            // cout << "pickup sum jam weight: " << old_sum_jam_weight << endl;

            int sum_jam_weight = task_errand_crossed_region_count_current[t_id];
            // cout << "sum jam weight: " << sum_jam_weight << endl;

            // sum_jam_weight * jam_coefficient = estimated delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic) {
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1) {
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
        // nothing to assign
        else {
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Task Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 1.2.6.1: 将地图分成12x12的区域, pickup-delivery经过区域中agent goal的数量之和作为sum jam weight
void TaskScheduler::adaptive_jam_pickup_delivery_crossed_region_count_goal(int time_limit, std::vector<int>& proposed_schedule)
{
    cout << "pickup delivery crossed region count goal" << endl;
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    if (env->num_of_agents > 500 && free_agents.size() > 50)
    {
        if (first_epoch_done_time == -1)
        {
            // 由于大算例初始任务过多, 在初始任务分配完成前采用默认算法
            greedy_sum_without_newtask(time_limit, proposed_schedule);
            return;
        }
    }
    else
    {
        if (first_epoch_done_time == -1)
        {
            first_epoch_done_time = env->curr_timestep; // 初始阶段的任务分配完毕的时间
        }
    }

    // 将map分为若干区域, 统计每个区域agent的数量
    vector<int> region_agent_num(num_small_region_column * num_small_region_row, 0);

    for (int i = 0; i < env->goal_locations.size(); i++)
    {
        if (!env->goal_locations[i].empty()) // 所有agent都会有任务, 所以都要计入
        {
            for (auto const& goal : env->goal_locations[i])
            {
                int agent_goal = goal.first;
                int agent_goal_x = agent_goal % env->cols;
                int agent_goal_y = agent_goal / env->cols;

                int agent_region_x = agent_goal_x / small_region_column;
                int agent_region_y = agent_goal_y / small_region_row;

                region_agent_num[agent_region_y * num_small_region_column + agent_region_x]++;
            }            
        }
    }

    /*
    cout << "region agent num: ";
    for(int i : region_agent_num)
    {
        cout << i << " ";
    }
    cout << endl;
     //*/

    std::unordered_map<int, int> task_errand_crossed_region_count_current; // 记录每个task errand连线穿过的区域的agent总数

    if (env->num_of_agents <= 500) // 小算例直接算
    {
        for (int t_id : env->new_tasks)
        {
            vector<int> pickup_delivery_crossed_regions;
            for (int i = 0; i < env->task_pool[t_id].locations.size() - 1; i++)
            {
                // 获取连线经过的单元格
                vector<Point> crossed_cells = get_line_crossed_cell(env->task_pool[t_id].locations[i],
                    env->task_pool[t_id].locations[i + 1]);

                // 计算经过的区域
                vector<int> crossed_regions = get_line_crossed_regions(crossed_cells);

                // 拼接到总区域里
                if (pickup_delivery_crossed_regions.empty())
                {
                    pickup_delivery_crossed_regions = crossed_regions;
                }
                else
                {
                    // 检查 B 是否至少有两个元素
                    if (crossed_regions.size() > 1)
                    {
                        // 将 B 的第一个元素去掉后的部分拼接到 A 的尾部
                        pickup_delivery_crossed_regions.insert(pickup_delivery_crossed_regions.end(),
                            crossed_regions.begin() + 1, crossed_regions.end());
                    }
                }
            }

            task_errand_crossed_region[t_id] = pickup_delivery_crossed_regions;
        }
    }
    else // 大算例
    {
        if (env->curr_timestep == first_epoch_done_time) // 在first_epoch_done_time计算完此时的free tasks
        {
            for (int t_id : free_tasks)
            {
                vector<int> pickup_delivery_crossed_regions;
                for (int i = 0; i < env->task_pool[t_id].locations.size() - 1; i++)
                {
                    // 获取连线经过的单元格
                    vector<Point> crossed_cells = get_line_crossed_cell(env->task_pool[t_id].locations[i],
                        env->task_pool[t_id].locations[i + 1]);

                    // 计算经过的区域
                    vector<int> crossed_regions = get_line_crossed_regions(crossed_cells);

                    // 拼接到总区域里
                    if (pickup_delivery_crossed_regions.empty())
                    {
                        pickup_delivery_crossed_regions = crossed_regions;
                    }
                    else
                    {
                        // 检查 B 是否至少有两个元素
                        if (crossed_regions.size() > 1)
                        {
                            // 将 B 的第一个元素去掉后的部分拼接到 A 的尾部
                            pickup_delivery_crossed_regions.insert(pickup_delivery_crossed_regions.end(),
                                crossed_regions.begin() + 1, crossed_regions.end());
                        }
                    }
                }

                task_errand_crossed_region[t_id] = pickup_delivery_crossed_regions;
            }
        }
        else // first_epoch_done_time之后就只计算新任务
        {
            for (int t_id : env->new_tasks)
            {
                vector<int> pickup_delivery_crossed_regions;
                for (int i = 0; i < env->task_pool[t_id].locations.size() - 1; i++)
                {
                    // 获取连线经过的单元格
                    vector<Point> crossed_cells = get_line_crossed_cell(env->task_pool[t_id].locations[i],
                        env->task_pool[t_id].locations[i + 1]);

                    // 计算经过的区域
                    vector<int> crossed_regions = get_line_crossed_regions(crossed_cells);

                    // 拼接到总区域里
                    if (pickup_delivery_crossed_regions.empty())
                    {
                        pickup_delivery_crossed_regions = crossed_regions;
                    }
                    else
                    {
                        // 检查 B 是否至少有两个元素
                        if (crossed_regions.size() > 1)
                        {
                            // 将 B 的第一个元素去掉后的部分拼接到 A 的尾部
                            pickup_delivery_crossed_regions.insert(pickup_delivery_crossed_regions.end(),
                                crossed_regions.begin() + 1, crossed_regions.end());
                        }
                    }
                }

                task_errand_crossed_region[t_id] = pickup_delivery_crossed_regions;
            }
        }
    }

    // 每个时间步, 一个任务经过区域的agent数量都会刷新
    for (int t_id : free_tasks)
    {
        int sum_jam_weight = 0;
        for (auto crossed_region : task_errand_crossed_region[t_id])
        {
            sum_jam_weight += region_agent_num[crossed_region];
        }
        task_errand_crossed_region_count_current[t_id] = sum_jam_weight;
    }

    // cout << 5036 << endl;

    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            // check for timeout every 10 task evaluations
            if (std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations)
            {
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            // cout << "from " << env->curr_states.at(i).location << " to " << env->task_pool[t_id].locations[0] << endl;

            // int temp_start = env->curr_states.at(i).location;
            // int temp_goal = env->task_pool[t_id].locations[0];

            // cout << "temp start " << temp_start << endl;
            // cout << "temp goal " << temp_goal << endl;

            // 获取连线经过的单元格
            // vector<Point> to_pickup_crossed_cells = get_line_crossed_cell(temp_start, temp_goal);

            // 计算经过的区域
            // vector<int> to_pickup_crossed_regions = get_line_crossed_regions(to_pickup_crossed_cells);

            /*
            std::cout << "pickup delivery crossed regions: ";
            for (int r : task_errand_crossed_region[t_id]) {
                std::cout << r << " ";
            }
            std::cout << std::endl;

            std::cout << "agent pickup delivery crossed regions: ";
            for (int r : agent_pickup_delivery_crossed_regions) {
                std::cout << r << " ";
            }
            std::cout << std::endl;
            //*/

            /*
            int curr_loc_x = temp_start % env->cols;
            int curr_loc_y = temp_goal / env->cols;

            int curr_region_x = curr_loc_x / small_region_column;
            int curr_region_y = curr_loc_y / small_region_row;

            auto verified_curr_region = curr_region_y * num_small_region_column + curr_region_x;

            cout << "verified start region: " << verified_curr_region << endl;

            int pickup_loc_x = temp_goal % env->cols;
            int pickup_loc_y = temp_goal / env->cols;

            int pickup_region_x = pickup_loc_x / small_region_column;
            int pickup_region_y = pickup_loc_y / small_region_row;

            auto verified_pickup_region = pickup_region_y * num_small_region_column + pickup_region_x;

            cout << "verified pickup region: " << verified_pickup_region << endl;
            cout << "pickup region: " << task_region[t_id] << endl;
            //*/

            // int old_sum_jam_weight = region_agent_num[task_region[t_id]];
            // cout << "pickup sum jam weight: " << old_sum_jam_weight << endl;

            int sum_jam_weight = task_errand_crossed_region_count_current[t_id];
            // cout << "sum jam weight: " << sum_jam_weight << endl;

            // sum_jam_weight * jam_coefficient = estimated delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic) {
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1) {
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
        // nothing to assign
        else {
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Task Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 1.2.7: 将地图分成12x12的区域, agent-pickup-delivery经过区域中agent的数量之和作为sum jam weight
void TaskScheduler::adaptive_jam_agent_pickup_delivery_crossed_region_count_current(int time_limit, std::vector<int>& proposed_schedule)
{
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    if (env->num_of_agents > 500 && free_agents.size() > 50)
    {
        if (first_epoch_done_time == -1)
        {
            // 由于大算例初始任务过多, 在初始任务分配完成前采用默认算法
            greedy_sum_without_newtask(time_limit, proposed_schedule);
            return;
        }
    }
    else
    {
        if (first_epoch_done_time == -1)
        {
            first_epoch_done_time = env->curr_timestep; // 初始阶段的任务分配完毕的时间
        }
    }

    // 将map分为若干区域, 统计每个区域agent的数量
    vector<int> region_agent_num(num_small_region_column * num_small_region_row, 0);

    for (int i = 0; i < env->num_of_agents; i++)
    {
        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;

        int agent_region_x = agent_loc_x / small_region_column;
        int agent_region_y = agent_loc_y / small_region_row;

        region_agent_num[agent_region_y * num_small_region_column + agent_region_x]++;
    }

    /*
    cout << "region agent num: ";
    for(int i : region_agent_num)
    {
        cout << i << " ";
    }
    cout << endl;
     //*/

    if (env->num_of_agents <= 500) // 小算例直接算
    {
        for (int t_id : env->new_tasks)
        {
            int pickup_loc = env->task_pool[t_id].locations[0];
            int pickup_loc_x = pickup_loc % env->cols;
            int pickup_loc_y = pickup_loc / env->cols;

            int pickup_region_x = pickup_loc_x / small_region_column;
            int pickup_region_y = pickup_loc_y / small_region_row;

            task_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;
        }
    }
    else // 大算例
    {
        if (env->curr_timestep == first_epoch_done_time) // 在first_epoch_done_time计算完此时的free tasks
        {
            for (int t_id : free_tasks)
            {
                int pickup_loc = env->task_pool[t_id].locations[0];
                int pickup_loc_x = pickup_loc % env->cols;
                int pickup_loc_y = pickup_loc / env->cols;

                int pickup_region_x = pickup_loc_x / small_region_column;
                int pickup_region_y = pickup_loc_y / small_region_row;

                task_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;
            }
        }
        else // first_epoch_done_time之后就只计算新任务
        {
            for (int t_id : env->new_tasks)
            {
                int pickup_loc = env->task_pool[t_id].locations[0];
                int pickup_loc_x = pickup_loc % env->cols;
                int pickup_loc_y = pickup_loc / env->cols;

                int pickup_region_x = pickup_loc_x / small_region_column;
                int pickup_region_y = pickup_loc_y / small_region_row;

                task_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;
            }
        }
    }

    // cout << 5036 << endl;

    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            // check for timeout every 10 task evaluations
            if (std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            vector<int> agent_pickup_delivery_crossed_regions;
            for (int loc : env->task_pool[t_id].locations) 
            {
                dist += DefaultPlanner::get_h(env, c_loc, loc);

                // 获取连线经过的单元格
                vector<Point> crossed_cells = get_line_crossed_cell(c_loc, loc);

                // 计算经过的区域
                vector<int> crossed_regions = get_line_crossed_regions(crossed_cells);

                // 拼接到总区域里
                if (agent_pickup_delivery_crossed_regions.empty())
                {
                    agent_pickup_delivery_crossed_regions = crossed_regions;
                }
                else
                {
                    // 检查 B 是否至少有两个元素
                    if (crossed_regions.size() > 1)
                    {
                        // 将 B 的第一个元素去掉后的部分拼接到 A 的尾部
                        agent_pickup_delivery_crossed_regions.insert(agent_pickup_delivery_crossed_regions.end(),
                            crossed_regions.begin() + 1, crossed_regions.end());
                    }
                }                    

                c_loc = loc;
            }

            // cout << "from " << env->curr_states.at(i).location << " to " << env->task_pool[t_id].locations[0] << endl;

            // int temp_start = env->curr_states.at(i).location;
            // int temp_goal = env->task_pool[t_id].locations[0];

            // cout << "temp start " << temp_start << endl;
            // cout << "temp goal " << temp_goal << endl;

            // 获取连线经过的单元格
            // vector<Point> to_pickup_crossed_cells = get_line_crossed_cell(temp_start, temp_goal);

            // 计算经过的区域
            // vector<int> to_pickup_crossed_regions = get_line_crossed_regions(to_pickup_crossed_cells);

            /*
            std::cout << "agent pickup crossed regions: ";
            for (int r : to_pickup_crossed_regions) {
                std::cout << r << " ";
            }
            std::cout << std::endl;

            std::cout << "agent pickup delivery crossed regions: ";
            for (int r : agent_pickup_delivery_crossed_regions) {
                std::cout << r << " ";
            }
            std::cout << std::endl;
            //*/

            /*
            int curr_loc_x = temp_start % env->cols;
            int curr_loc_y = temp_goal / env->cols;

            int curr_region_x = curr_loc_x / small_region_column;
            int curr_region_y = curr_loc_y / small_region_row;

            auto verified_curr_region = curr_region_y * num_small_region_column + curr_region_x;

            cout << "verified start region: " << verified_curr_region << endl;

            int pickup_loc_x = temp_goal % env->cols;
            int pickup_loc_y = temp_goal / env->cols;

            int pickup_region_x = pickup_loc_x / small_region_column;
            int pickup_region_y = pickup_loc_y / small_region_row;

            auto verified_pickup_region = pickup_region_y * num_small_region_column + pickup_region_x;

            cout << "verified pickup region: " << verified_pickup_region << endl;
            cout << "pickup region: " << task_region[t_id] << endl;
            //*/

            // int old_sum_jam_weight = region_agent_num[task_region[t_id]];
            // cout << "pickup sum jam weight: " << old_sum_jam_weight << endl;

            int sum_jam_weight = 0;
            for (int i = 0; i < agent_pickup_delivery_crossed_regions.size(); i++)
            {
                sum_jam_weight += region_agent_num[agent_pickup_delivery_crossed_regions[i]];
            }
            // cout << "sum jam weight: " << sum_jam_weight << endl;

            // sum_jam_weight * jam_coefficient = estimated delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic) {
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1) {
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
        // nothing to assign
        else {
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Task Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 1.2.8: 将地图分成12x12的区域, agent-pickup-delivery经过区域中agent的平均密度作为sum jam weight
void TaskScheduler::adaptive_jam_agent_pickup_delivery_crossed_region_current_density(int time_limit, std::vector<int>& proposed_schedule)
{
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    if (env->num_of_agents > 500 && free_agents.size() > 50)
    {
        if (first_epoch_done_time == -1)
        {
            // 由于大算例初始任务过多, 在初始任务分配完成前采用默认算法
            greedy_sum_without_newtask(time_limit, proposed_schedule);
            return;
        }
    }
    else
    {
        if (first_epoch_done_time == -1)
        {
            first_epoch_done_time = env->curr_timestep; // 初始阶段的任务分配完毕的时间
        }
    }

    // 将map分为若干区域, 统计每个区域agent的数量
    vector<int> region_agent_num(num_small_region_column * num_small_region_row, 0);

    for (int i = 0; i < env->num_of_agents; i++)
    {
        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;

        int agent_region_x = agent_loc_x / small_region_column;
        int agent_region_y = agent_loc_y / small_region_row;

        region_agent_num[agent_region_y * num_small_region_column + agent_region_x]++;
    }

    /*
    cout << "region agent num: ";
    for(int i : region_agent_num)
    {
        cout << i << " ";
    }
    cout << endl;
     //*/

    if (env->num_of_agents <= 500) // 小算例直接算
    {
        for (int t_id : env->new_tasks)
        {
            int pickup_loc = env->task_pool[t_id].locations[0];
            int pickup_loc_x = pickup_loc % env->cols;
            int pickup_loc_y = pickup_loc / env->cols;

            int pickup_region_x = pickup_loc_x / small_region_column;
            int pickup_region_y = pickup_loc_y / small_region_row;

            task_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;
        }
    }
    else // 大算例
    {
        if (env->curr_timestep == first_epoch_done_time) // 在first_epoch_done_time计算完此时的free tasks
        {
            for (int t_id : free_tasks)
            {
                int pickup_loc = env->task_pool[t_id].locations[0];
                int pickup_loc_x = pickup_loc % env->cols;
                int pickup_loc_y = pickup_loc / env->cols;

                int pickup_region_x = pickup_loc_x / small_region_column;
                int pickup_region_y = pickup_loc_y / small_region_row;

                task_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;
            }
        }
        else // first_epoch_done_time之后就只计算新任务
        {
            for (int t_id : env->new_tasks)
            {
                int pickup_loc = env->task_pool[t_id].locations[0];
                int pickup_loc_x = pickup_loc % env->cols;
                int pickup_loc_y = pickup_loc / env->cols;

                int pickup_region_x = pickup_loc_x / small_region_column;
                int pickup_region_y = pickup_loc_y / small_region_row;

                task_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;
            }
        }
    }

    // cout << 5036 << endl;

    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            // check for timeout every 10 task evaluations
            if (std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            vector<int> agent_pickup_delivery_crossed_regions;
            for (int loc : env->task_pool[t_id].locations)
            {
                dist += DefaultPlanner::get_h(env, c_loc, loc);

                // 获取连线经过的单元格
                vector<Point> crossed_cells = get_line_crossed_cell(c_loc, loc);

                // 计算经过的区域
                vector<int> crossed_regions = get_line_crossed_regions(crossed_cells);

                // 拼接到总区域里
                if (agent_pickup_delivery_crossed_regions.empty())
                {
                    agent_pickup_delivery_crossed_regions = crossed_regions;
                }
                else
                {
                    // 检查 B 是否至少有两个元素
                    if (crossed_regions.size() > 1)
                    {
                        // 将 B 的第一个元素去掉后的部分拼接到 A 的尾部
                        agent_pickup_delivery_crossed_regions.insert(agent_pickup_delivery_crossed_regions.end(),
                            crossed_regions.begin() + 1, crossed_regions.end());
                    }
                }

                c_loc = loc;
            }

            // cout << "from " << env->curr_states.at(i).location << " to " << env->task_pool[t_id].locations[0] << endl;

            // int temp_start = env->curr_states.at(i).location;
            // int temp_goal = env->task_pool[t_id].locations[0];

            // cout << "temp start " << temp_start << endl;
            // cout << "temp goal " << temp_goal << endl;

            // 获取连线经过的单元格
            // vector<Point> to_pickup_crossed_cells = get_line_crossed_cell(temp_start, temp_goal);

            // 计算经过的区域
            // vector<int> to_pickup_crossed_regions = get_line_crossed_regions(to_pickup_crossed_cells);

            /*
            std::cout << "agent pickup crossed regions: ";
            for (int r : to_pickup_crossed_regions) {
                std::cout << r << " ";
            }
            std::cout << std::endl;

            std::cout << "agent pickup delivery crossed regions: ";
            for (int r : agent_pickup_delivery_crossed_regions) {
                std::cout << r << " ";
            }
            std::cout << std::endl;
            //*/

            /*
            int curr_loc_x = temp_start % env->cols;
            int curr_loc_y = temp_goal / env->cols;

            int curr_region_x = curr_loc_x / small_region_column;
            int curr_region_y = curr_loc_y / small_region_row;

            auto verified_curr_region = curr_region_y * num_small_region_column + curr_region_x;

            cout << "verified start region: " << verified_curr_region << endl;

            int pickup_loc_x = temp_goal % env->cols;
            int pickup_loc_y = temp_goal / env->cols;

            int pickup_region_x = pickup_loc_x / small_region_column;
            int pickup_region_y = pickup_loc_y / small_region_row;

            auto verified_pickup_region = pickup_region_y * num_small_region_column + pickup_region_x;

            cout << "verified pickup region: " << verified_pickup_region << endl;
            cout << "pickup region: " << task_region[t_id] << endl;
            //*/

            // int old_sum_jam_weight = region_agent_num[task_region[t_id]];
            // cout << "pickup sum jam weight: " << old_sum_jam_weight << endl;

            double sum_density = 0;
            for (auto crossed_region : agent_pickup_delivery_crossed_regions)
            {
                if (small_region_blank_num[crossed_region] != 0)
                {
                    sum_density += static_cast<double>(region_agent_num[crossed_region]) / small_region_blank_num[crossed_region];
                }
            }

            double sum_jam_weight = sum_density / agent_pickup_delivery_crossed_regions.size();
            // cout << "sum jam weight: " << sum_jam_weight << endl;

            // sum_jam_weight * jam_coefficient = estimated delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic) {
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1) {
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
        // nothing to assign
        else {
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Task Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 1.2.9: 将地图分成12x12的区域, agent-pickup-delivery经过区域中agent的加权平均密度作为sum jam weight
void TaskScheduler::adaptive_jam_agent_pickup_delivery_crossed_region_current_weighted_density(int time_limit, std::vector<int>& proposed_schedule)
{
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    if (env->num_of_agents > 500 && free_agents.size() > 50)
    {
        if (first_epoch_done_time == -1)
        {
            // 由于大算例初始任务过多, 在初始任务分配完成前采用默认算法
            greedy_sum_without_newtask(time_limit, proposed_schedule);
            return;
        }
    }
    else
    {
        if (first_epoch_done_time == -1)
        {
            first_epoch_done_time = env->curr_timestep; // 初始阶段的任务分配完毕的时间
        }
    }

    // 将map分为若干区域, 统计每个区域agent的数量
    vector<int> region_agent_num(num_small_region_column * num_small_region_row, 0);

    for (int i = 0; i < env->num_of_agents; i++)
    {
        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;

        int agent_region_x = agent_loc_x / small_region_column;
        int agent_region_y = agent_loc_y / small_region_row;

        region_agent_num[agent_region_y * num_small_region_column + agent_region_x]++;
    }

    /*
    cout << "region agent num: ";
    for(int i : region_agent_num)
    {
        cout << i << " ";
    }
    cout << endl;
     //*/

    if (env->num_of_agents <= 500) // 小算例直接算
    {
        for (int t_id : env->new_tasks)
        {
            int pickup_loc = env->task_pool[t_id].locations[0];
            int pickup_loc_x = pickup_loc % env->cols;
            int pickup_loc_y = pickup_loc / env->cols;

            int pickup_region_x = pickup_loc_x / small_region_column;
            int pickup_region_y = pickup_loc_y / small_region_row;

            task_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;
        }
    }
    else // 大算例
    {
        if (env->curr_timestep == first_epoch_done_time) // 在first_epoch_done_time计算完此时的free tasks
        {
            for (int t_id : free_tasks)
            {
                int pickup_loc = env->task_pool[t_id].locations[0];
                int pickup_loc_x = pickup_loc % env->cols;
                int pickup_loc_y = pickup_loc / env->cols;

                int pickup_region_x = pickup_loc_x / small_region_column;
                int pickup_region_y = pickup_loc_y / small_region_row;

                task_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;
            }
        }
        else // first_epoch_done_time之后就只计算新任务
        {
            for (int t_id : env->new_tasks)
            {
                int pickup_loc = env->task_pool[t_id].locations[0];
                int pickup_loc_x = pickup_loc % env->cols;
                int pickup_loc_y = pickup_loc / env->cols;

                int pickup_region_x = pickup_loc_x / small_region_column;
                int pickup_region_y = pickup_loc_y / small_region_row;

                task_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;
            }
        }
    }

    // cout << 5036 << endl;

    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            // check for timeout every 10 task evaluations
            if (std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            vector<int> agent_pickup_delivery_crossed_regions;
            for (int loc : env->task_pool[t_id].locations)
            {
                dist += DefaultPlanner::get_h(env, c_loc, loc);

                // 获取连线经过的单元格
                vector<Point> crossed_cells = get_line_crossed_cell(c_loc, loc);

                // 计算经过的区域
                vector<int> crossed_regions = get_line_crossed_regions(crossed_cells);

                // 拼接到总区域里
                if (agent_pickup_delivery_crossed_regions.empty())
                {
                    agent_pickup_delivery_crossed_regions = crossed_regions;
                }
                else
                {
                    // 检查 B 是否至少有两个元素
                    if (crossed_regions.size() > 1)
                    {
                        // 将 B 的第一个元素去掉后的部分拼接到 A 的尾部
                        agent_pickup_delivery_crossed_regions.insert(agent_pickup_delivery_crossed_regions.end(),
                            crossed_regions.begin() + 1, crossed_regions.end());
                    }
                }

                c_loc = loc;
            }

            // cout << "from " << env->curr_states.at(i).location << " to " << env->task_pool[t_id].locations[0] << endl;

            // int temp_start = env->curr_states.at(i).location;
            // int temp_goal = env->task_pool[t_id].locations[0];

            // cout << "temp start " << temp_start << endl;
            // cout << "temp goal " << temp_goal << endl;

            // 获取连线经过的单元格
            // vector<Point> to_pickup_crossed_cells = get_line_crossed_cell(temp_start, temp_goal);

            // 计算经过的区域
            // vector<int> to_pickup_crossed_regions = get_line_crossed_regions(to_pickup_crossed_cells);

            /*
            std::cout << "agent pickup crossed regions: ";
            for (int r : to_pickup_crossed_regions) {
                std::cout << r << " ";
            }
            std::cout << std::endl;

            std::cout << "agent pickup delivery crossed regions: ";
            for (int r : agent_pickup_delivery_crossed_regions) {
                std::cout << r << " ";
            }
            std::cout << std::endl;
            //*/

            /*
            int curr_loc_x = temp_start % env->cols;
            int curr_loc_y = temp_goal / env->cols;

            int curr_region_x = curr_loc_x / small_region_column;
            int curr_region_y = curr_loc_y / small_region_row;

            auto verified_curr_region = curr_region_y * num_small_region_column + curr_region_x;

            cout << "verified start region: " << verified_curr_region << endl;

            int pickup_loc_x = temp_goal % env->cols;
            int pickup_loc_y = temp_goal / env->cols;

            int pickup_region_x = pickup_loc_x / small_region_column;
            int pickup_region_y = pickup_loc_y / small_region_row;

            auto verified_pickup_region = pickup_region_y * num_small_region_column + pickup_region_x;

            cout << "verified pickup region: " << verified_pickup_region << endl;
            cout << "pickup region: " << task_region[t_id] << endl;
            //*/

            // int old_sum_jam_weight = region_agent_num[task_region[t_id]];
            // cout << "pickup sum jam weight: " << old_sum_jam_weight << endl;

            double sum_density = 0;
            double weight = 1;
            double common_ratio = 0.8;
            double sum_weight = 0;
            for (auto crossed_region : agent_pickup_delivery_crossed_regions)
            {
                if (small_region_blank_num[crossed_region] != 0)
                {
                    // agent-pickup经过区域的算术平均密度
                    sum_density += (small_region_wait_num[crossed_region] * weight) / small_region_blank_num[crossed_region];

                    sum_weight += weight;
                    weight *= common_ratio;
                }
            }

            double sum_jam_weight = sum_density / sum_weight;
            // cout << "sum jam weight: " << sum_jam_weight << endl;

            // sum_jam_weight * jam_coefficient = estimated delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic) {
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1) {
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
        // nothing to assign
        else {
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Task Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 1.2.10: 将地图分成12x12的区域, agent-pickup-delivery经过区域中agent的加权平均密度 x |agent task|作为sum jam weight
void TaskScheduler::adaptive_jam_agent_pickup_delivery_crossed_region_current_weighted_density_times_agent_pickup(int time_limit, std::vector<int>& proposed_schedule)
{
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    if (env->num_of_agents > 500 && free_agents.size() > 50)
    {
        if (first_epoch_done_time == -1)
        {
            // 由于大算例初始任务过多, 在初始任务分配完成前采用默认算法
            greedy_sum_without_newtask(time_limit, proposed_schedule);
            return;
        }
    }
    else
    {
        if (first_epoch_done_time == -1)
        {
            first_epoch_done_time = env->curr_timestep; // 初始阶段的任务分配完毕的时间
        }
    }

    // 将map分为若干区域, 统计每个区域agent的数量
    vector<int> region_agent_num(num_small_region_column * num_small_region_row, 0);

    for (int i = 0; i < env->num_of_agents; i++)
    {
        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;

        int agent_region_x = agent_loc_x / small_region_column;
        int agent_region_y = agent_loc_y / small_region_row;

        region_agent_num[agent_region_y * num_small_region_column + agent_region_x]++;
    }

    /*
    cout << "region agent num: ";
    for(int i : region_agent_num)
    {
        cout << i << " ";
    }
    cout << endl;
     //*/

    if (env->num_of_agents <= 500) // 小算例直接算
    {
        for (int t_id : env->new_tasks)
        {
            int pickup_loc = env->task_pool[t_id].locations[0];
            int pickup_loc_x = pickup_loc % env->cols;
            int pickup_loc_y = pickup_loc / env->cols;

            int pickup_region_x = pickup_loc_x / small_region_column;
            int pickup_region_y = pickup_loc_y / small_region_row;

            task_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;
        }
    }
    else // 大算例
    {
        if (env->curr_timestep == first_epoch_done_time) // 在first_epoch_done_time计算完此时的free tasks
        {
            for (int t_id : free_tasks)
            {
                int pickup_loc = env->task_pool[t_id].locations[0];
                int pickup_loc_x = pickup_loc % env->cols;
                int pickup_loc_y = pickup_loc / env->cols;

                int pickup_region_x = pickup_loc_x / small_region_column;
                int pickup_region_y = pickup_loc_y / small_region_row;

                task_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;
            }
        }
        else // first_epoch_done_time之后就只计算新任务
        {
            for (int t_id : env->new_tasks)
            {
                int pickup_loc = env->task_pool[t_id].locations[0];
                int pickup_loc_x = pickup_loc % env->cols;
                int pickup_loc_y = pickup_loc / env->cols;

                int pickup_region_x = pickup_loc_x / small_region_column;
                int pickup_region_y = pickup_loc_y / small_region_row;

                task_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;
            }
        }
    }

    // cout << 5036 << endl;

    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            // check for timeout every 10 task evaluations
            if (std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            vector<int> agent_pickup_delivery_crossed_regions;
            for (int loc : env->task_pool[t_id].locations)
            {
                dist += DefaultPlanner::get_h(env, c_loc, loc);

                // 获取连线经过的单元格
                vector<Point> crossed_cells = get_line_crossed_cell(c_loc, loc);

                // 计算经过的区域
                vector<int> crossed_regions = get_line_crossed_regions(crossed_cells);

                // 拼接到总区域里
                if (agent_pickup_delivery_crossed_regions.empty())
                {
                    agent_pickup_delivery_crossed_regions = crossed_regions;
                }
                else
                {
                    // 检查 B 是否至少有两个元素
                    if (crossed_regions.size() > 1)
                    {
                        // 将 B 的第一个元素去掉后的部分拼接到 A 的尾部
                        agent_pickup_delivery_crossed_regions.insert(agent_pickup_delivery_crossed_regions.end(),
                            crossed_regions.begin() + 1, crossed_regions.end());
                    }
                }

                c_loc = loc;
            }

            // cout << "from " << env->curr_states.at(i).location << " to " << env->task_pool[t_id].locations[0] << endl;

            // int temp_start = env->curr_states.at(i).location;
            // int temp_goal = env->task_pool[t_id].locations[0];

            // cout << "temp start " << temp_start << endl;
            // cout << "temp goal " << temp_goal << endl;

            // 获取连线经过的单元格
            // vector<Point> to_pickup_crossed_cells = get_line_crossed_cell(temp_start, temp_goal);

            // 计算经过的区域
            // vector<int> to_pickup_crossed_regions = get_line_crossed_regions(to_pickup_crossed_cells);

            /*
            std::cout << "agent pickup crossed regions: ";
            for (int r : to_pickup_crossed_regions) {
                std::cout << r << " ";
            }
            std::cout << std::endl;

            std::cout << "agent pickup delivery crossed regions: ";
            for (int r : agent_pickup_delivery_crossed_regions) {
                std::cout << r << " ";
            }
            std::cout << std::endl;
            //*/

            /*
            int curr_loc_x = temp_start % env->cols;
            int curr_loc_y = temp_goal / env->cols;

            int curr_region_x = curr_loc_x / small_region_column;
            int curr_region_y = curr_loc_y / small_region_row;

            auto verified_curr_region = curr_region_y * num_small_region_column + curr_region_x;

            cout << "verified start region: " << verified_curr_region << endl;

            int pickup_loc_x = temp_goal % env->cols;
            int pickup_loc_y = temp_goal / env->cols;

            int pickup_region_x = pickup_loc_x / small_region_column;
            int pickup_region_y = pickup_loc_y / small_region_row;

            auto verified_pickup_region = pickup_region_y * num_small_region_column + pickup_region_x;

            cout << "verified pickup region: " << verified_pickup_region << endl;
            cout << "pickup region: " << task_region[t_id] << endl;
            //*/

            // int old_sum_jam_weight = region_agent_num[task_region[t_id]];
            // cout << "pickup sum jam weight: " << old_sum_jam_weight << endl;

            double sum_density = 0;
            double weight = 1;
            double common_ratio = 0.8;
            double sum_weight = 0;
            for (auto crossed_region : agent_pickup_delivery_crossed_regions)
            {
                if (small_region_blank_num[crossed_region] != 0)
                {
                    // agent-pickup经过区域的算术平均密度
                    sum_density += (small_region_wait_num[crossed_region] * weight) / small_region_blank_num[crossed_region];

                    sum_weight += weight;
                    weight *= common_ratio;
                }
            }

            int curr_loc = env->curr_states.at(i).location;
            int pickup_loc = env->task_pool[t_id].locations[0];
            double sum_jam_weight = (sum_density / sum_weight) * DefaultPlanner::get_h(env, curr_loc, pickup_loc);
            // cout << "sum jam weight: " << sum_jam_weight << endl;

            // sum_jam_weight * jam_coefficient = estimated delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic) {
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1) {
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
        // nothing to assign
        else {
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Task Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 1.3: 用地图以12x12方形分割区域, task pickup区域中agent时间平均等待点的数量作为jam
void TaskScheduler::adaptive_jam_task_pickup_region_count_average_wait(int time_limit, std::vector<int>& proposed_schedule)
{
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    if (free_agents.size() > 50)
    {
        if (first_epoch_done_time == -1)
        {
            // 由于大算例初始任务过多, 在初始任务分配完成前采用默认算法
            greedy_sum_without_newtask(time_limit, proposed_schedule);
            return;
        }
    }
    else
    {
        if (first_epoch_done_time == -1)
        {
            first_epoch_done_time = env->curr_timestep; // 初始阶段的任务分配完毕的时间
        }
    }

    // 将map分为若干区域, 统计每个区域历史agent wait的数量
    for (int i = 0; i < env->num_of_agents; i++)
    {
        if (env->curr_states.at(i).location == prev_states[i].location
            // && env->curr_states.at(i).orientation == prev_states[i].orientation
            )
        {
            int agent_loc = env->curr_states.at(i).location;
            int agent_loc_x = agent_loc % env->cols;
            int agent_loc_y = agent_loc / env->cols;

            int agent_region_x = agent_loc_x / small_region_column;
            int agent_region_y = agent_loc_y / small_region_row;

            small_region_wait_num[agent_region_y * num_small_region_column + agent_region_x]++;
        }        
    }

    /*
    cout << "region agent num: ";
    for(int i : region_agent_num)
    {
        cout << i << " ";
    }
    cout << endl;
     //*/

    if (env->num_of_agents <= 500) // 小算例直接算
    {
        for (int t_id : env->new_tasks)
        {
            int pickup_loc = env->task_pool[t_id].locations[0];
            int pickup_loc_x = pickup_loc % env->cols;
            int pickup_loc_y = pickup_loc / env->cols;

            int pickup_region_x = pickup_loc_x / small_region_column;
            int pickup_region_y = pickup_loc_y / small_region_row;

            task_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;
        }
    }
    else // 大算例
    {
        if (env->curr_timestep == first_epoch_done_time) // 在first_epoch_done_time计算完此时的free tasks
        {
            for (int t_id : free_tasks)
            {
                int pickup_loc = env->task_pool[t_id].locations[0];
                int pickup_loc_x = pickup_loc % env->cols;
                int pickup_loc_y = pickup_loc / env->cols;

                int pickup_region_x = pickup_loc_x / small_region_column;
                int pickup_region_y = pickup_loc_y / small_region_row;

                task_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;
            }
        }
        else // first_epoch_done_time之后就只计算新任务
        {
            for (int t_id : env->new_tasks)
            {
                int pickup_loc = env->task_pool[t_id].locations[0];
                int pickup_loc_x = pickup_loc % env->cols;
                int pickup_loc_y = pickup_loc / env->cols;

                int pickup_region_x = pickup_loc_x / small_region_column;
                int pickup_region_y = pickup_loc_y / small_region_row;

                task_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;
            }
        }
    }


    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            // check for timeout every 10 task evaluations
            if (std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations) {
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            int pickup_loc = env->task_pool[t_id].locations[0];
            // 因为region_wait_num统计的是所有时间, 所以这里需要求数量的时间平均值
            // cout << "region wait num: " << small_region_wait_num[task_region[t_id]] << endl;
            double sum_jam_weight = (double) small_region_wait_num[task_region[t_id]] / (env->curr_timestep + 1);

            // sum_jam_weight * jam_coefficient = estimated delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic) {
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1) {
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
        // nothing to assign
        else {
            proposed_schedule[i] = -1;
            it++;
        }
    }

    prev_states = env->curr_states; // 更新prev states for all agents

    cout << "Task Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 1.3.1: 用地图以12x12方形分割区域, task pickup区域中agent时间平均等待点的密度作为jam
void TaskScheduler::adaptive_jam_task_pickup_region_average_wait_density(int time_limit, std::vector<int>& proposed_schedule)
{
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    if (free_agents.size() > 50)
    {
        if (first_epoch_done_time == -1)
        {
            // 由于大算例初始任务过多, 在初始任务分配完成前采用默认算法
            greedy_sum_without_newtask(time_limit, proposed_schedule);
            return;
        }
    }
    else
    {
        if (first_epoch_done_time == -1)
        {
            first_epoch_done_time = env->curr_timestep; // 初始阶段的任务分配完毕的时间
        }
    }

    // 将map分为若干区域, 统计每个区域历史agent wait的数量
    for (int i = 0; i < env->num_of_agents; i++)
    {
        // 如果和前一时刻位置和方向一样, 则陷入堵车
        // 后面可以尝试去掉方向一样的限定
        if (env->curr_states.at(i).location == prev_states[i].location
            && env->curr_states.at(i).orientation == prev_states[i].orientation)
        {
            int agent_loc = env->curr_states.at(i).location;
            int agent_loc_x = agent_loc % env->cols;
            int agent_loc_y = agent_loc / env->cols;

            int agent_region_x = agent_loc_x / small_region_column;
            int agent_region_y = agent_loc_y / small_region_row;

            small_region_wait_num[agent_region_y * num_small_region_column + agent_region_x]++;
        }
    }

    /*
    cout << "region agent num: ";
    for(int i : region_agent_num)
    {
        cout << i << " ";
    }
    cout << endl;
     //*/

    if (env->num_of_agents <= 500) // 小算例直接算
    {
        for (int t_id : env->new_tasks)
        {
            int pickup_loc = env->task_pool[t_id].locations[0];
            int pickup_loc_x = pickup_loc % env->cols;
            int pickup_loc_y = pickup_loc / env->cols;

            int pickup_region_x = pickup_loc_x / small_region_column;
            int pickup_region_y = pickup_loc_y / small_region_row;

            task_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;
        }
    }
    else // 大算例
    {
        if (env->curr_timestep == first_epoch_done_time) // 在first_epoch_done_time计算完此时的free tasks
        {
            for (int t_id : free_tasks)
            {
                int pickup_loc = env->task_pool[t_id].locations[0];
                int pickup_loc_x = pickup_loc % env->cols;
                int pickup_loc_y = pickup_loc / env->cols;

                int pickup_region_x = pickup_loc_x / small_region_column;
                int pickup_region_y = pickup_loc_y / small_region_row;

                task_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;
            }
        }
        else // first_epoch_done_time之后就只计算新任务
        {
            for (int t_id : env->new_tasks)
            {
                int pickup_loc = env->task_pool[t_id].locations[0];
                int pickup_loc_x = pickup_loc % env->cols;
                int pickup_loc_y = pickup_loc / env->cols;

                int pickup_region_x = pickup_loc_x / small_region_column;
                int pickup_region_y = pickup_loc_y / small_region_row;

                task_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;
            }
        }
    }


    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            // check for timeout every 10 task evaluations
            if (std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations) {
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            int pickup_loc = env->task_pool[t_id].locations[0];
            // 因为region_wait_num统计的是所有时间, 所以这里需要求数量的时间平均值
            // cout << "region wait num: " << small_region_wait_num[task_region[t_id]] << endl;
            double sum_jam_weight = (double)small_region_wait_num[task_region[t_id]] / (small_region_blank_num[task_region[t_id]] * env->curr_timestep + 1);

            // sum_jam_weight * jam_coefficient = estimated delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic) {
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1) {
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
        // nothing to assign
        else {
            proposed_schedule[i] = -1;
            it++;
        }
    }

    prev_states = env->curr_states; // 更新prev states for all agents

    cout << "Task Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 1.3.2: 将地图分成12x12的区域, task pickup区域中时间窗agent等待点的数量作为sum jam weight
void TaskScheduler::adaptive_jam_task_pickup_region_count_time_window_wait(int time_limit, std::vector<int>& proposed_schedule)
{
    cout << "adaptive jam task pickup region time window count wait" << endl;
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    if (free_agents.size() > 50)
    {
        if (first_epoch_done_time == -1)
        {
            // 由于大算例初始任务过多, 在初始任务分配完成前采用默认算法
            greedy_sum_without_newtask(time_limit, proposed_schedule);
            return;
        }
    }
    else
    {
        if (first_epoch_done_time == -1)
        {
            first_epoch_done_time = env->curr_timestep; // 初始阶段的任务分配完毕的时间
        }
    }

    // 将map分为若干区域, 统计每个区域时间窗agent wait的数量
    vector<int> current_region_wait_num(small_region_wait_num.size(), 0);
    for (int i = 0; i < env->num_of_agents; i++)
    {
        // 如果和前一时刻位置和方向一样, 则陷入堵车
        if (env->curr_states.at(i).location == prev_states[i].location
            && env->curr_states.at(i).orientation == prev_states[i].orientation)
        {
            int agent_loc = env->curr_states.at(i).location;
            int agent_loc_x = agent_loc % env->cols;
            int agent_loc_y = agent_loc / env->cols;

            int agent_region_x = agent_loc_x / small_region_column;
            int agent_region_y = agent_loc_y / small_region_row;

            int agent_region_index = agent_region_y * num_small_region_column + agent_region_x;
            small_region_wait_num[agent_region_index]++;
            current_region_wait_num[agent_region_index]++;
        }
    }

    auto removed_region_wait_num = period_small_region_wait_num.push(current_region_wait_num); // 添加元素，可能移除旧元素
    if (!removed_region_wait_num.empty())
    {
        // cout << "removed previous region agent num: ";
        for (int i = 0; i < removed_region_wait_num.size(); i++)
        {
            // cout << removed_small_region_wait_num[i] << " ";
            small_region_wait_num[i] -= removed_region_wait_num[i];
        }
        // cout << endl;
    }

    /*
    cout << "history total region agent num: ";
    for(int i : small_region_wait_num)
    {
        cout << i << " ";
    }
    cout << endl;
    cout << "current region agent num: ";
    for (int i : current_small_region_wait_num)
    {
        cout << i << " ";
    }
    cout << endl;
     //*/

    if (env->curr_timestep == first_epoch_done_time) // 在first_epoch_done_time计算完此时的free tasks
    {
        for (int t_id : free_tasks)
        {
            int pickup_loc = env->task_pool[t_id].locations[0];
            int pickup_loc_x = pickup_loc % env->cols;
            int pickup_loc_y = pickup_loc / env->cols;

            int pickup_region_x = pickup_loc_x / small_region_column;
            int pickup_region_y = pickup_loc_y / small_region_row;

            task_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;
        }
    }
    else // first_epoch_done_time之后就只计算新任务
    {
        for (int t_id : env->new_tasks)
        {
            int pickup_loc = env->task_pool[t_id].locations[0];
            int pickup_loc_x = pickup_loc % env->cols;
            int pickup_loc_y = pickup_loc / env->cols;

            int pickup_region_x = pickup_loc_x / small_region_column;
            int pickup_region_y = pickup_loc_y / small_region_row;

            task_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;
        }
    }


    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            // check for timeout every 10 task evaluations
            if (std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations) {
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            int pickup_loc = env->task_pool[t_id].locations[0];
            // 因为region_wait_num统计的是所有时间, 所以这里需要求数量的时间平均值
            // cout << "region wait num: " << small_region_wait_num[task_region[t_id]] << endl;
            int sum_jam_weight = small_region_wait_num[task_region[t_id]];
            // double sum_jam_weight = (double)small_region_wait_num[task_region[t_id]] / (small_region_blank_num[task_region[t_id]] * env->curr_timestep + 1);

            // sum_jam_weight * jam_coefficient = estimated delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic) {
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1) {
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
        // nothing to assign
        else {
            proposed_schedule[i] = -1;
            it++;
        }
    }

    prev_states = env->curr_states; // 更新prev states for all agents

    cout << "Task Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 1.4: 用地图以8x8方形分割区域, task delivery区域中agent等待点的数量作为jam
void TaskScheduler::adaptive_jam_task_delivery_region_count_average_wait(int time_limit, std::vector<int>& proposed_schedule)
{
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    if (free_agents.size() > 50)
    {
        if (first_epoch_done_time == -1)
        {
            // 由于大算例初始任务过多, 在初始任务分配完成前采用默认算法
            greedy_sum_without_newtask(time_limit, proposed_schedule);
            return;
        }
    }
    else
    {
        if (first_epoch_done_time == -1)
        {
            first_epoch_done_time = env->curr_timestep; // 初始阶段的任务分配完毕的时间
        }
    }

    // 将map分为若干区域, 统计每个区域历史agent wait的数量
    for (int i = 0; i < env->num_of_agents; i++)
    {
        if (env->curr_states.at(i).location == prev_states[i].location
            && env->curr_states.at(i).orientation == prev_states[i].orientation)
        {
            int agent_loc = env->curr_states.at(i).location;
            int agent_loc_x = agent_loc % env->cols;
            int agent_loc_y = agent_loc / env->cols;

            int agent_region_x = agent_loc_x / small_region_column;
            int agent_region_y = agent_loc_y / small_region_row;

            small_region_wait_num[agent_region_y * num_small_region_column + agent_region_x]++;
        }
    }

    /*
    cout << "region agent num: ";
    for(int i : region_agent_num)
    {
        cout << i << " ";
    }
    cout << endl;
     //*/

    if (env->num_of_agents <= 500) // 小算例直接算
    {
        for (int t_id : env->new_tasks)
        {
            int delivery_loc = env->task_pool[t_id].locations[1];
            int delivery_loc_x = delivery_loc % env->cols;
            int delivery_loc_y = delivery_loc / env->cols;

            int delivery_region_x = delivery_loc_x / small_region_column;
            int delivery_region_y = delivery_loc_y / small_region_row;

            task_region[t_id] = delivery_region_y * num_small_region_column + delivery_region_x;
        }
    }
    else // 大算例
    {
        if (env->curr_timestep == first_epoch_done_time) // 在first_epoch_done_time计算完此时的free tasks
        {
            for (int t_id : free_tasks)
            {
                int delivery_loc = env->task_pool[t_id].locations[1];
                int delivery_loc_x = delivery_loc % env->cols;
                int delivery_loc_y = delivery_loc / env->cols;

                int delivery_region_x = delivery_loc_x / small_region_column;
                int delivery_region_y = delivery_loc_y / small_region_row;

                task_region[t_id] = delivery_region_y * num_small_region_column + delivery_region_x;
            }
        }
        else // first_epoch_done_time之后就只计算新任务
        {
            for (int t_id : env->new_tasks)
            {
                int delivery_loc = env->task_pool[t_id].locations[1];
                int delivery_loc_x = delivery_loc % env->cols;
                int delivery_loc_y = delivery_loc / env->cols;

                int delivery_region_x = delivery_loc_x / small_region_column;
                int delivery_region_y = delivery_loc_y / small_region_row;

                task_region[t_id] = delivery_region_y * num_small_region_column + delivery_region_x;
            }
        }
    }


    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            // check for timeout every 10 task evaluations
            if (std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations) {
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            int delivery_loc = env->task_pool[t_id].locations[1];
            double sum_jam_weight = (double) small_region_wait_num[task_region[t_id]] / (env->curr_timestep + 1);

            // sum_jam_weight * jam_coefficient = estimated delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic) {
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1) {
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
        // nothing to assign
        else {
            proposed_schedule[i] = -1;
            it++;
        }
    }

    prev_states = env->curr_states; // 更新prev states for all agents

    cout << "Task Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 1.4.1: 将地图分成12x12的区域, task delivery区域中时间窗agent等待点的数量作为sum jam weight
void TaskScheduler::adaptive_jam_task_delivery_region_count_time_window_wait(int time_limit, std::vector<int>& proposed_schedule)
{
    cout << "adaptive jam task pickup region time window count wait" << endl;
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    if (free_agents.size() > 50)
    {
        if (first_epoch_done_time == -1)
        {
            // 由于大算例初始任务过多, 在初始任务分配完成前采用默认算法
            greedy_sum_without_newtask(time_limit, proposed_schedule);
            return;
        }
    }
    else
    {
        if (first_epoch_done_time == -1)
        {
            first_epoch_done_time = env->curr_timestep; // 初始阶段的任务分配完毕的时间
        }
    }

    // 将map分为若干区域, 统计每个区域时间窗agent wait的数量
    vector<int> current_region_wait_num(small_region_wait_num.size(), 0);
    for (int i = 0; i < env->num_of_agents; i++)
    {
        // 如果和前一时刻位置和方向一样, 则陷入堵车
        if (env->curr_states.at(i).location == prev_states[i].location
            && env->curr_states.at(i).orientation == prev_states[i].orientation)
        {
            int agent_loc = env->curr_states.at(i).location;
            int agent_loc_x = agent_loc % env->cols;
            int agent_loc_y = agent_loc / env->cols;

            int agent_region_x = agent_loc_x / small_region_column;
            int agent_region_y = agent_loc_y / small_region_row;

            int agent_region_index = agent_region_y * num_small_region_column + agent_region_x;
            small_region_wait_num[agent_region_index]++;
            current_region_wait_num[agent_region_index]++;
        }
    }

    auto removed_region_wait_num = period_small_region_wait_num.push(current_region_wait_num); // 添加元素，可能移除旧元素
    if (!removed_region_wait_num.empty())
    {
        // cout << "removed previous region agent num: ";
        for (int i = 0; i < removed_region_wait_num.size(); i++)
        {
            // cout << removed_small_region_wait_num[i] << " ";
            small_region_wait_num[i] -= removed_region_wait_num[i];
        }
        // cout << endl;
    }

    /*
    cout << "history total region agent num: ";
    for(int i : small_region_wait_num)
    {
        cout << i << " ";
    }
    cout << endl;
    cout << "current region agent num: ";
    for (int i : current_small_region_wait_num)
    {
        cout << i << " ";
    }
    cout << endl;
     //*/

    // 计算free tasks的delivery位置所属的region
    if (env->curr_timestep == first_epoch_done_time) // 在first_epoch_done_time计算完此时的free tasks
    {
        for (int t_id : free_tasks)
        {
            int delivery_loc = env->task_pool[t_id].locations[1];
            int delivery_loc_x = delivery_loc % env->cols;
            int delivery_loc_y = delivery_loc / env->cols;

            int delivery_region_x = delivery_loc_x / small_region_column;
            int delivery_region_y = delivery_loc_y / small_region_row;

            task_region[t_id] = delivery_region_y * num_small_region_column + delivery_region_x;
        }
    }
    else // first_epoch_done_time之后就只计算新任务
    {
        for (int t_id : env->new_tasks)
        {
            int delivery_loc = env->task_pool[t_id].locations[1];
            int delivery_loc_x = delivery_loc % env->cols;
            int delivery_loc_y = delivery_loc / env->cols;

            int delivery_region_x = delivery_loc_x / small_region_column;
            int delivery_region_y = delivery_loc_y / small_region_row;

            task_region[t_id] = delivery_region_y * num_small_region_column + delivery_region_x;
        }
    }


    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            // check for timeout every 10 task evaluations
            if (std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations) {
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            int pickup_loc = env->task_pool[t_id].locations[0];
            // 因为region_wait_num统计的是所有时间, 所以这里需要求数量的时间平均值
            // cout << "region wait num: " << small_region_wait_num[task_region[t_id]] << endl;
            int sum_jam_weight = small_region_wait_num[task_region[t_id]];
            // double sum_jam_weight = (double)small_region_wait_num[task_region[t_id]] / (small_region_blank_num[task_region[t_id]] * env->curr_timestep + 1);

            // sum_jam_weight * jam_coefficient = estimated delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic) {
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1) {
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
        // nothing to assign
        else {
            proposed_schedule[i] = -1;
            it++;
        }
    }

    prev_states = env->curr_states; // 更新prev states for all agents

    cout << "Task Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 1.5: 用地图以8x8方形分割区域, task errand区域中agent等待点的数量作为jam
void TaskScheduler::adaptive_jam_task_errand_region_count_average_wait(int time_limit, std::vector<int>& proposed_schedule)
{
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    if (free_agents.size() > 50)
    {
        if (first_epoch_done_time == -1)
        {
            // 由于大算例初始任务过多, 在初始任务分配完成前采用默认算法
            greedy_sum_without_newtask(time_limit, proposed_schedule);
            return;
        }
    }
    else
    {
        if (first_epoch_done_time == -1)
        {
            first_epoch_done_time = env->curr_timestep; // 初始阶段的任务分配完毕的时间
        }
    }

    // 将map分为若干区域, 统计每个区域历史agent wait的数量
    for (int i = 0; i < env->num_of_agents; i++)
    {
        if (env->curr_states.at(i).location == prev_states[i].location
            && env->curr_states.at(i).orientation == prev_states[i].orientation)
        {
            int agent_loc = env->curr_states.at(i).location;
            int agent_loc_x = agent_loc % env->cols;
            int agent_loc_y = agent_loc / env->cols;

            int agent_region_x = agent_loc_x / small_region_column;
            int agent_region_y = agent_loc_y / small_region_row;

            small_region_wait_num[agent_region_y * num_small_region_column + agent_region_x]++;
        }
    }

    /*
    cout << "region agent num: ";
    for(int i : region_agent_num)
    {
        cout << i << " ";
    }
    cout << endl;
     //*/

    if (env->num_of_agents <= 500) // 小算例直接算
    {
        for (int t_id : env->new_tasks)
        {
            vector<int> errand_regions;
            for (auto errand_loc : env->task_pool[t_id].locations)
            {
                int errand_loc_x = errand_loc % env->cols;
                int errand_loc_y = errand_loc / env->cols;

                int errand_region_x = errand_loc_x / small_region_column;
                int errand_region_y = errand_loc_y / small_region_row;

                errand_regions.emplace_back(errand_region_y * num_small_region_column + errand_region_x);
            }

            task_errand_region[t_id] = errand_regions;
        }
    }
    else // 大算例
    {
        if (env->curr_timestep == first_epoch_done_time) // 在first_epoch_done_time计算完此时的free tasks
        {
            for (int t_id : free_tasks)
            {
                vector<int> errand_regions;
                for (auto errand_loc : env->task_pool[t_id].locations)
                {
                    int errand_loc_x = errand_loc % env->cols;
                    int errand_loc_y = errand_loc / env->cols;

                    int errand_region_x = errand_loc_x / small_region_column;
                    int errand_region_y = errand_loc_y / small_region_row;

                    errand_regions.emplace_back(errand_region_y * num_small_region_column + errand_region_x);
                }  

                task_errand_region[t_id] = errand_regions;
            }
        }
        else // first_epoch_done_time之后就只计算新任务
        {
            for (int t_id : env->new_tasks)
            {
                vector<int> errand_regions;
                for (auto errand_loc : env->task_pool[t_id].locations)
                {
                    int errand_loc_x = errand_loc % env->cols;
                    int errand_loc_y = errand_loc / env->cols;

                    int errand_region_x = errand_loc_x / small_region_column;
                    int errand_region_y = errand_loc_y / small_region_row;

                    errand_regions.emplace_back(errand_region_y * num_small_region_column + errand_region_x);
                }

                task_errand_region[t_id] = errand_regions;
            }
        }
    }


    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            // check for timeout every 10 task evaluations
            if (std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int errand_loc : env->task_pool[t_id].locations) {
                dist += DefaultPlanner::get_h(env, c_loc, errand_loc);
                c_loc = errand_loc;
            }

            double sum_jam_weight = 0;
            for (auto errand_region : task_errand_region[t_id])
            {
                sum_jam_weight += (double)small_region_wait_num[errand_region] / (env->curr_timestep + 1);
            }

            // sum_jam_weight * jam_coefficient = estimated delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic) {
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1) {
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
        // nothing to assign
        else {
            proposed_schedule[i] = -1;
            it++;
        }
    }

    prev_states = env->curr_states; // 更新prev states for all agents

    cout << "Task Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 1.5.1: 用地图以8x8方形分割区域, task errand区域中agent等待点的数量作为jam
void TaskScheduler::adaptive_jam_task_errand_region_count_time_window_wait(int time_limit, std::vector<int>& proposed_schedule)
{
    cout << "adaptive jam task errand region time window count wait" << endl;
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    if (free_agents.size() > 50)
    {
        if (first_epoch_done_time == -1)
        {
            // 由于大算例初始任务过多, 在初始任务分配完成前采用默认算法
            greedy_sum_without_newtask(time_limit, proposed_schedule);
            return;
        }
    }
    else
    {
        if (first_epoch_done_time == -1)
        {
            first_epoch_done_time = env->curr_timestep; // 初始阶段的任务分配完毕的时间
        }
    }

    // Step 1: 将map分为若干区域, 统计每个区域时间窗agent wait的数量
    // 如果不是count current, small_region_wait_num[]就不应该清空
    vector<int> current_region_wait_num(small_region_wait_num.size(), 0);
    for (int i = 0; i < env->num_of_agents; i++)
    {
        // 如果和前一时刻位置和方向一样, 则陷入堵车
        if (env->curr_states.at(i).location == prev_states[i].location
            && env->curr_states.at(i).orientation == prev_states[i].orientation)
        {
            int agent_loc = env->curr_states.at(i).location;
            int agent_loc_x = agent_loc % env->cols;
            int agent_loc_y = agent_loc / env->cols;

            int agent_region_x = agent_loc_x / small_region_column;
            int agent_region_y = agent_loc_y / small_region_row;

            int agent_region_index = agent_region_y * num_small_region_column + agent_region_x;
            small_region_wait_num[agent_region_index]++;
            current_region_wait_num[agent_region_index]++;
        }
    }

    auto removed_region_wait_num = period_small_region_wait_num.push(current_region_wait_num); // 添加元素，可能移除旧元素
    if (!removed_region_wait_num.empty())
    {
        // cout << "removed previous region agent num: ";
        for (int i = 0; i < removed_region_wait_num.size(); i++)
        {
            // cout << removed_small_region_wait_num[i] << " ";
            small_region_wait_num[i] -= removed_region_wait_num[i];
        }
        // cout << endl;
    }

    /*
    cout << "history total region agent num: ";
    for(int i : small_region_wait_num)
    {
        cout << i << " ";
    }
    cout << endl;
    cout << "current region agent num: ";
    for (int i : current_small_region_wait_num)
    {
        cout << i << " ";
    }
    cout << endl;
     //*/

    // Step 2: 计算task每个errand点所在区域
    if (env->curr_timestep == first_epoch_done_time) // 在first_epoch_done_time计算完此时的free tasks
    {
        for (int t_id : free_tasks)
        {
            vector<int> errand_regions;
            for (auto errand_loc : env->task_pool[t_id].locations)
            {
                int errand_loc_x = errand_loc % env->cols;
                int errand_loc_y = errand_loc / env->cols;

                int errand_region_x = errand_loc_x / small_region_column;
                int errand_region_y = errand_loc_y / small_region_row;

                int region_id = errand_region_y * num_small_region_column + errand_region_x;

                // 如果 errand_regions 为空或末尾元素与当前计算的 region_id 不相同，则添加
                if (errand_regions.empty() || errand_regions.back() != region_id)
                {
                    errand_regions.emplace_back(region_id);
                }
            }

            task_errand_region[t_id] = errand_regions;
        }
    }
    else // first_epoch_done_time之后就只计算新任务
    {
        for (int t_id : env->new_tasks)
        {
            vector<int> errand_regions;
            for (auto errand_loc : env->task_pool[t_id].locations)
            {
                int errand_loc_x = errand_loc % env->cols;
                int errand_loc_y = errand_loc / env->cols;

                int errand_region_x = errand_loc_x / small_region_column;
                int errand_region_y = errand_loc_y / small_region_row;

                int region_id = errand_region_y * num_small_region_column + errand_region_x;

                // 如果 errand_regions 为空或末尾元素与当前计算的 region_id 不相同，则添加
                if (errand_regions.empty() || errand_regions.back() != region_id)
                {
                    errand_regions.emplace_back(region_id);
                }
            }

            task_errand_region[t_id] = errand_regions;
        }
    }

    // 遍历并输出
    /*
    for (const auto& pair : task_errand_region) {
        std::cout << "Task ID: " << pair.first << " -> Errand Regions: ";
        for (const int& errand : pair.second) {
            std::cout << errand << " ";
        }
        std::cout << std::endl;
    }
    //*/

    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            // check for timeout every 10 task evaluations
            if (std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations) {
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            // Step 3: 根据task所属区域估计执行成本。
            int sum_jam_weight = 0;

            if (task_errand_region[t_id].size() == 1)
            {
                sum_jam_weight += small_region_wait_num[task_errand_region[t_id][0]];
            }
            else
            {
                for (int i = 0; i < task_errand_region[t_id].size() - 1; i++)
                {
                    sum_jam_weight += small_region_wait_num[task_errand_region[t_id][i]];
                }

                sum_jam_weight += small_region_wait_num[task_errand_region[t_id].back()] / 2;
            }

            // cout << "this step weight: " << current_small_region_wait_num[task_errand_region[t_id][0]] << endl;
            // cout << "sam jam weight: " << sum_jam_weight << endl;
            
            // sum_jam_weight * jam_coefficient = estimated delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic) {
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1) {
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
        // nothing to assign
        else {
            proposed_schedule[i] = -1;
            it++;
        }
    }

    prev_states = env->curr_states; // 更新prev states for all agents

    cout << "Task Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 1.5.2: 用地图以12x12方形分割区域, task所在区域中agent的数量作为jam
void TaskScheduler::adaptive_jam_task_errand_region_count_current(int time_limit, std::vector<int>& proposed_schedule)
{
    cout << "adaptive jam task errand region count current" << endl;
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    if (free_agents.size() > 50)
    {
        if (first_epoch_done_time == -1)
        {
            // 由于大算例初始任务过多, 在初始任务分配完成前采用默认算法
            greedy_sum_without_newtask(time_limit, proposed_schedule);
            return;
        }
    }
    else
    {
        if (first_epoch_done_time == -1)
        {
            first_epoch_done_time = env->curr_timestep; // 初始阶段的任务分配完毕的时间
        }
    }

    small_region_wait_num.assign(small_region_wait_num.size(), 0); // 每次清空

    for (int i = 0; i < env->num_of_agents; i++)
    {
        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;

        int agent_region_x = agent_loc_x / small_region_column;
        int agent_region_y = agent_loc_y / small_region_row;

        small_region_wait_num[agent_region_y * num_small_region_column + agent_region_x]++;
    }

    /*
    cout << "region agent num: ";
    for(int i : small_region_wait_num)
    {
        cout << i << " ";
    }
    cout << endl;
     //*/


    if (env->curr_timestep == first_epoch_done_time) // 在first_epoch_done_time计算完此时的free tasks
    {
        for (int t_id : free_tasks)
        {
            vector<int> errand_regions;
            for (auto errand_loc : env->task_pool[t_id].locations)
            {
                int errand_loc_x = errand_loc % env->cols;
                int errand_loc_y = errand_loc / env->cols;

                int errand_region_x = errand_loc_x / small_region_column;
                int errand_region_y = errand_loc_y / small_region_row;

                int region_id = errand_region_y * num_small_region_column + errand_region_x;

                // 如果 errand_regions 为空或末尾元素与当前计算的 region_id 不相同，则添加
                if (errand_regions.empty() || errand_regions.back() != region_id)
                {
                    errand_regions.emplace_back(region_id);
                }
            }

            task_errand_region[t_id] = errand_regions;
        }
    }
    else // first_epoch_done_time之后就只计算新任务
    {
        for (int t_id : env->new_tasks)
        {
            vector<int> errand_regions;
            for (auto errand_loc : env->task_pool[t_id].locations)
            {
                int errand_loc_x = errand_loc % env->cols;
                int errand_loc_y = errand_loc / env->cols;

                int errand_region_x = errand_loc_x / small_region_column;
                int errand_region_y = errand_loc_y / small_region_row;

                int region_id = errand_region_y * num_small_region_column + errand_region_x;

                // 如果 errand_regions 为空或末尾元素与当前计算的 region_id 不相同，则添加
                if (errand_regions.empty() || errand_regions.back() != region_id)
                {
                    errand_regions.emplace_back(region_id);
                }
            }

            task_errand_region[t_id] = errand_regions;
        }
    }

    // 遍历并输出
    /*
    for (const auto& pair : task_errand_region) {
        std::cout << "Task ID: " << pair.first << " -> Errand Regions: ";
        for (const int& errand : pair.second) {
            std::cout << errand << " ";
        }
        std::cout << std::endl;
    }
    //*/

    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            // check for timeout every 10 task evaluations
            if (std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int errand_loc : env->task_pool[t_id].locations) {
                dist += DefaultPlanner::get_h(env, c_loc, errand_loc);
                c_loc = errand_loc;
            }

            int sum_jam_weight = 0;

            if (task_errand_region[t_id].size() == 1)
            {
                sum_jam_weight += small_region_wait_num[task_errand_region[t_id][0]];
            }
            else
            {
                for (int i = 0; i < task_errand_region[t_id].size() - 1; i++)
                {
                    sum_jam_weight += small_region_wait_num[task_errand_region[t_id][i]];
                }

                sum_jam_weight += small_region_wait_num[task_errand_region[t_id].back()] / 2;
            }
            
            // cout << "sam jam weight: " << sum_jam_weight << endl;

            // sum_jam_weight * jam_coefficient = estimated delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic) {
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1) {
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
        // nothing to assign
        else {
            proposed_schedule[i] = -1;
            it++;
        }
    }

    prev_states = env->curr_states; // 更新prev states for all agents

    cout << "Task Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 统计以agent-task中点为圆心，|agent-task|/2为半径的圆中other agent的数量作为jam。
void TaskScheduler::adaptive_jam_middle_circle_count_current(int time_limit, std::vector<int> & proposed_schedule)
{
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for(auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                 << " minDist " << agent_task[element].min_task_dist
                 << " heuristic " << agent_task[element].task_heuristic
                 << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                 << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if(numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;
        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            //check for timeout every 10 task evaluations
            if (std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            int sum_jam_weight = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations){
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            /*
            if(OneDim2TwoDim.find(env->task_pool[t_id].locations[0]) == OneDim2TwoDim.end())
            {
                cerr << "map error!" << endl;
            }
            */

            int pickup_loc = env->task_pool[t_id].locations[0];
            int pickup_loc_x = env->task_pool[t_id].locations[0] % env->cols;
            int pickup_loc_y = env->task_pool[t_id].locations[0] / env->cols;
            // cout << "pickup loc " << pickup_twodim.x << " " << pickup_twodim.y << endl;

            int middle_loc_x = (agent_loc_x + pickup_loc_x) / 2;
            int middle_loc_y = (agent_loc_y + pickup_loc_y) / 2;

            // 当前agent指向某个agent-task中点的向量
            int agent_middle_direction_x = pickup_loc_x - agent_loc_x;
            int agent_middle_direction_y = pickup_loc_y - agent_loc_y;
            int agent_middle_direction_square = agent_middle_direction_x * agent_middle_direction_x +
                                              agent_middle_direction_y * agent_middle_direction_y;

            for(int j=0;j<env->curr_states.size();j++)
            {
                if (j != i) // 所有agent都会有任务, 所以都要计入
                {
                    int other_agent_loc = env->curr_states.at(j).location;
                    int other_agent_loc_x = other_agent_loc % env->cols;
                    int other_agent_loc_y = other_agent_loc / env->cols;
                    // cout << "other agent loc " << other_agent_loc << " " << other_agent_loc_x << " "
                    // << other_agent_loc_y << endl;

                    int other_middle_direction_x = middle_loc_x - other_agent_loc_x;
                    int other_middle_direction_y = middle_loc_y - other_agent_loc_y;
                    // cout << "other agent direction " << agent_other_direction_x << " " << other_agent_loc_y << endl;
                    int other_middle_distance_square = other_middle_direction_x * other_middle_direction_x
                                                     + other_middle_direction_y * other_middle_direction_y;

                    // 只统计以|agent-task|中点为圆心, |agent-task|为直径范围内的other agent
                    if(other_middle_distance_square < agent_middle_direction_square)
                    {
                        sum_jam_weight++;
                    }
                }
            }

            // sum_jam_weight * jam_coefficient = guess delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic){
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1){
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist  = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
            // nothing to assign
        else{
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Time Usage: " <<  ((float)(clock() - start))/CLOCKS_PER_SEC <<endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: "<< env->new_tasks.size() <<  endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 1.5.3: 将地图进行12x12和16x16两次划分, 统计pickup区域小方块中agent数量与delivery区域大方块中agent数量的加权和
void TaskScheduler::adaptive_jam_count_near_small_current_far_large_current(int time_limit, std::vector<int>& proposed_schedule)
{
    cout << "adaptive jam count small current far large current" << endl;
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    if (free_agents.size() > 50)
    {
        if (first_epoch_done_time == -1)
        {
            // 由于大算例初始任务过多, 在初始任务分配完成前采用默认算法
            greedy_sum_without_newtask(time_limit, proposed_schedule);
            return;
        }
    }
    else
    {
        if (first_epoch_done_time == -1)
        {
            first_epoch_done_time = env->curr_timestep; // 初始阶段的任务分配完毕的时间
        }
    }

    // Step 1: 统计每个区域agent的数量。分别统计小区域和大区域。
    // small_region_wait_num.assign(small_region_wait_num.size(), 0); // 每次清空
    // 在当前时间步, 每个region有多少个agent
    vector<int> current_large_region_agent_num(small_region_wait_num.size(), 0);
    vector<int> current_small_region_agent_num(num_large_region_column * num_large_region_row, 0);

    for (int i = 0; i < env->num_of_agents; i++)
    {        
        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;

        // current large region num
        int agent_region_x = agent_loc_x / small_region_column;
        int agent_region_y = agent_loc_y / small_region_row;

        int agent_region_index = agent_region_y * num_small_region_column + agent_region_x;
        current_large_region_agent_num[agent_region_index]++;

        // current small region num
        int agent_small_region_x = agent_loc_x / large_region_column;
        int agent_small_region_y = agent_loc_y / large_region_row;

        int agent_small_region_index = agent_small_region_y * num_large_region_column + agent_small_region_x;
        current_small_region_agent_num[agent_small_region_index]++;
    }

    /*
    cout << "current large region agent num: ";
    for(int i : current_large_region_agent_num)
    {
        cout << i << " ";
    }
    cout << endl;
    cout << "current small region agent num: ";
    for (int i : current_small_region_agent_num)
    {
        cout << i << " ";
    }
    cout << endl;
     //*/

    // Step 2: 计算每个task归属于哪个区域。pickup属于哪个小区域, delivery属于哪个大区域。
    if (env->curr_timestep == first_epoch_done_time) // 在first_epoch_done_time计算完此时的free tasks
    {
        for (int t_id : free_tasks)
        {
            // delivery (large) region
            int delivery_loc = env->task_pool[t_id].locations[1];
            int delivery_loc_x = delivery_loc % env->cols;
            int delivery_loc_y = delivery_loc / env->cols;

            int delivery_region_x = delivery_loc_x / small_region_column;
            int delivery_region_y = delivery_loc_y / small_region_row;

            task_region[t_id] = delivery_region_y * num_small_region_column + delivery_region_x; // large

            // pickup (small) region
            int pickup_loc = env->task_pool[t_id].locations[0];
            int pickup_loc_x = pickup_loc % env->cols;
            int pickup_loc_y = pickup_loc / env->cols;
            
            int current_pickup_region_x = pickup_loc_x / large_region_column;
            int current_pickup_region_y = pickup_loc_y / large_region_row;

            task_current_region[t_id] = current_pickup_region_y * num_large_region_column + current_pickup_region_x;
        }
    }
    else // first_epoch_done_time之后就只计算新任务
    {
        for (int t_id : env->new_tasks)
        {
            // delivery (large) region
            int delivery_loc = env->task_pool[t_id].locations[1];
            int delivery_loc_x = delivery_loc % env->cols;
            int delivery_loc_y = delivery_loc / env->cols;

            int delivery_region_x = delivery_loc_x / small_region_column;
            int delivery_region_y = delivery_loc_y / small_region_row;

            task_region[t_id] = delivery_region_y * num_small_region_column + delivery_region_x; // large

            // pickup (small) region
            int pickup_loc = env->task_pool[t_id].locations[0];
            int pickup_loc_x = pickup_loc % env->cols;
            int pickup_loc_y = pickup_loc / env->cols;
            
            int current_pickup_region_x = pickup_loc_x / large_region_column;
            int current_pickup_region_y = pickup_loc_y / large_region_row;

            task_current_region[t_id] = current_pickup_region_y * num_large_region_column + current_pickup_region_x;
        }
    }

    // 遍历并输出task所在region
    /*
    // large region
    for (const auto& pair : task_region)
    {
        std::cout << "Task ID: " << pair.first << " -> large Regions: " << pair.second << endl;
    }    
    // small region
    for (const auto& pair : task_current_region)
    {
        std::cout << "Task ID: " << pair.first << " -> small Regions: " << pair.second << endl;
    }    
    //*/

    int min_task_i, dist, c_loc, count;
    clock_t start = clock();
    // cout << "small_region_wait_num size: " << small_region_wait_num.size() << endl;

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            // check for timeout every 10 task evaluations
            if (std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations) {
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            // int pickup_loc = env->task_pool[t_id].locations[0];
            int small_agent_count = current_small_region_agent_num[task_current_region[t_id]];
            int large_agent_count = current_large_region_agent_num[task_region[t_id]];          

            // cout << "task region " << task_region[t_id] << endl;
            // cout << "sum jam weight " << small_region_wait_num[task_region[t_id]] << " " << small_region_blank_num[task_region[t_id]] << endl;
            // cout << "large agent count: " << large_agent_count << endl;
            // cout << "small agent count: " << small_agent_count << endl;
            double short_term_ratio = 0.7;
            double sum_jam_weight = small_agent_count * short_term_ratio + large_agent_count * (1 - short_term_ratio);
            // cout << "sum jam weight: " << sum_jam_weight << endl;

            // sum_jam_weight * jam_coefficient = estimated delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic) {
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1) {
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
        // nothing to assign
        else {
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Task Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 1.5.4.-3: 将地图分成方形区域, task pickup区域统计当前agent数量, delivery区域统计agent goal数量, 两者和作为sum jam weight
void TaskScheduler::adaptive_jam_count_pickup_current_delivery_goal(int time_limit, std::vector<int>& proposed_schedule)
{
    cout << "adaptive jam count pickup current delivery goal" << endl;
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    if (free_agents.size() > 50)
    {
        if (first_epoch_done_time == -1)
        {
            // 由于大算例初始任务过多, 在初始任务分配完成前采用默认算法
            greedy_sum_without_newtask(time_limit, proposed_schedule);
            return;
        }
    }
    else
    {
        if (first_epoch_done_time == -1)
        {
            first_epoch_done_time = env->curr_timestep; // 初始阶段的任务分配完毕的时间
        }
    }

    // Step 1: 将map分为若干区域, 统计每个区域时间窗agent和goal的数量
    // Step 1.1: 计算每个区域agent的数量。
    vector<int> current_region_agent_num(small_region_wait_num.size(), 0);
    for (int i = 0; i < env->num_of_agents; i++)
    {
        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;

        int agent_region_x = agent_loc_x / small_region_column;
        int agent_region_y = agent_loc_y / small_region_row;

        int agent_region_index = agent_region_y * num_small_region_column + agent_region_x;

        // 计算每个区域当前agent数量
        current_region_agent_num[agent_region_index]++;
    }

    // Step 1.2: 计算每个区域agent goal的数量。
    vector<int> region_goal_num(small_region_wait_num.size(), 0);
    for (int i = 0; i < env->goal_locations.size(); i++)
    {
        if (!env->goal_locations[i].empty()) // 这里goal_locations.size()==1, for循环用不用都无所谓
        {
            for (auto const& goal : env->goal_locations[i])
            {
                int agent_goal = goal.first;
                int agent_goal_x = agent_goal % env->cols;
                int agent_goal_y = agent_goal / env->cols;

                int agent_region_x = agent_goal_x / small_region_column;
                int agent_region_y = agent_goal_y / small_region_row;

                region_goal_num[agent_region_y * num_small_region_column + agent_region_x]++;
            }
        }
    }


    /*
    cout << "current region agent num: ";
    for (int i : current_small_region_agent_num)
    {
        cout << i << " ";
    }
    cout << endl;
    cout << "region goal num: ";
    for (int i : region_goal_num)
    {
        cout << i << " ";
    }
    cout << endl;
     //*/

     // Step 2: 计算task每个errand点所在区域
     // Step 2.1: 计算每个task pickup归属于哪个区域。
    if (env->curr_timestep == first_epoch_done_time) // 在first_epoch_done_time计算完此时的free tasks
    {
        for (int t_id : free_tasks)
        {
            int pickup_loc = env->task_pool[t_id].locations[0];
            int pickup_loc_x = pickup_loc % env->cols;
            int pickup_loc_y = pickup_loc / env->cols;

            int pickup_region_x = pickup_loc_x / small_region_column;
            int pickup_region_y = pickup_loc_y / small_region_row;

            pickup_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;
        }
    }
    else // first_epoch_done_time之后就只计算新任务
    {
        for (int t_id : env->new_tasks)
        {
            int pickup_loc = env->task_pool[t_id].locations[0];
            int pickup_loc_x = pickup_loc % env->cols;
            int pickup_loc_y = pickup_loc / env->cols;

            int pickup_region_x = pickup_loc_x / small_region_column;
            int pickup_region_y = pickup_loc_y / small_region_row;

            pickup_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;
        }
    }

    // Step 2.2: 计算每个task delivery归属于哪个区域。
    if (env->curr_timestep == first_epoch_done_time) // 在first_epoch_done_time计算完此时的free tasks
    {
        for (int t_id : free_tasks)
        {
            int delivery_loc = env->task_pool[t_id].locations[1];
            int delivery_loc_x = delivery_loc % env->cols;
            int delivery_loc_y = delivery_loc / env->cols;

            int delivery_region_x = delivery_loc_x / small_region_column;
            int delivery_region_y = delivery_loc_y / small_region_row;

            delivery_region[t_id] = delivery_region_y * num_small_region_column + delivery_region_x;
        }
    }
    else // first_epoch_done_time之后就只计算新任务
    {
        for (int t_id : env->new_tasks)
        {
            int delivery_loc = env->task_pool[t_id].locations[1];
            int delivery_loc_x = delivery_loc % env->cols;
            int delivery_loc_y = delivery_loc / env->cols;

            int delivery_region_x = delivery_loc_x / small_region_column;
            int delivery_region_y = delivery_loc_y / small_region_row;

            delivery_region[t_id] = delivery_region_y * num_small_region_column + delivery_region_x;
        }
    }

    // 遍历并输出
    /*
    for (const auto& pair : pickup_region) 
    {
        std::cout << "Task ID: " << pair.first << " -> pickup Regions: " << pair.second << endl;
    }

    for (const auto& pair : delivery_region)
    {
        std::cout << "Task ID: " << pair.first << " -> delivery Regions: " << pair.second << endl;
    }
    //*/

    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            // check for timeout every 10 task evaluations
            if (std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations) {
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            // Step 3: 根据task所属区域估计执行成本。
            // 对于距离较近的errand点(pickup), 计算agent数量
            int sum_jam_agent = current_region_agent_num[pickup_region[t_id]];
            // cout << "sam jam agent: " << sum_jam_agent << endl;
            int sum_jam_goal = region_goal_num[delivery_region[t_id]];
            // cout << "sam jam goal: " << sum_jam_goal << endl;
            int sum_jam_weight = sum_jam_agent + sum_jam_goal;
            // cout << "sam jam weight: " << sum_jam_weight << endl;

            // sum_jam_weight * jam_coefficient = estimated delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic) {
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1) {
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
        // nothing to assign
        else {
            proposed_schedule[i] = -1;
            it++;
        }
    }

    prev_states = env->curr_states; // 更新prev states for all agents

    cout << "Task Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 1.5.4.-2: 将地图分成方形区域, task pickup区域统计当前agent数量, delivery区域统计agent goal数量, 两者加权和作为sum jam weight
void TaskScheduler::adaptive_jam_count_weighted_pickup_current_delivery_goal(int time_limit, std::vector<int>& proposed_schedule)
{
    cout << "adaptive jam count weighted pickup current delivery goal" << endl;
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    if (free_agents.size() > 50)
    {
        if (first_epoch_done_time == -1)
        {
            // 由于大算例初始任务过多, 在初始任务分配完成前采用默认算法
            greedy_sum_without_newtask(time_limit, proposed_schedule);
            return;
        }
    }
    else
    {
        if (first_epoch_done_time == -1)
        {
            first_epoch_done_time = env->curr_timestep; // 初始阶段的任务分配完毕的时间
        }
    }

    // Step 1: 将map分为若干区域, 统计每个区域时间窗agent和goal的数量
    // Step 1.1: 计算每个区域agent的数量。
    vector<int> current_region_agent_num(small_region_wait_num.size(), 0);
    for (int i = 0; i < env->num_of_agents; i++)
    {
        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;

        int agent_region_x = agent_loc_x / small_region_column;
        int agent_region_y = agent_loc_y / small_region_row;

        int agent_region_index = agent_region_y * num_small_region_column + agent_region_x;

        // 计算每个区域当前agent数量
        current_region_agent_num[agent_region_index]++;
    }

    // Step 1.2: 计算每个区域agent goal的数量。
    vector<int> region_goal_num(small_region_wait_num.size(), 0);
    for (int i = 0; i < env->goal_locations.size(); i++)
    {
        if (!env->goal_locations[i].empty()) // 这里goal_locations.size()==1, for循环用不用都无所谓
        {
            for (auto const& goal : env->goal_locations[i])
            {
                int agent_goal = goal.first;
                int agent_goal_x = agent_goal % env->cols;
                int agent_goal_y = agent_goal / env->cols;

                int agent_region_x = agent_goal_x / small_region_column;
                int agent_region_y = agent_goal_y / small_region_row;

                region_goal_num[agent_region_y * num_small_region_column + agent_region_x]++;
            }
        }
    }


    /*
    cout << "current region agent num: ";
    for (int i : current_small_region_agent_num)
    {
        cout << i << " ";
    }
    cout << endl;
    cout << "region goal num: ";
    for (int i : region_goal_num)
    {
        cout << i << " ";
    }
    cout << endl;
     //*/

     // Step 2: 计算task每个errand点所在区域
     // Step 2.1: 计算每个task pickup归属于哪个区域。
    if (env->curr_timestep == first_epoch_done_time) // 在first_epoch_done_time计算完此时的free tasks
    {
        for (int t_id : free_tasks)
        {
            int pickup_loc = env->task_pool[t_id].locations[0];
            int pickup_loc_x = pickup_loc % env->cols;
            int pickup_loc_y = pickup_loc / env->cols;

            int pickup_region_x = pickup_loc_x / small_region_column;
            int pickup_region_y = pickup_loc_y / small_region_row;

            pickup_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;
        }
    }
    else // first_epoch_done_time之后就只计算新任务
    {
        for (int t_id : env->new_tasks)
        {
            int pickup_loc = env->task_pool[t_id].locations[0];
            int pickup_loc_x = pickup_loc % env->cols;
            int pickup_loc_y = pickup_loc / env->cols;

            int pickup_region_x = pickup_loc_x / small_region_column;
            int pickup_region_y = pickup_loc_y / small_region_row;

            pickup_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;
        }
    }

    // Step 2.2: 计算每个task delivery归属于哪个区域。
    if (env->curr_timestep == first_epoch_done_time) // 在first_epoch_done_time计算完此时的free tasks
    {
        for (int t_id : free_tasks)
        {
            int delivery_loc = env->task_pool[t_id].locations[1];
            int delivery_loc_x = delivery_loc % env->cols;
            int delivery_loc_y = delivery_loc / env->cols;

            int delivery_region_x = delivery_loc_x / small_region_column;
            int delivery_region_y = delivery_loc_y / small_region_row;

            delivery_region[t_id] = delivery_region_y * num_small_region_column + delivery_region_x;
        }
    }
    else // first_epoch_done_time之后就只计算新任务
    {
        for (int t_id : env->new_tasks)
        {
            int delivery_loc = env->task_pool[t_id].locations[1];
            int delivery_loc_x = delivery_loc % env->cols;
            int delivery_loc_y = delivery_loc / env->cols;

            int delivery_region_x = delivery_loc_x / small_region_column;
            int delivery_region_y = delivery_loc_y / small_region_row;

            delivery_region[t_id] = delivery_region_y * num_small_region_column + delivery_region_x;
        }
    }

    // 遍历并输出
    /*
    for (const auto& pair : pickup_region)
    {
        std::cout << "Task ID: " << pair.first << " -> pickup Regions: " << pair.second << endl;
    }

    for (const auto& pair : delivery_region)
    {
        std::cout << "Task ID: " << pair.first << " -> delivery Regions: " << pair.second << endl;
    }
    //*/

    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            // check for timeout every 10 task evaluations
            if (std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations) {
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            // Step 3: 根据task所属区域估计执行成本。
            // 对于距离较近的errand点(pickup), 计算agent数量
            int sum_jam_agent = current_region_agent_num[pickup_region[t_id]];
            // cout << "sam jam agent: " << sum_jam_agent << endl;
            int sum_jam_goal = region_goal_num[delivery_region[t_id]];
            // cout << "sam jam goal: " << sum_jam_goal << endl;
            double near_ratio = 0.7;
            double sum_jam_weight = sum_jam_agent * near_ratio + sum_jam_goal * (1 - near_ratio);
            // cout << "sam jam weight: " << sum_jam_weight << endl;

            // sum_jam_weight * jam_coefficient = estimated delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic) {
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1) {
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
        // nothing to assign
        else {
            proposed_schedule[i] = -1;
            it++;
        }
    }

    prev_states = env->curr_states; // 更新prev states for all agents

    cout << "Task Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}


// 1.5.4.-1: 将地图分成方形区域, task pickup区域统计当前agent数量, delivery区域统计时间窗agent等待点数量, 两者和作为sum jam weight
void TaskScheduler::adaptive_jam_count_pickup_current_delivery_time_window_wait(int time_limit, std::vector<int>& proposed_schedule)
{
    cout << "adaptive jam count pickup current delivery time window wait" << endl;
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    if (free_agents.size() > 50)
    {
        if (first_epoch_done_time == -1)
        {
            // 由于大算例初始任务过多, 在初始任务分配完成前采用默认算法
            greedy_sum_without_newtask(time_limit, proposed_schedule);
            return;
        }
    }
    else
    {
        if (first_epoch_done_time == -1)
        {
            first_epoch_done_time = env->curr_timestep; // 初始阶段的任务分配完毕的时间
        }
    }

    // Step 1: 将map分为若干区域, 统计每个区域时间窗agent和wait的数量
    // 如果不是count current, small_region_wait_num[]就不应该清空
    vector<int> current_region_agent_num(small_region_wait_num.size(), 0);
    vector<int> current_region_wait_num(small_region_wait_num.size(), 0);
    for (int i = 0; i < env->num_of_agents; i++)
    {
        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;

        int agent_region_x = agent_loc_x / small_region_column;
        int agent_region_y = agent_loc_y / small_region_row;

        int agent_region_index = agent_region_y * num_small_region_column + agent_region_x;

        // 计算每个区域当前agent数量
        current_region_agent_num[agent_region_index]++;

        // 如果和前一时刻位置和方向一样, 则计入等待
        if (env->curr_states.at(i).location == prev_states[i].location
            && env->curr_states.at(i).orientation == prev_states[i].orientation)
        {
            small_region_wait_num[agent_region_index]++;
            // 计算每个区域当前agent wait数量
            current_region_wait_num[agent_region_index]++;
        }
    }

    auto removed_region_wait_num = period_small_region_wait_num.push(current_region_wait_num); // 添加元素，可能移除旧元素
    if (!removed_region_wait_num.empty())
    {
        // cout << "removed previous region agent num: ";
        for (int i = 0; i < removed_region_wait_num.size(); i++)
        {
            // cout << removed_small_region_wait_num[i] << " ";
            small_region_wait_num[i] -= removed_region_wait_num[i];
        }
        // cout << endl;
    }

    /*
    cout << "history total region wait num: ";
    for(int i : small_region_wait_num)
    {
        cout << i << " ";
    }
    cout << endl;
    cout << "current region wait num: ";
    for (int i : current_small_region_wait_num)
    {
        cout << i << " ";
    }
    cout << endl;
    cout << "current region agent num: ";
    for (int i : current_small_region_agent_num)
    {
        cout << i << " ";
    }
    cout << endl;
     //*/

     // Step 2: 计算task每个errand点所在区域
     // Step 2.1: 计算每个task pickup归属于哪个区域。
    if (env->curr_timestep == first_epoch_done_time) // 在first_epoch_done_time计算完此时的free tasks
    {
        for (int t_id : free_tasks)
        {
            int pickup_loc = env->task_pool[t_id].locations[0];
            int pickup_loc_x = pickup_loc % env->cols;
            int pickup_loc_y = pickup_loc / env->cols;

            int pickup_region_x = pickup_loc_x / small_region_column;
            int pickup_region_y = pickup_loc_y / small_region_row;

            pickup_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;
        }
    }
    else // first_epoch_done_time之后就只计算新任务
    {
        for (int t_id : env->new_tasks)
        {
            int pickup_loc = env->task_pool[t_id].locations[0];
            int pickup_loc_x = pickup_loc % env->cols;
            int pickup_loc_y = pickup_loc / env->cols;

            int pickup_region_x = pickup_loc_x / small_region_column;
            int pickup_region_y = pickup_loc_y / small_region_row;

            pickup_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;
        }
    }

    // 遍历并输出
    /*
    for (const auto& pair : task_errand_region) {
        std::cout << "Task ID: " << pair.first << " -> Errand Regions: ";
        for (const int& errand : pair.second) {
            std::cout << errand << " ";
        }
        std::cout << std::endl;
    }
    //*/

    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            // check for timeout every 10 task evaluations
            if (std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations) {
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            // Step 3: 根据task所属区域估计执行成本。
            // 对于距离较近的errand点(pickup), 计算agent数量
            int sum_jam_weight = current_region_agent_num[task_errand_region[t_id][0]];

            // cout << "sam jam weight only agent: " << sum_jam_weight << endl;

            if (task_errand_region[t_id].size() == 2)
            {
                // 最后的errand点只统计一般agent wait数量
                sum_jam_weight += small_region_wait_num[task_errand_region[t_id].back()] / 2;
            }
            else if (task_errand_region[t_id].size() > 2)
            {
                // 对于距离较远的errand点(delivery), 计算agent wait数量
                for (int i = 1; i < task_errand_region[t_id].size() - 1; i++)
                {
                    sum_jam_weight += small_region_wait_num[task_errand_region[t_id][i]];
                }

                // 最后的errand点只统计一般agent wait数量
                sum_jam_weight += small_region_wait_num[task_errand_region[t_id].back()] / 2;
            }

            // cout << "sam jam weight with agent and wait: " << sum_jam_weight << endl;

            // sum_jam_weight * jam_coefficient = estimated delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic) {
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1) {
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
        // nothing to assign
        else {
            proposed_schedule[i] = -1;
            it++;
        }
    }

    prev_states = env->curr_states; // 更新prev states for all agents

    cout << "Task Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 1.5.4: 将地图分成方形区域, task pickup区域统计当前agent数量, delivery区域统计时间窗agent等待点数量, 两者和作为sum jam weight
void TaskScheduler::adaptive_jam_count_near_current_far_time_window_wait(int time_limit, std::vector<int>& proposed_schedule)
{
    cout << "adaptive jam count near current far time window wait" << endl;
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    if (free_agents.size() > 50)
    {
        if (first_epoch_done_time == -1)
        {
            // 由于大算例初始任务过多, 在初始任务分配完成前采用默认算法
            greedy_sum_without_newtask(time_limit, proposed_schedule);
            return;
        }
    }
    else
    {
        if (first_epoch_done_time == -1)
        {
            first_epoch_done_time = env->curr_timestep; // 初始阶段的任务分配完毕的时间
        }
    }

    // Step 1: 将map分为若干区域, 统计每个区域时间窗agent和wait的数量
    // 如果不是count current, small_region_wait_num[]就不应该清空
    vector<int> current_region_agent_num(small_region_wait_num.size(), 0);
    vector<int> current_region_wait_num(small_region_wait_num.size(), 0);
    for (int i = 0; i < env->num_of_agents; i++)
    {
        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;

        int agent_region_x = agent_loc_x / small_region_column;
        int agent_region_y = agent_loc_y / small_region_row;

        int agent_region_index = agent_region_y * num_small_region_column + agent_region_x;

        // 计算每个区域当前agent数量
        current_region_agent_num[agent_region_index]++;
        
        // 如果和前一时刻位置和方向一样, 则计入等待
        if (env->curr_states.at(i).location == prev_states[i].location
            && env->curr_states.at(i).orientation == prev_states[i].orientation)
        {
            small_region_wait_num[agent_region_index]++;
            // 计算每个区域当前agent wait数量
            current_region_wait_num[agent_region_index]++;
        }
    }

    auto removed_region_wait_num = period_small_region_wait_num.push(current_region_wait_num); // 添加元素，可能移除旧元素
    if (!removed_region_wait_num.empty())
    {
        // cout << "removed previous region agent num: ";
        for (int i = 0; i < removed_region_wait_num.size(); i++)
        {
            // cout << removed_small_region_wait_num[i] << " ";
            small_region_wait_num[i] -= removed_region_wait_num[i];
        }
        // cout << endl;
    }

    /*
    cout << "history total region wait num: ";
    for(int i : small_region_wait_num)
    {
        cout << i << " ";
    }
    cout << endl;
    cout << "current region wait num: ";
    for (int i : current_small_region_wait_num)
    {
        cout << i << " ";
    }
    cout << endl;
    cout << "current region agent num: ";
    for (int i : current_small_region_agent_num)
    {
        cout << i << " ";
    }
    cout << endl;
     //*/

     // Step 2: 计算task每个errand点所在区域
    if (env->curr_timestep == first_epoch_done_time) // 在first_epoch_done_time计算完此时的free tasks
    {
        for (int t_id : free_tasks)
        {
            vector<int> errand_regions;
            for (auto errand_loc : env->task_pool[t_id].locations)
            {
                int errand_loc_x = errand_loc % env->cols;
                int errand_loc_y = errand_loc / env->cols;

                int errand_region_x = errand_loc_x / small_region_column;
                int errand_region_y = errand_loc_y / small_region_row;

                int region_id = errand_region_y * num_small_region_column + errand_region_x;

                // 如果 errand_regions 为空或末尾元素与当前计算的 region_id 不相同，则添加
                if (errand_regions.empty() || errand_regions.back() != region_id)
                {
                    errand_regions.emplace_back(region_id);
                }
            }

            task_errand_region[t_id] = errand_regions;
        }
    }
    else // first_epoch_done_time之后就只计算新任务
    {
        for (int t_id : env->new_tasks)
        {
            vector<int> errand_regions;
            for (auto errand_loc : env->task_pool[t_id].locations)
            {
                int errand_loc_x = errand_loc % env->cols;
                int errand_loc_y = errand_loc / env->cols;

                int errand_region_x = errand_loc_x / small_region_column;
                int errand_region_y = errand_loc_y / small_region_row;

                int region_id = errand_region_y * num_small_region_column + errand_region_x;

                // 如果 errand_regions 为空或末尾元素与当前计算的 region_id 不相同，则添加
                if (errand_regions.empty() || errand_regions.back() != region_id)
                {
                    errand_regions.emplace_back(region_id);
                }
            }

            task_errand_region[t_id] = errand_regions;
        }
    }

    // 遍历并输出
    /*
    for (const auto& pair : task_errand_region) {
        std::cout << "Task ID: " << pair.first << " -> Errand Regions: ";
        for (const int& errand : pair.second) {
            std::cout << errand << " ";
        }
        std::cout << std::endl;
    }
    //*/

    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            // check for timeout every 10 task evaluations
            if (std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations) {
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            // Step 3: 根据task所属区域估计执行成本。
            // 对于距离较近的errand点(pickup), 计算agent数量
            int sum_jam_weight = current_region_agent_num[task_errand_region[t_id][0]];

            // cout << "sam jam weight only agent: " << sum_jam_weight << endl;

            if (task_errand_region[t_id].size() == 2)
            {
                // 最后的errand点只统计一般agent wait数量
                sum_jam_weight += small_region_wait_num[task_errand_region[t_id].back()] / 2;
            }
            else if (task_errand_region[t_id].size() > 2)
            {
                // 对于距离较远的errand点(delivery), 计算agent wait数量
                for (int i = 1; i < task_errand_region[t_id].size() - 1; i++)
                {
                    sum_jam_weight += small_region_wait_num[task_errand_region[t_id][i]];
                }

                // 最后的errand点只统计一般agent wait数量
                sum_jam_weight += small_region_wait_num[task_errand_region[t_id].back()] / 2;
            }

            // cout << "sam jam weight with agent and wait: " << sum_jam_weight << endl;

            // sum_jam_weight * jam_coefficient = estimated delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic) {
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1) {
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
        // nothing to assign
        else {
            proposed_schedule[i] = -1;
            it++;
        }
    }

    prev_states = env->curr_states; // 更新prev states for all agents

    cout << "Task Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 1.5.5: 将地图分成方形区域, task pickup区域统计当前agent数量, delivery区域统计时间窗平均agent等待点数量, 两者加权和作为sum jam weight
void TaskScheduler::adaptive_jam_count_pickup_current_delivery_time_window_average_wait(int time_limit, std::vector<int>& proposed_schedule)
{
    cout << "adaptive jam count pickup current delivery time window average wait" << endl;
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;
    cout << "small region length: " << small_region_column << endl;

    // 大算例sortation和warehouse必须分离出来
    if (env->map_name[0] == 's' || env->map_name[0] == 'w')
    {
        if (free_agents.size() > 50)
        {
            if (first_epoch_done_time == -1)
            {
                // 由于大算例初始任务过多, 在初始任务分配完成前采用默认算法
                greedy_sum_without_newtask(time_limit, proposed_schedule);
                return;
            }
        }
        else
        {
            if (first_epoch_done_time == -1)
            {
                first_epoch_done_time = env->curr_timestep; // 初始阶段的任务分配完毕的时间
            }
        }
    }    

    // Step 1: 将map分为若干区域, 统计每个区域时间窗agent和wait的数量
    // 如果不是count current, small_region_wait_num[]就不应该清空
    vector<int> current_small_region_agent_num(small_region_wait_num.size(), 0);
    vector<int> current_small_region_wait_num(small_region_wait_num.size(), 0);
    for (int i = 0; i < env->num_of_agents; i++)
    {
        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;

        int agent_region_x = agent_loc_x / small_region_column;
        int agent_region_y = agent_loc_y / small_region_row;

        int agent_region_index = agent_region_y * num_small_region_column + agent_region_x;

        // 计算每个区域当前agent数量
        current_small_region_agent_num[agent_region_index]++;

        // 如果和前一时刻位置和方向一样, 则计入等待
        if (env->curr_states.at(i).location == prev_states[i].location
            && env->curr_states.at(i).orientation == prev_states[i].orientation)
        {
            small_region_wait_num[agent_region_index]++;
            // 计算每个区域当前agent wait数量
            current_small_region_wait_num[agent_region_index]++;
        }
    }

    // 添加元素，可能移除旧元素
    auto removed_small_region_wait_num = period_small_region_wait_num.push(current_small_region_wait_num); 
    if (!removed_small_region_wait_num.empty())
    {
        // cout << "removed previous region agent num: ";
        for (int i = 0; i < removed_small_region_wait_num.size(); i++)
        {
            // cout << removed_small_region_wait_num[i] << " ";
            small_region_wait_num[i] -= removed_small_region_wait_num[i];
        }
        // cout << endl;
    }

    /*
    cout << "history total region wait num: ";
    for(int i : small_region_wait_num)
    {
        cout << i << " ";
    }
    cout << endl;
    cout << "current region wait num: ";
    for (int i : current_small_region_wait_num)
    {
        cout << i << " ";
    }
    cout << endl;
    cout << "current region agent num: ";
    for (int i : current_small_region_agent_num)
    {
        cout << i << " ";
    }
    cout << endl;
     //*/

    // Step 2: 计算task每个errand点所在区域
    // 大算例sortation和warehouse必须分离出来
    if (env->map_name[0] == 's' || env->map_name[0] == 'w')
    {
        if (env->curr_timestep == first_epoch_done_time) // 在first_epoch_done_time计算完此时的free tasks
        {
            for (int t_id : free_tasks)
            {
                vector<int> errand_regions;
                for (auto errand_loc : env->task_pool[t_id].locations)
                {
                    int errand_loc_x = errand_loc % env->cols;
                    int errand_loc_y = errand_loc / env->cols;

                    int errand_region_x = errand_loc_x / small_region_column;
                    int errand_region_y = errand_loc_y / small_region_row;

                    int region_id = errand_region_y * num_small_region_column + errand_region_x;

                    // 如果 errand_regions 为空或末尾元素与当前计算的 region_id 不相同，则添加
                    if (errand_regions.empty() || errand_regions.back() != region_id)
                    {
                        errand_regions.emplace_back(region_id);
                    }
                }

                task_errand_region[t_id] = errand_regions;
            }
        }
        else // first_epoch_done_time之后就只计算新任务
        {
            for (int t_id : env->new_tasks)
            {
                vector<int> errand_regions;
                for (auto errand_loc : env->task_pool[t_id].locations)
                {
                    int errand_loc_x = errand_loc % env->cols;
                    int errand_loc_y = errand_loc / env->cols;

                    int errand_region_x = errand_loc_x / small_region_column;
                    int errand_region_y = errand_loc_y / small_region_row;

                    int region_id = errand_region_y * num_small_region_column + errand_region_x;

                    // 如果 errand_regions 为空或末尾元素与当前计算的 region_id 不相同，则添加
                    if (errand_regions.empty() || errand_regions.back() != region_id)
                    {
                        errand_regions.emplace_back(region_id);
                    }
                }

                task_errand_region[t_id] = errand_regions;
            }
        }
    }
    else // 小算例直接算
    {
        for (int t_id : env->new_tasks)
        {
            vector<int> errand_regions;
            for (auto errand_loc : env->task_pool[t_id].locations)
            {
                int errand_loc_x = errand_loc % env->cols;
                int errand_loc_y = errand_loc / env->cols;

                int errand_region_x = errand_loc_x / small_region_column;
                int errand_region_y = errand_loc_y / small_region_row;

                int region_id = errand_region_y * num_small_region_column + errand_region_x;

                // 如果 errand_regions 为空或末尾元素与当前计算的 region_id 不相同，则添加
                if (errand_regions.empty() || errand_regions.back() != region_id)
                {
                    errand_regions.emplace_back(region_id);
                }
            }

            task_errand_region[t_id] = errand_regions;
        }
    }
    

    // 遍历并输出
    /*
    for (const auto& pair : task_errand_region) {
        std::cout << "Task ID: " << pair.first << " -> Errand Regions: ";
        for (const int& errand : pair.second) {
            std::cout << errand << " ";
        }
        std::cout << std::endl;
    }
    //*/

    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            // check for timeout every 10 task evaluations
            if (std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations) {
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            // Step 3: 根据task所属区域估计执行成本。
            // 对于距离较近的errand点(pickup), 计算agent数量
            int sum_jam_agent = current_small_region_agent_num[task_errand_region[t_id][0]];
            // cout << "sum jam agent: " << sum_jam_agent << endl;

            // cout << "sam jam weight only agent: " << sum_jam_weight << endl;            
            double sum_jam_wait = 0;
            // 尝试1: 末位errand取一半wait num
            /*
            if (task_errand_region[t_id].size() == 2)
            {
                // 最后的errand点只统计一般agent wait数量
                sum_jam_wait += small_region_wait_num[task_errand_region[t_id].back()] / 2;
            }
            else if (task_errand_region[t_id].size() > 2)
            {
                // 对于距离较远的errand点(delivery), 计算agent wait数量
                for (int i = 1; i < task_errand_region[t_id].size() - 1; i++)
                {
                    sum_jam_wait += small_region_wait_num[task_errand_region[t_id][i]];
                }

                // 最后的errand点只统计一般agent wait数量
                sum_jam_wait += small_region_wait_num[task_errand_region[t_id].back()] / 2;
            }
            */

            // 尝试2: 末位errand全取wait num
            if (task_errand_region[t_id].size() > 1)
            {
                // 对于距离较远的errand点(delivery), 计算agent wait数量
                for (int i = 1; i < task_errand_region[t_id].size(); i++)
                {
                    sum_jam_wait += small_region_wait_num[task_errand_region[t_id][i]];
                }
            }

            sum_jam_wait /= period_small_region_wait_num.get_size();
            // cout << "sum jam wait: " << sum_jam_wait << endl;
            double wait_coefficient = 1;
            double sum_jam_weight = sum_jam_agent + sum_jam_wait * wait_coefficient;

            // cout << "sam jam weight with agent and wait: " << sum_jam_weight << endl;

            // sum_jam_weight * jam_coefficient = estimated delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic) {
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1) {
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
        // nothing to assign
        else {
            proposed_schedule[i] = -1;
            it++;
        }
    }

    prev_states = env->curr_states; // 更新prev states for all agents

    cout << "Task Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 1.5.6: 将地图分成方形区域, task pickup区域统计当前agent数量 减去 delivery区域统计时间窗平均agent等待点数量, 作为sum jam weight
void TaskScheduler::adaptive_jam_count_pickup_current_minus_delivery_time_window_average_wait(int time_limit, std::vector<int>& proposed_schedule)
{
    cout << "adaptive jam count pickup current minus delivery time window average wait" << endl;
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;
    cout << "small region length: " << small_region_column << endl;

    // 大算例sortation和warehouse必须分离出来
    if (env->map_name[0] == 's' || env->map_name[0] == 'w')
    {
        if (free_agents.size() > 50)
        {
            if (first_epoch_done_time == -1)
            {
                // 由于大算例初始任务过多, 在初始任务分配完成前采用默认算法
                greedy_sum_without_newtask(time_limit, proposed_schedule);
                return;
            }
        }
        else
        {
            if (first_epoch_done_time == -1)
            {
                first_epoch_done_time = env->curr_timestep; // 初始阶段的任务分配完毕的时间
            }
        }
    }

    // Step 1: 将map分为若干区域, 统计每个区域时间窗agent和wait的数量
    // 如果不是count current, small_region_wait_num[]就不应该清空
    vector<int> current_small_region_agent_num(small_region_wait_num.size(), 0);
    vector<int> current_small_region_wait_num(small_region_wait_num.size(), 0);
    for (int i = 0; i < env->num_of_agents; i++)
    {
        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;

        int agent_region_x = agent_loc_x / small_region_column;
        int agent_region_y = agent_loc_y / small_region_row;

        int agent_region_index = agent_region_y * num_small_region_column + agent_region_x;

        // 计算每个区域当前agent数量
        current_small_region_agent_num[agent_region_index]++;

        // 如果和前一时刻位置和方向一样, 则计入等待
        if (env->curr_states.at(i).location == prev_states[i].location
            && env->curr_states.at(i).orientation == prev_states[i].orientation)
        {
            small_region_wait_num[agent_region_index]++;
            // 计算每个区域当前agent wait数量
            current_small_region_wait_num[agent_region_index]++;
        }
    }

    // 添加元素，可能移除旧元素
    auto removed_small_region_wait_num = period_small_region_wait_num.push(current_small_region_wait_num);
    if (!removed_small_region_wait_num.empty())
    {
        // cout << "removed previous region agent num: ";
        for (int i = 0; i < removed_small_region_wait_num.size(); i++)
        {
            // cout << removed_small_region_wait_num[i] << " ";
            small_region_wait_num[i] -= removed_small_region_wait_num[i];
        }
        // cout << endl;
    }

    /*
    cout << "history total region wait num: ";
    for(int i : small_region_wait_num)
    {
        cout << i << " ";
    }
    cout << endl;
    cout << "current region wait num: ";
    for (int i : current_small_region_wait_num)
    {
        cout << i << " ";
    }
    cout << endl;
    cout << "current region agent num: ";
    for (int i : current_small_region_agent_num)
    {
        cout << i << " ";
    }
    cout << endl;
     //*/

     // Step 2: 计算task每个errand点所在区域
     // 大算例sortation和warehouse必须分离出来
    if (env->map_name[0] == 's' || env->map_name[0] == 'w')
    {
        if (env->curr_timestep == first_epoch_done_time) // 在first_epoch_done_time计算完此时的free tasks
        {
            for (int t_id : free_tasks)
            {
                int pickup_loc = env->task_pool[t_id].locations.front();
                int pickup_loc_x = pickup_loc % env->cols;
                int pickup_loc_y = pickup_loc / env->cols;

                int pickup_region_x = pickup_loc_x / small_region_column;
                int pickup_region_y = pickup_loc_y / small_region_row;

                pickup_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;

                int delivery_loc = env->task_pool[t_id].locations.back();
                int delivery_loc_x = delivery_loc % env->cols;
                int delivery_loc_y = delivery_loc / env->cols;

                int delivery_region_x = delivery_loc_x / small_region_column;
                int delivery_region_y = delivery_loc_y / small_region_row;

                delivery_region[t_id] = delivery_region_y * num_small_region_column + delivery_region_x;
            }
        }
        else // first_epoch_done_time之后就只计算新任务
        {
            for (int t_id : env->new_tasks)
            {
                int pickup_loc = env->task_pool[t_id].locations.front();
                int pickup_loc_x = pickup_loc % env->cols;
                int pickup_loc_y = pickup_loc / env->cols;

                int pickup_region_x = pickup_loc_x / small_region_column;
                int pickup_region_y = pickup_loc_y / small_region_row;

                pickup_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;

                int delivery_loc = env->task_pool[t_id].locations.back();
                int delivery_loc_x = delivery_loc % env->cols;
                int delivery_loc_y = delivery_loc / env->cols;

                int delivery_region_x = delivery_loc_x / small_region_column;
                int delivery_region_y = delivery_loc_y / small_region_row;

                delivery_region[t_id] = delivery_region_y * num_small_region_column + delivery_region_x;
            }
        }
    }
    else // 小算例直接算
    {
        for (int t_id : env->new_tasks)
        {
            int pickup_loc = env->task_pool[t_id].locations.front();
            int pickup_loc_x = pickup_loc % env->cols;
            int pickup_loc_y = pickup_loc / env->cols;

            int pickup_region_x = pickup_loc_x / small_region_column;
            int pickup_region_y = pickup_loc_y / small_region_row;

            pickup_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;

            int delivery_loc = env->task_pool[t_id].locations.back();
            int delivery_loc_x = delivery_loc % env->cols;
            int delivery_loc_y = delivery_loc / env->cols;

            int delivery_region_x = delivery_loc_x / small_region_column;
            int delivery_region_y = delivery_loc_y / small_region_row;

            delivery_region[t_id] = delivery_region_y * num_small_region_column + delivery_region_x;
        }
    }


    // 遍历并输出
    /*
    for (const auto& pair : pickup_region) 
    {
        std::cout << "Task ID: " << pair.first << " -> pickup Region: " << pair.second << endl;
    }

    for (const auto& pair : delivery_region) 
    {
        std::cout << "Task ID: " << pair.first << " -> delivery Region: " << pair.second << endl;
    }
    //*/

    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            // check for timeout every 10 task evaluations
            if (std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations) {
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            // Step 3: 根据task所属区域估计执行成本。
            // 对于距离较近的errand点(pickup), 计算agent数量
            int sum_jam_agent = current_small_region_agent_num[pickup_region[t_id]];
            // cout << "sum jam agent: " << sum_jam_agent << endl;
        
            double sum_jam_wait = small_region_wait_num[delivery_region[t_id]];

            sum_jam_wait /= period_small_region_wait_num.get_size();
            // cout << "sum jam wait: " << sum_jam_wait << endl;
            double wait_coefficient = 1;
            double sum_jam_weight = sum_jam_agent - sum_jam_wait * wait_coefficient;

            // cout << "sam jam weight with agent and wait: " << sum_jam_weight << endl;

            // sum_jam_weight * jam_coefficient = estimated delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic) {
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1) {
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
        // nothing to assign
        else {
            proposed_schedule[i] = -1;
            it++;
        }
    }

    prev_states = env->curr_states; // 更新prev states for all agents

    cout << "Task Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 1.5.7: 将地图分成方形区域, task pickup区域统计当前agent数量 减去 delivery区域统计时间窗平均agent等待点数量, 作为sum jam weight
// 等待权重的系数是恒定的
void TaskScheduler::adaptive_jam_count_pickup_current_minus_delivery_time_window_average_wait_constant(int time_limit, std::vector<int>& proposed_schedule)
{
    cout << "adaptive jam count pickup current minus delivery time window average wait constant" << endl;
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;
    cout << "small region length: " << small_region_column << endl;

    // 大算例sortation和warehouse必须分离出来
    if (env->map_name[0] == 's' || env->map_name[0] == 'w')
    {
        if (free_agents.size() > 50)
        {
            if (first_epoch_done_time == -1)
            {
                // 由于大算例初始任务过多, 在初始任务分配完成前采用默认算法
                greedy_sum_without_newtask(time_limit, proposed_schedule);
                return;
            }
        }
        else
        {
            if (first_epoch_done_time == -1)
            {
                first_epoch_done_time = env->curr_timestep; // 初始阶段的任务分配完毕的时间
            }
        }
    }

    // Step 1: 将map分为若干区域, 统计每个区域时间窗agent和wait的数量
    // 如果不是count current, small_region_wait_num[]就不应该清空
    vector<int> current_small_region_agent_num(small_region_wait_num.size(), 0);
    vector<int> current_small_region_wait_num(small_region_wait_num.size(), 0);
    for (int i = 0; i < env->num_of_agents; i++)
    {
        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;

        int agent_region_x = agent_loc_x / small_region_column;
        int agent_region_y = agent_loc_y / small_region_row;

        int agent_region_index = agent_region_y * num_small_region_column + agent_region_x;

        // 计算每个区域当前agent数量
        current_small_region_agent_num[agent_region_index]++;

        // 如果和前一时刻位置和方向一样, 则计入等待
        if (env->curr_states.at(i).location == prev_states[i].location
            && env->curr_states.at(i).orientation == prev_states[i].orientation)
        {
            small_region_wait_num[agent_region_index]++;
            // 计算每个区域当前agent wait数量
            current_small_region_wait_num[agent_region_index]++;
        }
    }

    // 添加元素，可能移除旧元素
    auto removed_small_region_wait_num = period_small_region_wait_num.push(current_small_region_wait_num);
    if (!removed_small_region_wait_num.empty())
    {
        // cout << "removed previous region agent num: ";
        for (int i = 0; i < removed_small_region_wait_num.size(); i++)
        {
            // cout << removed_small_region_wait_num[i] << " ";
            small_region_wait_num[i] -= removed_small_region_wait_num[i];
        }
        // cout << endl;
    }

    /*
    cout << "history total region wait num: ";
    for(int i : small_region_wait_num)
    {
        cout << i << " ";
    }
    cout << endl;
    cout << "current region wait num: ";
    for (int i : current_small_region_wait_num)
    {
        cout << i << " ";
    }
    cout << endl;
    cout << "current region agent num: ";
    for (int i : current_small_region_agent_num)
    {
        cout << i << " ";
    }
    cout << endl;
     //*/

     // Step 2: 计算task每个errand点所在区域
     // 大算例sortation和warehouse必须分离出来
    if (env->map_name[0] == 's' || env->map_name[0] == 'w')
    {
        if (env->curr_timestep == first_epoch_done_time) // 在first_epoch_done_time计算完此时的free tasks
        {
            for (int t_id : free_tasks)
            {
                int pickup_loc = env->task_pool[t_id].locations.front();
                int pickup_loc_x = pickup_loc % env->cols;
                int pickup_loc_y = pickup_loc / env->cols;

                int pickup_region_x = pickup_loc_x / small_region_column;
                int pickup_region_y = pickup_loc_y / small_region_row;

                pickup_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;

                int delivery_loc = env->task_pool[t_id].locations.back();
                int delivery_loc_x = delivery_loc % env->cols;
                int delivery_loc_y = delivery_loc / env->cols;

                int delivery_region_x = delivery_loc_x / small_region_column;
                int delivery_region_y = delivery_loc_y / small_region_row;

                delivery_region[t_id] = delivery_region_y * num_small_region_column + delivery_region_x;
            }
        }
        else // first_epoch_done_time之后就只计算新任务
        {
            for (int t_id : env->new_tasks)
            {
                int pickup_loc = env->task_pool[t_id].locations.front();
                int pickup_loc_x = pickup_loc % env->cols;
                int pickup_loc_y = pickup_loc / env->cols;

                int pickup_region_x = pickup_loc_x / small_region_column;
                int pickup_region_y = pickup_loc_y / small_region_row;

                pickup_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;

                int delivery_loc = env->task_pool[t_id].locations.back();
                int delivery_loc_x = delivery_loc % env->cols;
                int delivery_loc_y = delivery_loc / env->cols;

                int delivery_region_x = delivery_loc_x / small_region_column;
                int delivery_region_y = delivery_loc_y / small_region_row;

                delivery_region[t_id] = delivery_region_y * num_small_region_column + delivery_region_x;
            }
        }
    }
    else // 小算例直接算
    {
        for (int t_id : env->new_tasks)
        {
            int pickup_loc = env->task_pool[t_id].locations.front();
            int pickup_loc_x = pickup_loc % env->cols;
            int pickup_loc_y = pickup_loc / env->cols;

            int pickup_region_x = pickup_loc_x / small_region_column;
            int pickup_region_y = pickup_loc_y / small_region_row;

            pickup_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;

            int delivery_loc = env->task_pool[t_id].locations.back();
            int delivery_loc_x = delivery_loc % env->cols;
            int delivery_loc_y = delivery_loc / env->cols;

            int delivery_region_x = delivery_loc_x / small_region_column;
            int delivery_region_y = delivery_loc_y / small_region_row;

            delivery_region[t_id] = delivery_region_y * num_small_region_column + delivery_region_x;
        }
    }


    // 遍历并输出
    /*
    for (const auto& pair : pickup_region)
    {
        std::cout << "Task ID: " << pair.first << " -> pickup Region: " << pair.second << endl;
    }

    for (const auto& pair : delivery_region)
    {
        std::cout << "Task ID: " << pair.first << " -> delivery Region: " << pair.second << endl;
    }
    //*/

    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_score = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            // check for timeout every 10 task evaluations
            if (std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations) {
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            // Step 3: 根据task所属区域估计执行成本。
            // 对于距离较近的errand点(pickup), 计算agent数量
            int sum_jam_agent = current_small_region_agent_num[pickup_region[t_id]];
            // cout << "sum jam agent: " << sum_jam_agent << endl;

            double sum_jam_wait = small_region_wait_num[delivery_region[t_id]];

            sum_jam_wait /= period_small_region_wait_num.get_size();
            // cout << "sum jam wait: " << sum_jam_wait << endl;
            double wait_coefficient = 2;

            // cout << "sam jam weight with agent and wait: " << sum_jam_weight << endl;

            double task_score = dist + sum_jam_agent * jam_coefficient - sum_jam_wait * wait_coefficient;

            // sum_jam_weight * jam_coefficient = estimated delay time
            if (task_score < min_task_score) 
            {
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_score = task_score;
                corresponding_traffic_jam = sum_jam_agent;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1) {
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist = min_task_dist;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
        // nothing to assign
        else {
            proposed_schedule[i] = -1;
            it++;
        }
    }

    prev_states = env->curr_states; // 更新prev states for all agents

    cout << "Task Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 1.5.8: 将地图分成方形区域, task pickup区域统计当前agent数量, delivery区域统计时间窗平均agent等待点数量, 两者加权和作为sum jam weight
void TaskScheduler::adaptive_jam_count_pickup_current_delivery_time_window_average_wait_middle_large(int time_limit, std::vector<int>& proposed_schedule)
{
    cout << "adaptive jam count pickup current delivery time window average wait middle large" << endl;
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;
    cout << "small region length: " << small_region_column << endl;

    if (free_agents.size() > 50)
    {
        if (first_epoch_done_time == -1)
        {
            // 由于大算例初始任务过多, 在初始任务分配完成前采用默认算法
            greedy_sum_without_newtask(time_limit, proposed_schedule);
            return;
        }
    }
    else
    {
        if (first_epoch_done_time == -1)
        {
            first_epoch_done_time = env->curr_timestep; // 初始阶段的任务分配完毕的时间
        }
    }

    // Step 1: 将map分为若干区域, 统计每个区域时间窗agent和wait的数量
    // Step 1.1: 计算每个小方格中agent的数量
    vector<int> current_small_region_agent_num(small_region_wait_num.size(), 0);
    vector<int> current_small_region_wait_num(small_region_wait_num.size(), 0);
    for (int i = 0; i < env->num_of_agents; i++)
    {
        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;

        int agent_region_x = agent_loc_x / small_region_column;
        int agent_region_y = agent_loc_y / small_region_row;

        int agent_region_index = agent_region_y * num_small_region_column + agent_region_x;

        // 计算每个区域当前agent数量
        current_small_region_agent_num[agent_region_index]++;

        // 如果和前一时刻位置和方向一样, 则计入等待
        if (env->curr_states.at(i).location == prev_states[i].location
            && env->curr_states.at(i).orientation == prev_states[i].orientation)
        {
            small_region_wait_num[agent_region_index]++;
            // 计算每个区域当前agent wait数量
            current_small_region_wait_num[agent_region_index]++;
        }
    }

    // 添加元素，可能移除旧元素
    auto removed_small_region_wait_num = period_small_region_wait_num.push(current_small_region_wait_num);
    if (!removed_small_region_wait_num.empty())
    {
        // cout << "removed previous region agent num: ";
        for (int i = 0; i < removed_small_region_wait_num.size(); i++)
        {
            // cout << removed_small_region_wait_num[i] << " ";
            small_region_wait_num[i] -= removed_small_region_wait_num[i];
        }
        // cout << endl;
    }

    /*
    cout << "current region agent num: ";
    for (int i : current_small_region_agent_num)
    {
        cout << i << " ";
    }
    cout << endl;
    cout << "history total small region wait num: ";
    for(int i : small_region_wait_num)
    {
        cout << i << " ";
    }
    cout << endl;
    cout << "current small region wait num: ";
    for (int i : current_small_region_wait_num)
    {
        cout << i << " ";
    }
    cout << endl;
     //*/

    // Step 1.2: 计算每个大方格中agent wait的数量
    vector<int> current_large_region_wait_num(large_region_wait_num.size(), 0);
    for (int i = 0; i < env->num_of_agents; i++)
    {
        // 如果和前一时刻位置和方向一样, 则计入等待
        if (env->curr_states.at(i).location == prev_states[i].location
            && env->curr_states.at(i).orientation == prev_states[i].orientation)
        {
            int agent_loc = env->curr_states.at(i).location;
            int agent_loc_x = agent_loc % env->cols;
            int agent_loc_y = agent_loc / env->cols;

            int agent_region_x = agent_loc_x / large_region_column;
            int agent_region_y = agent_loc_y / large_region_row;

            int agent_region_index = agent_region_y * num_large_region_column + agent_region_x;
            
            large_region_wait_num[agent_region_index]++;
            // 计算每个区域当前agent wait数量
            current_large_region_wait_num[agent_region_index]++;
        }
    }

    // 添加元素，可能移除旧元素
    auto removed_large_region_wait_num = period_large_region_wait_num.push(current_large_region_wait_num);
    if (!removed_large_region_wait_num.empty())
    {
        // cout << "removed previous region agent num: ";
        for (int i = 0; i < removed_large_region_wait_num.size(); i++)
        {
            // cout << removed_small_region_wait_num[i] << " ";
            large_region_wait_num[i] -= removed_large_region_wait_num[i];
        }
        // cout << endl;
    }

    /*
    cout << "history total large region wait num: ";
    for(int i : large_region_wait_num)
    {
        cout << i << " ";
    }
    cout << endl;
    cout << "current large region wait num: ";
    for (int i : current_large_region_wait_num)
    {
        cout << i << " ";
    }
    cout << endl;
     //*/

     // Step 2: 计算task每个errand点所在区域
    if (env->curr_timestep == first_epoch_done_time) // 在first_epoch_done_time计算完此时的free tasks
    {
        for (int t_id : free_tasks)
        {
            vector<int> errand_regions;
            for (auto errand_loc : env->task_pool[t_id].locations)
            {
                int errand_loc_x = errand_loc % env->cols;
                int errand_loc_y = errand_loc / env->cols;

                int errand_region_x = errand_loc_x / small_region_column;
                int errand_region_y = errand_loc_y / small_region_row;

                int region_id = errand_region_y * num_small_region_column + errand_region_x;

                // 如果 errand_regions 为空或末尾元素与当前计算的 region_id 不相同，则添加
                if (errand_regions.empty() || errand_regions.back() != region_id)
                {
                    errand_regions.emplace_back(region_id);
                }
            }

            task_errand_region[t_id] = errand_regions;
            
            vector<int> middle_regions; // task相邻errand点的中点所属的区域序列
            for (int i = 0; i < env->task_pool[t_id].locations.size() - 1; i++)
            {
                int start_loc_x = env->task_pool[t_id].locations[i] % env->cols;
                int start_loc_y = env->task_pool[t_id].locations[i] / env->cols;

                int end_loc_x = env->task_pool[t_id].locations[i+1] % env->cols;
                int end_loc_y = env->task_pool[t_id].locations[i+1] / env->cols;

                int middle_loc_x = (start_loc_x + end_loc_x) / 2;
                int middle_loc_y = (start_loc_y + end_loc_y) / 2;

                int middle_region_x = middle_loc_x / large_region_column;
                int middle_region_y = middle_loc_y / large_region_row;

                int region_id = middle_region_y * num_large_region_column + middle_region_x;

                // 如果 middle_regions 为空或末尾元素与当前计算的 region_id 不相同，则添加
                if (middle_regions.empty() || middle_regions.back() != region_id)
                {
                    middle_regions.emplace_back(region_id);
                }
            }

            task_middle_region[t_id] = middle_regions;
        }
    }
    else // first_epoch_done_time之后就只计算新任务
    {
        for (int t_id : env->new_tasks)
        {
            vector<int> errand_regions;
            for (auto errand_loc : env->task_pool[t_id].locations)
            {
                int errand_loc_x = errand_loc % env->cols;
                int errand_loc_y = errand_loc / env->cols;

                int errand_region_x = errand_loc_x / small_region_column;
                int errand_region_y = errand_loc_y / small_region_row;

                int region_id = errand_region_y * num_small_region_column + errand_region_x;

                // 如果 errand_regions 为空或末尾元素与当前计算的 region_id 不相同，则添加
                if (errand_regions.empty() || errand_regions.back() != region_id)
                {
                    errand_regions.emplace_back(region_id);
                }
            }

            task_errand_region[t_id] = errand_regions;

            vector<int> middle_regions; // task相邻errand点的中点所属的区域序列
            for (int i = 0; i < env->task_pool[t_id].locations.size() - 1; i++)
            {
                int start_loc_x = env->task_pool[t_id].locations[i] % env->cols;
                int start_loc_y = env->task_pool[t_id].locations[i] / env->cols;

                int end_loc_x = env->task_pool[t_id].locations[i + 1] % env->cols;
                int end_loc_y = env->task_pool[t_id].locations[i + 1] / env->cols;

                int middle_loc_x = (start_loc_x + end_loc_x) / 2;
                int middle_loc_y = (start_loc_y + end_loc_y) / 2;

                int middle_region_x = middle_loc_x / large_region_column;
                int middle_region_y = middle_loc_y / large_region_row;

                int region_id = middle_region_y * num_large_region_column + middle_region_x;

                // 如果 middle_regions 为空或末尾元素与当前计算的 region_id 不相同，则添加
                if (middle_regions.empty() || middle_regions.back() != region_id)
                {
                    middle_regions.emplace_back(region_id);
                }
            }

            task_middle_region[t_id] = middle_regions;
        }
    }

    // 遍历并输出
    /*
    for (const auto& pair : task_errand_region) {
        std::cout << "Task ID: " << pair.first << " -> Errand Regions: ";
        for (const int& errand : pair.second) {
            std::cout << errand << " ";
        }
        std::cout << std::endl;
    }

    for (const auto& pair : task_middle_region) {
        std::cout << "Task ID: " << pair.first << " -> middle Regions: ";
        for (const int& errand : pair.second) {
            std::cout << errand << " ";
        }
        std::cout << std::endl;
    }
    //*/

    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            // check for timeout every 10 task evaluations
            if (std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations) {
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            // Step 3: 根据task所属区域估计执行成本。
            // 对于距离较近的errand点(pickup), 计算agent数量
            int sum_jam_agent = current_small_region_agent_num[task_errand_region[t_id][0]];
            // cout << "sum jam agent: " << sum_jam_agent << endl;

            // cout << "sam jam weight only agent: " << sum_jam_weight << endl;            
            double sum_errand_wait = 0;

            if (task_errand_region[t_id].size() > 1)
            {
                // 对于距离较远的errand点(delivery), 计算agent wait数量
                for (int i = 1; i < task_errand_region[t_id].size(); i++)
                {
                    sum_errand_wait += small_region_wait_num[task_errand_region[t_id][i]];
                }
            }

            sum_errand_wait /= period_small_region_wait_num.get_size();
            // cout << "sum errand wait: " << sum_errand_wait << endl;

            // 对于距离较远的errand点之间的middle点, 计算更大区域的agent wait数量
            double sum_middle_wait = 0;
            for (int i = 0; i < task_middle_region[t_id].size(); i++)
            {
                sum_middle_wait += large_region_wait_num[task_middle_region[t_id][i]];
            }
            sum_middle_wait /= period_large_region_wait_num.get_size();
            // cout << "sum middle wait: " << sum_middle_wait << endl;

            double wait_coefficient = 1;
            double sum_jam_weight = sum_jam_agent + (sum_errand_wait + sum_middle_wait / 4) * wait_coefficient;

            // cout << "sam jam weight with agent and wait: " << sum_jam_weight << endl;

            // sum_jam_weight * jam_coefficient = estimated delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic) {
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1) {
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
        // nothing to assign
        else {
            proposed_schedule[i] = -1;
            it++;
        }
    }

    prev_states = env->curr_states; // 更新prev states for all agents

    cout << "Task Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 以task pickup为圆心，agent-task为半径朝向task画出一个圆，位于这个圆内的other agent的计入拥堵系数。为了量纲相等还要乘以|at|。jam = cost<ao,at> * |at| / |ao| = inner(ao, at) / inner(ao, ao) if |to| < |at|; =0, otherwise
void TaskScheduler::adaptive_jam_task_circle_vector_current(int time_limit, std::vector<int> & proposed_schedule)
{
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for(auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                 << " minDist " << agent_task[element].min_task_dist
                 << " heuristic " << agent_task[element].task_heuristic
                 << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                 << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if(numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;
        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            //check for timeout every 10 task evaluations
            if (std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            double sum_jam_weight = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations){
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            /*
            if(OneDim2TwoDim.find(env->task_pool[t_id].locations[0]) == OneDim2TwoDim.end())
            {
                cerr << "map error!" << endl;
            }
            */

            int pickup_loc = env->task_pool[t_id].locations[0];
            int pickup_loc_x = env->task_pool[t_id].locations[0] % env->cols;
            int pickup_loc_y = env->task_pool[t_id].locations[0] / env->cols;
            // cout << "pickup loc " << pickup_twodim.x << " " << pickup_twodim.y << endl;

            // 当前agent指向某个任务的向量
            int agent_task_direction_x = pickup_loc_x - agent_loc_x;
            int agent_task_direction_y = pickup_loc_y - agent_loc_y;
            int agent_task_direction_square = agent_task_direction_x * agent_task_direction_x +
                                              agent_task_direction_y * agent_task_direction_y;

            for(int j=0;j<env->curr_states.size();j++)
            {
                if (j != i) // 所有agent都会有任务, 所以都要计入
                {
                    int other_agent_loc = env->curr_states.at(j).location;
                    int other_agent_loc_x = other_agent_loc % env->cols;
                    int other_agent_loc_y = other_agent_loc / env->cols;
                    // cout << "other agent loc " << other_agent_loc << " " << other_agent_loc_x << " "
                    // << other_agent_loc_y << endl;

                    int agent_other_direction_x = other_agent_loc_x - agent_loc_x;
                    int agent_other_direction_y = other_agent_loc_y - agent_loc_y;
                    // cout << "other agent direction " << agent_other_direction_x << " " << other_agent_loc_y << endl;
                    int agent_other_distance_square = agent_other_direction_x * agent_other_direction_x
                                                      + agent_other_direction_y * agent_other_direction_y;

                    int other_task_direction_x = pickup_loc_x - other_agent_loc_x;
                    int other_task_direction_y = pickup_loc_y - other_agent_loc_y;
                    // cout << "other agent direction " << agent_other_direction_x << " " << other_agent_loc_y << endl;
                    int other_task_distance_square = other_task_direction_x * other_task_direction_x
                                                     + other_task_direction_y * other_task_direction_y;

                    // 只统计以task为圆心, agent-task范围内的other agent
                    if(other_task_distance_square < agent_task_direction_square)
                    {
                        int inner_product = agent_other_direction_x * agent_task_direction_x
                                            + agent_other_direction_y * agent_task_direction_y;

                        // cout << "task direction: " << agent_task_direction_x << " " << agent_task_direction_y << " "
                        // << task_direction_length << endl;

                        sum_jam_weight += double (inner_product) / agent_other_distance_square;
                    }
                }
            }

            // sum_jam_weight * jam_coefficient = guess delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic){
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1){
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist  = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
            // nothing to assign
        else{
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Time Usage: " <<  ((float)(clock() - start))/CLOCKS_PER_SEC <<endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: "<< env->new_tasks.size() <<  endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 以task pickup为圆心，agent-task为半径朝向task画出一个圆，位于这个圆内的other agent的计入拥堵系数，并把这个系数外推出去。jam = (cost<ao,at> * |at| / |ao|) * (total_dist / |at|) = inner(ao, at) / inner(ao, ao) if |to| < |at|; =0, otherwise
void TaskScheduler::adaptive_jam_task_circle_vector_current_extrapolation(int time_limit,
                                                                          std::vector<int> & proposed_schedule)
{
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for(auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                 << " minDist " << agent_task[element].min_task_dist
                 << " heuristic " << agent_task[element].task_heuristic
                 << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                 << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if(numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;
        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            //check for timeout every 10 task evaluations
            if (std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            double sum_jam_weight = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations){
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            /*
            if(OneDim2TwoDim.find(env->task_pool[t_id].locations[0]) == OneDim2TwoDim.end())
            {
                cerr << "map error!" << endl;
            }
            */

            int pickup_loc = env->task_pool[t_id].locations[0];
            int pickup_loc_x = env->task_pool[t_id].locations[0] % env->cols;
            int pickup_loc_y = env->task_pool[t_id].locations[0] / env->cols;
            // cout << "pickup loc " << pickup_twodim.x << " " << pickup_twodim.y << endl;

            // 当前agent指向某个任务的向量
            int agent_task_direction_x = pickup_loc_x - agent_loc_x;
            int agent_task_direction_y = pickup_loc_y - agent_loc_y;
            int agent_task_direction_square = agent_task_direction_x * agent_task_direction_x +
                                              agent_task_direction_y * agent_task_direction_y;

            for(int j=0;j<env->curr_states.size();j++)
            {
                if (j != i) // 所有agent都会有任务, 所以都要计入
                {
                    int other_agent_loc = env->curr_states.at(j).location;
                    int other_agent_loc_x = other_agent_loc % env->cols;
                    int other_agent_loc_y = other_agent_loc / env->cols;
                    // cout << "other agent loc " << other_agent_loc << " " << other_agent_loc_x << " "
                    // << other_agent_loc_y << endl;

                    int agent_other_direction_x = other_agent_loc_x - agent_loc_x;
                    int agent_other_direction_y = other_agent_loc_y - agent_loc_y;
                    // cout << "other agent direction " << agent_other_direction_x << " " << other_agent_loc_y << endl;
                    int agent_other_distance_square = agent_other_direction_x * agent_other_direction_x
                                                      + agent_other_direction_y * agent_other_direction_y;

                    int other_task_direction_x = pickup_loc_x - other_agent_loc_x;
                    int other_task_direction_y = pickup_loc_y - other_agent_loc_y;
                    // cout << "other agent direction " << agent_other_direction_x << " " << other_agent_loc_y << endl;
                    int other_task_distance_square = other_task_direction_x * other_task_direction_x
                                                     + other_task_direction_y * other_task_direction_y;

                    // 只统计以task为圆心, agent-task范围内的other agent
                    if(other_task_distance_square < agent_task_direction_square)
                    {
                        int inner_product = agent_other_direction_x * agent_task_direction_x
                                            + agent_other_direction_y * agent_task_direction_y;

                        // cout << "task direction: " << agent_task_direction_x << " " << agent_task_direction_y << " "
                        // << task_direction_length << endl;

                        sum_jam_weight += double (inner_product) / agent_other_distance_square;
                    }
                }
            }

            // sum_jam_weight * jam_coefficient * extrapolation = guess delay time
            if (dist + sum_jam_weight * jam_coefficient * dist /
            DefaultPlanner::get_h(env, agent_loc, pickup_loc) < min_task_heuristic){
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1){
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist  = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
            // nothing to assign
        else{
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Time Usage: " <<  ((float)(clock() - start))/CLOCKS_PER_SEC <<endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: "<< env->new_tasks.size() <<  endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 以task pickup为圆心，agent-task为半径朝向task画出一个圆，位于这个圆内的other agent的计入拥堵系数, 有|agent-task|欧几里得距离作为分母。jam = cost<ao,at> / |ao| = inner(ao, at) / (inner(ao, ao) * |at|) if |to| < |at|; =0, otherwise
void TaskScheduler::adaptive_jam_task_circle_vector_current_complex(int time_limit, std::vector<int> & proposed_schedule)
{
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for(auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);

            total_min_span += temp.min_task_dist;
            total_real_duration += temp.real_duration;
            total_jam += temp.jam_when_assign;

            cout << "complete task " << temp.task_id
                 << " minDist " << temp.min_task_dist
                 << " heuristic " << temp.heuristic_duration
                 << " real " << temp.real_duration
                 << " jam " << temp.jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if(numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;
        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            //check for timeout every 10 task evaluations
            if (std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            double traffic_jam = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations){
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            /*
            if(OneDim2TwoDim.find(env->task_pool[t_id].locations[0]) == OneDim2TwoDim.end())
            {
                cerr << "map error!" << endl;
            }
            */

            int pickup_loc = env->task_pool[t_id].locations[0];
            int pickup_loc_x = env->task_pool[t_id].locations[0] % env->cols;
            int pickup_loc_y = env->task_pool[t_id].locations[0] / env->cols;
            // cout << "pickup loc " << pickup_twodim.x << " " << pickup_twodim.y << endl;

            // 当前agent指向某个任务的向量
            int agent_task_direction_x = pickup_loc_x - agent_loc_x;
            int agent_task_direction_y = pickup_loc_y - agent_loc_y;
            int agent_task_direction_square = agent_task_direction_x * agent_task_direction_x +
                                              agent_task_direction_y * agent_task_direction_y;

            for(int j=0;j<env->curr_states.size();j++)
            {
                if (j != i) // 所有agent都会有任务, 所以都要计入
                {
                    int other_agent_loc = env->curr_states.at(j).location;
                    int other_agent_loc_x = other_agent_loc % env->cols;
                    int other_agent_loc_y = other_agent_loc / env->cols;
                    // cout << "other agent loc " << other_agent_loc << " " << other_agent_loc_x << " "
                    // << other_agent_loc_y << endl;

                    int agent_other_direction_x = other_agent_loc_x - agent_loc_x;
                    int agent_other_direction_y = other_agent_loc_y - agent_loc_y;
                    // cout << "other agent direction " << agent_other_direction_x << " " << other_agent_loc_y << endl;
                    int agent_other_distance_square = agent_other_direction_x * agent_other_direction_x
                                                      + agent_other_direction_y * agent_other_direction_y;

                    int other_task_direction_x = pickup_loc_x - other_agent_loc_x;
                    int other_task_direction_y = pickup_loc_y - other_agent_loc_y;
                    // cout << "other agent direction " << agent_other_direction_x << " " << other_agent_loc_y << endl;
                    int other_task_distance_square = other_task_direction_x * other_task_direction_x
                                                      + other_task_direction_y * other_task_direction_y;

                    // 只统计以task为圆心, agent-task范围内的other agent
                    if(other_task_distance_square < agent_task_direction_square)
                    {
                        int inner_product = agent_other_direction_x * agent_task_direction_x
                                            + agent_other_direction_y * agent_task_direction_y;

                            // double task_direction_length = sqrt(agent_task_direction_square);
                            // cout << "task direction: " << agent_task_direction_x << " " << agent_task_direction_y << " "
                            // << task_direction_length << endl;

                            traffic_jam += inner_product / (agent_other_distance_square
                                                            * sqrt(agent_task_direction_square));
                    }
                }
            }

            // update the new minimum makespan
            if (dist + traffic_jam * jam_coefficient < min_task_heuristic){
                min_task_i = t_id;
                min_task_dist = dist;
                // 在算代价时, sum_jam_weight要乘以系数; 记录时, 不乘系数
                min_task_heuristic = dist + traffic_jam * jam_coefficient;
                corresponding_traffic_jam = traffic_jam;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1){
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist  = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
            // nothing to assign
        else{
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Time Usage: " <<  ((float)(clock() - start))/CLOCKS_PER_SEC <<endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: "<< env->new_tasks.size() <<  endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 以task pickup为圆心，agent-task为半径朝向task画出一个圆，位于这个圆内的other agent的计入拥堵系数。为了量纲相等还要乘以|at|。jam = cost<ao,at> * |at| / |ao| = inner(ao, at) / inner(ao, ao) if |to| < |at|; =0, otherwise
void TaskScheduler::adaptive_jam_task_circle_vector_current_busy(int time_limit, std::vector<int> & proposed_schedule)
{
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for(auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                 << " minDist " << agent_task[element].min_task_dist
                 << " heuristic " << agent_task[element].task_heuristic
                 << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                 << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if(numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;
        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            //check for timeout every 10 task evaluations
            if (count % 10 == 0 && std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            double sum_jam_weight = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations){
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            /*
            if(OneDim2TwoDim.find(env->task_pool[t_id].locations[0]) == OneDim2TwoDim.end())
            {
                cerr << "map error!" << endl;
            }
            */

            int pickup_loc = env->task_pool[t_id].locations[0];
            int pickup_loc_x = env->task_pool[t_id].locations[0] % env->cols;
            int pickup_loc_y = env->task_pool[t_id].locations[0] / env->cols;
            // cout << "pickup loc " << pickup_twodim.x << " " << pickup_twodim.y << endl;

            // 当前agent指向某个任务的向量
            int agent_task_direction_x = pickup_loc_x - agent_loc_x;
            int agent_task_direction_y = pickup_loc_y - agent_loc_y;
            int agent_task_direction_square = agent_task_direction_x * agent_task_direction_x +
                                              agent_task_direction_y * agent_task_direction_y;

            for(int j=0;j<env->curr_states.size();j++)
            {
                if (j != i && proposed_schedule[j] != -1) // 只统计有任务的agent
                {
                    int other_agent_loc = env->curr_states.at(j).location;
                    int other_agent_loc_x = other_agent_loc % env->cols;
                    int other_agent_loc_y = other_agent_loc / env->cols;
                    // cout << "other agent loc " << other_agent_loc << " " << other_agent_loc_x << " "
                    // << other_agent_loc_y << endl;

                    int agent_other_direction_x = other_agent_loc_x - agent_loc_x;
                    int agent_other_direction_y = other_agent_loc_y - agent_loc_y;
                    // cout << "other agent direction " << agent_other_direction_x << " " << other_agent_loc_y << endl;
                    int agent_other_distance_square = agent_other_direction_x * agent_other_direction_x
                                                      + agent_other_direction_y * agent_other_direction_y;

                    int other_task_direction_x = pickup_loc_x - other_agent_loc_x;
                    int other_task_direction_y = pickup_loc_y - other_agent_loc_y;
                    // cout << "other agent direction " << agent_other_direction_x << " " << other_agent_loc_y << endl;
                    int other_task_distance_square = other_task_direction_x * other_task_direction_x
                                                     + other_task_direction_y * other_task_direction_y;

                    // 只统计以task为圆心, agent-task范围内的other agent
                    if(other_task_distance_square < agent_task_direction_square)
                    {
                        int inner_product = agent_other_direction_x * agent_task_direction_x
                                            + agent_other_direction_y * agent_task_direction_y;

                        // cout << "task direction: " << agent_task_direction_x << " " << agent_task_direction_y << " "
                        // << task_direction_length << endl;

                        sum_jam_weight += double (inner_product) / agent_other_distance_square;
                    }
                }
            }

            // sum_jam_weight * jam_coefficient = guess delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic){
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1){
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist  = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
            // nothing to assign
        else{
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Time Usage: " <<  ((float)(clock() - start))/CLOCKS_PER_SEC <<endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: "<< env->new_tasks.size() <<  endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 每个任务的拥堵系数在一个时间步对所有agent都是相同的。由所有agent目标距离该任务的倒数之和决定。
void TaskScheduler::pickup_jam_based_goal(int time_limit, std::vector<int> & proposed_schedule)
{
    //use at most half of time_limit to compute schedule, -10 for timing error tolerance
    //so that the remainning time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    TimePoint jam_end_moment = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit / 2);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    // cout << "agent num:" << env->curr_states.size() << endl;
    // cout << "curr time:" << env->curr_timestep << endl;
    /*
    cout << "num goal locs: " << env->goal_locations.size() << endl;
    for(int i=0;i<env->goal_locations.size();i++)
    {
        cout << "agent " << i << " goal locs: ";
        for(auto element : env->goal_locations[i])
        {
            cout << element.first << " ";
        }
        cout << endl;
    }
     */

    clock_t start = clock();

    // compute pickup jam for each free task every timestep
    for (int t_id : free_tasks)
    {
        double pickup_jam = 0;
        int pickup_loc = env->task_pool[t_id].locations[0];
        for(int i=0;i<env->goal_locations.size();i++)
        {
            if (!env->goal_locations[i].empty())
            {
                // 上下左右四个格子内的障碍物越多, 对拥堵的影响就越大
                pickup_jam += double(4 - DefaultPlanner::global_neighbors[pickup_loc].size())
                              / DefaultPlanner::get_h(env, pickup_loc, env->goal_locations[i][0].first);

                // cout << "pickup jam: " << pickup_jam << endl;
            }
        }

        task_pickup_jams[t_id] = pickup_jam;

        if (std::chrono::steady_clock::now() > jam_end_moment)
        {
            // cout << "jam time not enough" << endl;
            break;
        }
    }

    /*
    for (auto it = task_pickup_jams.begin(); it != task_pickup_jams.end(); ++it) {
        std::cout << "task: " << it->first << ", jam: " << it->second << std::endl;
    }
     */

    // cout << "jam compute duration: " <<  ((float)(clock() - start))/CLOCKS_PER_SEC <<endl;

    int min_task_i, min_task_makespan, c_loc, count;


    // iterate over the free agents to decide which task to assign to each of them
    int best_total_distance = 0;
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        //keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        min_task_makespan = INT_MAX;
        count = 0;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            //check for timeout every 10 task evaluations
            if (count % 10 == 0 && std::chrono::steady_clock::now() > endtime)
            {
                break;
            }

            // distance between current location and task pick up location
            int dist = DefaultPlanner::get_h(env, env->curr_states.at(i).location,
                                             env->task_pool[t_id].locations[0]);
            int temp_dist = dist;

            // TODO: 如果task pickup jams没有来得及算, 这里不要加上去
            dist += int ((task_pickup_jams[t_id] - 1.0 / temp_dist) * jam_coefficient);

            // update the new minimum makespan
            if (dist < min_task_makespan){
                min_task_i = t_id;
                min_task_makespan = dist;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1){
            proposed_schedule[i] = min_task_i;
            best_total_distance += min_task_makespan;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
        }
            // nothing to assign
        else{
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Time Usage: " <<  ((float)(clock() - start))/CLOCKS_PER_SEC <<endl;
#ifndef NDEBUG
    cout << "best total distance: " << best_total_distance << endl;
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: "<< env->new_tasks.size() <<  endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

int TaskScheduler::compute_jam_task_circle_count_goal(int _agent_id, int _agent_loc_x, int _agent_loc_y,
                                       int _pickup_loc) const
{
    int sum_jam_weight = 0;

    int pickup_loc_x = _pickup_loc % env->cols;
    int pickup_loc_y = _pickup_loc / env->cols;
    // cout << "pickup loc " << pickup_twodim.x << " " << pickup_twodim.y << endl;

    // 当前agent指向某个任务的向量
    int agent_task_direction_x = pickup_loc_x - _agent_loc_x;
    int agent_task_direction_y = pickup_loc_y - _agent_loc_y;
    int agent_task_direction_square = agent_task_direction_x * agent_task_direction_x +
                                      agent_task_direction_y * agent_task_direction_y;

    for(int j=0;j<env->goal_locations.size();j++)
    {
        if (j != _agent_id && !env->goal_locations[j].empty()) // 所有agent都会有任务, 所以都要计入
        {
            int other_agent_goal = env->goal_locations[j][0].first;
            int other_agent_goal_x = other_agent_goal % env->cols;
            int other_agent_goal_y = other_agent_goal / env->cols;
            // cout << "other agent goal " << other_agent_goal << " " << other_agent_goal_x << " "
            // << other_agent_goal_y << endl;

            int other_task_direction_x = pickup_loc_x - other_agent_goal_x;
            int other_task_direction_y = pickup_loc_y - other_agent_goal_y;
            // cout << "other agent direction " << agent_other_direction_x << " " << other_agent_loc_y << endl;
            int other_task_distance_square = other_task_direction_x * other_task_direction_x
                                             + other_task_direction_y * other_task_direction_y;

            // 只统计以task为圆心, agent-task范围内的other agent
            if(other_task_distance_square < agent_task_direction_square)
            {
                sum_jam_weight++;
            }
        }
    }

    return sum_jam_weight;
}

// 以task pickup为圆心，agent-task为半径朝向task画出一个圆，位于这个圆内的other agent goal的数量为拥堵系数。
void TaskScheduler::adaptive_jam_task_circle_count_goal(int time_limit, std::vector<int> & proposed_schedule)
{
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for(auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                 << " minDist " << agent_task[element].min_task_dist
                 << " heuristic " << agent_task[element].task_heuristic
                 << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                 << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if(numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;
        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            //check for timeout every 10 task evaluations
            if (std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations){
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            int pickup_loc = env->task_pool[t_id].locations[0];

            int sum_jam_weight = compute_jam_task_circle_count_goal(i, agent_loc_x,
                                                                    agent_loc_y, pickup_loc);

            // sum_jam_weight * jam_coefficient = guess delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic){
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1){
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist  = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
            // nothing to assign
        else{
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Time Usage: " <<  ((float)(clock() - start))/CLOCKS_PER_SEC <<endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: "<< env->new_tasks.size() <<  endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

void TaskScheduler::adaptive_jam_task_circle_count_goal_compare_dist(int time_limit,
                                                      std::vector<int> & proposed_schedule)
{
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for(auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                 << " minDist " << agent_task[element].min_task_dist
                 << " heuristic " << agent_task[element].task_heuristic
                 << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                 << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if(numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;
        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            //check for timeout every 10 task evaluations
            if (std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations){
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            if (dist < min_task_heuristic)
            {
                int pickup_loc = env->task_pool[t_id].locations[0];

                int sum_jam_weight = compute_jam_task_circle_count_goal(i, agent_loc_x,
                                                                        agent_loc_y, pickup_loc);

                // sum_jam_weight * jam_coefficient = guess delay time
                if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic){
                    min_task_i = t_id;
                    min_task_dist = dist;
                    min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                    corresponding_traffic_jam = sum_jam_weight;
                }
            }

            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1){
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist  = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
            // nothing to assign
        else{
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Time Usage: " <<  ((float)(clock() - start))/CLOCKS_PER_SEC <<endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: "<< env->new_tasks.size() <<  endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

void TaskScheduler::hungarian_sum_snatch_adaptive_jam_task_circle_count_goal(int time_limit,
                                                              std::vector<int> & proposed_schedule)
{
    //use at most half of time_limit to compute schedule, -10 for timing error tolerance
    //so that the remainning time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;
    clock_t start = clock();

    // 没有新agent就不用抢单了
    if(env->new_freeagents.empty())
    {
        return;
    }

    //*
    for(auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                 << " minDist " << agent_task[element].min_task_dist
                 << " heuristic " << agent_task[element].task_heuristic
                 << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                 << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if(numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    int counter = 0;
    for (const int& free_task_id : free_tasks)
    {
        if (counter % 10 == 0 && std::chrono::steady_clock::now() > endtime)
        {
            break;
        }

        // this task distance has been calculated
        if (task_distances.find(free_task_id) == task_distances.end())
        {
            int total_dist = 0;
            int curr_loc = env->task_pool[free_task_id].locations[0];

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[free_task_id].locations)
            {
                total_dist += DefaultPlanner::get_h(env, curr_loc, loc);
                curr_loc = loc;
            }

            task_distances[free_task_id] = total_dist;
            counter++;
            // cout << counter << endl;
        }
        else
        {
            // cout << "already in" << endl;
        }
    }

    // free agent and agent with task but before pickup
    std::vector<int> free_agents_and_before_pickup;
    free_agents_and_before_pickup.assign(free_agents.begin(), free_agents.end());

    // free tasks and tasks already assigned but before pickup
    std::vector<int> free_tasks_and_before_pickup;
    free_tasks_and_before_pickup.assign(free_tasks.begin(), free_tasks.end());

    for(const auto& element : env->task_pool)
    {
        if(element.second.agent_assigned != -1 && element.second.idx_next_loc == 0)
        {
            free_agents_and_before_pickup.emplace_back(element.second.agent_assigned);
            free_tasks_and_before_pickup.emplace_back(element.second.task_id);
        }
    }

    // 每个时间步，空闲agent数量等于新出现任务的数量。
    // cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    vector< vector<int> > dist_matrix;
    dist_matrix.resize(free_agents_and_before_pickup.size());
    vector< vector<double> > jam_matrix;
    jam_matrix.resize(free_agents_and_before_pickup.size());
    vector< vector<double> > cost_matrix;
    cost_matrix.resize(free_agents_and_before_pickup.size());
    for(int i=0;i<cost_matrix.size();i++)
    {
        auto agent_id = free_agents_and_before_pickup[i];
        int curr_loc = env->curr_states.at(agent_id).location;
        int agent_loc_x = curr_loc % env->cols;
        int agent_loc_y = curr_loc / env->cols;

        dist_matrix[i].resize(free_tasks_and_before_pickup.size(), 0);
        jam_matrix[i].resize(free_tasks_and_before_pickup.size(), 0);
        cost_matrix[i].resize(free_tasks_and_before_pickup.size(), 0);

        for(int j=0;j<free_tasks_and_before_pickup.size();j++)
        {
            auto task_id = free_tasks_and_before_pickup[j];
            int pickup_loc = env->task_pool[task_id].locations[0];

            int sum_jam_weight = compute_jam_task_circle_count_goal(agent_id, agent_loc_x,
                                                                    agent_loc_y, pickup_loc);
            // cout << "traffic jam: " << sum_jam_weight << endl;

            int dist = DefaultPlanner::get_h(env, curr_loc, pickup_loc) + task_distances[task_id];
            dist_matrix[i][j] = dist;
            // 在算代价时, sum_jam_weight要乘以系数; 记录时, 不乘系数
            jam_matrix[i][j] = sum_jam_weight;
            // 计算agent id完成task id的成本
            cost_matrix[i][j] = dist + sum_jam_weight * jam_coefficient;
        }
    }

    vector<int> work_assignment; // "worker " << i << ", assignment " << work_assignment[i]
    Hungarian HungAlgo(cost_matrix);
    // HungAlgo.print_cost_matrix();
    // cout << "prev cost: " << prev_best_total_distance << endl;
    int cost = HungAlgo.Solve(work_assignment); // 如果后续算拥堵系数, cost和prev_best的类型改成double
    // cout << "new cost: " << cost << endl;

    if (cost != prev_best_total_distance)
    {
        prev_best_total_distance = cost;
        free_agents.clear();
        free_agents.insert(free_agents_and_before_pickup.begin(), free_agents_and_before_pickup.end());
        free_tasks.clear();
        free_tasks.insert(free_tasks_and_before_pickup.begin(), free_tasks_and_before_pickup.end());

        for(int i=0; i < free_agents_and_before_pickup.size(); i++)
        {
            int assigned_agent = free_agents_and_before_pickup[i];
            int assigned_task = free_tasks_and_before_pickup[work_assignment[i]];

            proposed_schedule[assigned_agent] = assigned_task;

            // 该工人被分配了任务
            if(work_assignment[i] != -1)
            {
                free_agents.erase(free_agents_and_before_pickup[i]);
                free_tasks.erase(free_tasks_and_before_pickup[work_assignment[i]]);

                agent_task[assigned_agent].task_id = assigned_task;
                agent_task[assigned_agent].min_task_dist  = dist_matrix[i][work_assignment[i]];
                agent_task[assigned_agent].task_heuristic = cost_matrix[i][work_assignment[i]];
                agent_task[assigned_agent].assign_moment = env->curr_timestep; // assign task moment
                agent_task[assigned_agent].jam_when_assign = jam_matrix[i][work_assignment[i]];
                // cout << "jam when assign: " << agent_task[assigned_agent].jam_when_assign << endl;
            }
        }
    }

    /*
    cout << "work assignment: ";
    for(int i=0;i<work_assignment.size();i++)
    {
        cout << work_assignment[i] << " ";
    }
    cout << endl;
     */

    /*
    cout << "proposed schedule: ";
    for(int i=0;i<proposed_schedule.size();i++)
    {
        cout << proposed_schedule[i] << " ";
    }
    cout << endl;
     //*/

    cout << "Time Usage: " <<  ((float)(clock() - start))/CLOCKS_PER_SEC <<endl;
    // cout << "hungarian total distance: " << cost << endl; // 2087, 比默认方法确实缩小了
}

// 以task pickup为圆心，agent-task为半径朝向task画出一个圆，位于这个圆内的other agent goal的数量为拥堵系数。
void TaskScheduler::adaptive_jam_task_circle_count_goal_preassign(int time_limit, std::vector<int>& proposed_schedule)
{
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;
        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            //check for timeout every 10 task evaluations
            if (std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations) {
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            int pickup_loc = env->task_pool[t_id].locations[0];

            int sum_jam_weight = compute_jam_task_circle_count_goal(i, agent_loc_x,
                agent_loc_y, pickup_loc);

            // sum_jam_weight * jam_coefficient = guess delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic) {
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1) {
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
        // nothing to assign
        else {
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

int TaskScheduler::compute_jam_task_circle_count_next_goal(int _agent_id, int _agent_loc_x, int _agent_loc_y,
    int _pickup_loc) const
{
    int sum_jam_weight = 0;

    int pickup_loc_x = _pickup_loc % env->cols;
    int pickup_loc_y = _pickup_loc / env->cols;
    // cout << "pickup loc " << pickup_twodim.x << " " << pickup_twodim.y << endl;

    // 当前agent指向某个任务的向量
    int agent_task_direction_x = pickup_loc_x - _agent_loc_x;
    int agent_task_direction_y = pickup_loc_y - _agent_loc_y;
    int agent_task_direction_square = agent_task_direction_x * agent_task_direction_x +
        agent_task_direction_y * agent_task_direction_y;

    for (int j = 0; j < env->goal_locations.size(); j++)
    {
        if (j != _agent_id && !env->goal_locations[j].empty()) // 所有agent都会有任务, 所以都要计入
        {
            int goal_index = env->task_pool[env->curr_task_schedule[j]].idx_next_loc;
            // cout << "goal index: " << goal_index << endl;
            int other_agent_goal = env->goal_locations[j][goal_index].first;

            int other_agent_goal_x = other_agent_goal % env->cols;
            int other_agent_goal_y = other_agent_goal / env->cols;
            // cout << "other agent goal " << other_agent_goal << " " << other_agent_goal_x << " "
            // << other_agent_goal_y << endl;

            int other_task_direction_x = pickup_loc_x - other_agent_goal_x;
            int other_task_direction_y = pickup_loc_y - other_agent_goal_y;
            // cout << "other agent direction " << agent_other_direction_x << " " << other_agent_loc_y << endl;
            int other_task_distance_square = other_task_direction_x * other_task_direction_x
                + other_task_direction_y * other_task_direction_y;

            // 只统计以task为圆心, agent-task范围内的other agent
            if (other_task_distance_square < agent_task_direction_square)
            {
                sum_jam_weight++;
            }
        }
    }

    return sum_jam_weight;
}

// 3.1: 统计以task为圆心，|agent-task|为半径的圆中other agent next goal的数量作为jam
void TaskScheduler::adaptive_jam_task_circle_count_next_goal(int time_limit, std::vector<int>& proposed_schedule)
{
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;
        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            //check for timeout every 10 task evaluations
            if (std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations) {
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            int pickup_loc = env->task_pool[t_id].locations[0];

            int sum_jam_weight = compute_jam_task_circle_count_next_goal(i, agent_loc_x,
                agent_loc_y, pickup_loc);

            // sum_jam_weight * jam_coefficient = guess delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic) {
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1) {
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
        // nothing to assign
        else {
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

int TaskScheduler::compute_jam_task_circle_count_all_goals(int _agent_id, int _agent_loc_x, int _agent_loc_y,
    int _pickup_loc) const
{
    int sum_jam_weight = 0;

    int pickup_loc_x = _pickup_loc % env->cols;
    int pickup_loc_y = _pickup_loc / env->cols;
    // cout << "pickup loc " << pickup_twodim.x << " " << pickup_twodim.y << endl;

    // 当前agent指向某个任务的向量
    int agent_task_direction_x = pickup_loc_x - _agent_loc_x;
    int agent_task_direction_y = pickup_loc_y - _agent_loc_y;
    int agent_task_direction_square = agent_task_direction_x * agent_task_direction_x +
        agent_task_direction_y * agent_task_direction_y;

    for (int j = 0; j < env->goal_locations.size(); j++)
    {
        if (j != _agent_id && !env->goal_locations[j].empty()) // 所有agent都会有任务, 所以都要计入
        {
            for (int k = 0; k < env->goal_locations[j].size(); k++)
            {
                int other_agent_goal = env->goal_locations[j][k].first;
                int other_agent_goal_x = other_agent_goal % env->cols;
                int other_agent_goal_y = other_agent_goal / env->cols;
                // cout << "other agent goal " << other_agent_goal << " " << other_agent_goal_x << " "
                // << other_agent_goal_y << endl;

                int other_task_direction_x = pickup_loc_x - other_agent_goal_x;
                int other_task_direction_y = pickup_loc_y - other_agent_goal_y;
                // cout << "other agent direction " << agent_other_direction_x << " " << other_agent_loc_y << endl;
                int other_task_distance_square = other_task_direction_x * other_task_direction_x
                    + other_task_direction_y * other_task_direction_y;

                // 只统计以task为圆心, agent-task范围内的other agent
                if (other_task_distance_square < agent_task_direction_square)
                {
                    sum_jam_weight++;
                }
            }           
        }
    }

    return sum_jam_weight;
}

// 3.2: 以task pickup为圆心，agent-task为半径朝向task画出一个圆，位于这个圆内的other agent goal的数量为拥堵系数。
void TaskScheduler::adaptive_jam_task_circle_count_all_goals(int time_limit, std::vector<int>& proposed_schedule)
{
    cout << "adaptive jam task circle count all goals" << endl;
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;
        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            //check for timeout every 10 task evaluations
            if (std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations) {
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            int pickup_loc = env->task_pool[t_id].locations[0];

            int sum_jam_weight = compute_jam_task_circle_count_all_goals(i, agent_loc_x,
                agent_loc_y, pickup_loc);

            // sum_jam_weight * jam_coefficient = guess delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic) {
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1) {
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
        // nothing to assign
        else {
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 3.2.-2: 完不成的任务就不接了
void TaskScheduler::adaptive_jam_task_circle_count_all_goals_not_get(int time_limit, std::vector<int>& proposed_schedule)
{
    cout << "adaptive jam task circle count all goals not get" << endl;
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            /*
            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;
                */
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;
        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            //check for timeout every 10 task evaluations
            if (std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations) {
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            int pickup_loc = env->task_pool[t_id].locations[0];

            int sum_jam_weight = compute_jam_task_circle_count_all_goals(i, agent_loc_x,
                agent_loc_y, pickup_loc);

            // sum_jam_weight * jam_coefficient = guess delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic) {
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1 && min_task_dist < 4995 - env->curr_timestep)
        {
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
        // nothing to assign
        else {
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 3.2.-1: 规避末段靠近边缘的任务
void TaskScheduler::adaptive_jam_task_circle_count_all_goals_delivery_edge(int time_limit, std::vector<int>& proposed_schedule)
{
    cout << "adaptive jam task circle count all goals delivery edge" << endl;
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    for (int t_id : env->new_tasks)
    {
        int delivery_loc = env->task_pool[t_id].locations.back();
        int delivery_loc_x = delivery_loc % env->cols;
        int delivery_loc_y = delivery_loc / env->cols;

        int dist_to_edge = std::min(std::min(delivery_loc_x, env->cols - 1 - delivery_loc_x),
            std::min(delivery_loc_y, env->rows - 1 - delivery_loc_y));

        // cout << "dist to edge: " << dist_to_edge << endl;

        // edge < 5, penalty = 30
        if (dist_to_edge < 5)
        {
            delivery_near_edge[t_id] = 30;
        }
        else
        {
            delivery_near_edge[t_id] = 0;
        }
    }

    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_score = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;
        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            //check for timeout every 10 task evaluations
            if (std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations) {
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            int pickup_loc = env->task_pool[t_id].locations[0];

            int sum_jam_weight = compute_jam_task_circle_count_all_goals(i, agent_loc_x,
                agent_loc_y, pickup_loc);

            // 规避送货点在边缘的任务
            double task_score = dist + sum_jam_weight * jam_coefficient + delivery_near_edge[t_id];

            // sum_jam_weight * jam_coefficient = guess delay time
            if (task_score < min_task_score) 
            {
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_score = task_score;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1) {
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist = min_task_dist;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
        // nothing to assign
        else {
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 3.2.0: 减去任务等待时间
void TaskScheduler::adaptive_jam_task_circle_count_all_goals_minus_wait(int time_limit, std::vector<int>& proposed_schedule)
{
    cout << "adaptive jam task circle count all goals minus wait" << endl;
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    // 每个时间步, free task的等待时间加一
    for (auto element : free_tasks)
    {
        task_wait[element]++;
    }

    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;
        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            //check for timeout every 10 task evaluations
            if (std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations) {
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            int pickup_loc = env->task_pool[t_id].locations[0];

            int sum_jam_weight = compute_jam_task_circle_count_all_goals(i, agent_loc_x,
                agent_loc_y, pickup_loc);

            // sum_jam_weight * jam_coefficient = guess delay time
            if (dist - task_wait[t_id] + sum_jam_weight * jam_coefficient < min_task_heuristic) 
            {
                // cout << "task wait: " << task_wait[t_id] << endl;

                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist - task_wait[t_id] + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1) {
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
        // nothing to assign
        else {
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}


// 3.2.1: 线性回归拟合
void TaskScheduler::linear_regression_jam_task_circle_count_all_goals(int time_limit, std::vector<int>& proposed_schedule)
{
    cout << "linear regression jam task circle count all goals" << endl;
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            // real_duration = min_task_dist + jam * coefficient;
            // real_duration = min_task_dist + jam * fit_a + fit_b;
            total_jam += agent_task[element].jam_when_assign;
            int min_task_dist = agent_task[element].min_task_dist; 
            int real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment; 
            y.emplace_back(real_duration - min_task_dist);
            x.emplace_back(agent_task[element].jam_when_assign);

            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << real_duration
                << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        // vector<int> _x = { 1, 2, 3, 4, 5 };
        // vector<int> _y = { 2, 4, 5, 4, 5 };

        // vector<int> _x = { 0, 0 };
        // vector<int> _y = { 7, 7 };

        /*
        cout << "x:" << endl;
        for (auto element : x)
        {
            cout << element << " ";
        }
        cout << endl;

        cout << "y:" << endl;
        for (auto element : y)
        {
            cout << element << " ";
        }
        cout << endl;
        */

        double a, b;
        linear_regression(x, y, a, b);
        cout << "a: " << a << " b: " << b << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;
        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            //check for timeout every 10 task evaluations
            if (std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations) {
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            int pickup_loc = env->task_pool[t_id].locations[0];

            int sum_jam_weight = compute_jam_task_circle_count_all_goals(i, agent_loc_x,
                agent_loc_y, pickup_loc);

            double guess_delay = sum_jam_weight * fit_a + fit_b;
            if (dist + guess_delay < min_task_heuristic) 
            {
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + guess_delay;
                corresponding_traffic_jam = guess_delay;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1) {
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
        // nothing to assign
        else {
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 3.2.2: 一口气把长度算完
void TaskScheduler::adaptive_jam_task_circle_count_all_goals_at_once(int time_limit, std::vector<int>& proposed_schedule)
{
    cout << "adaptive jam task circle count all goals at once" << endl;
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // 在开始前一口气把新任务长度算完
    for (const int& new_task_id : env->new_tasks)
    {
        // this task distance has been calculated
        int total_dist = 0;
        int curr_loc = env->task_pool[new_task_id].locations[0];

        // iterate over the locations (errands) of the task to compute the makespan to finish the task
        // makespan: the time for the agent to complete all the errands of the task t_id in order
        for (int loc : env->task_pool[new_task_id].locations)
        {
            total_dist += DefaultPlanner::get_h(env, curr_loc, loc);
            curr_loc = loc;
        }

        task_distances[new_task_id] = total_dist;
        // cout << counter << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;
        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            //check for timeout every 10 task evaluations
            if (std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations) {
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                dist += task_distances[t_id];
                c_loc = loc;
                break;
            }

            int pickup_loc = env->task_pool[t_id].locations[0];

            int sum_jam_weight = compute_jam_task_circle_count_all_goals(i, agent_loc_x,
                agent_loc_y, pickup_loc);

            // sum_jam_weight * jam_coefficient = guess delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic) {
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1) {
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
        // nothing to assign
        else {
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

int TaskScheduler::compute_jam_count_pickup_circle_goal_delivery_square_goal(int _agent_id, int _agent_loc_x, 
    int _agent_loc_y, int _pickup_loc) const
{
    int sum_jam_weight = 0;

    int pickup_loc_x = _pickup_loc % env->cols;
    int pickup_loc_y = _pickup_loc / env->cols;
    // cout << "pickup loc " << pickup_twodim.x << " " << pickup_twodim.y << endl;

    // 当前agent指向某个任务的向量
    int agent_task_direction_x = pickup_loc_x - _agent_loc_x;
    int agent_task_direction_y = pickup_loc_y - _agent_loc_y;
    int agent_task_direction_square = agent_task_direction_x * agent_task_direction_x +
        agent_task_direction_y * agent_task_direction_y;

    for (int j = 0; j < env->goal_locations.size(); j++)
    {
        if (j != _agent_id && !env->goal_locations[j].empty()) // 所有agent都会有任务, 所以都要计入
        {
            int other_agent_goal = env->goal_locations[j][0].first;
            int other_agent_goal_x = other_agent_goal % env->cols;
            int other_agent_goal_y = other_agent_goal / env->cols;
            // cout << "other agent goal " << other_agent_goal << " " << other_agent_goal_x << " "
            // << other_agent_goal_y << endl;

            int other_task_direction_x = pickup_loc_x - other_agent_goal_x;
            int other_task_direction_y = pickup_loc_y - other_agent_goal_y;
            // cout << "other agent direction " << agent_other_direction_x << " " << other_agent_loc_y << endl;
            int other_task_distance_square = other_task_direction_x * other_task_direction_x
                + other_task_direction_y * other_task_direction_y;

            // 只统计以task为圆心, agent-task范围内的other agent
            if (other_task_distance_square < agent_task_direction_square)
            {
                sum_jam_weight++;
            }
        }
    }

    return sum_jam_weight;
}

// 3.3: 统计以task为圆心，|agent-pickup|为半径的圆中goal的数量与delivery所在方块中goal的数量作为jam
void TaskScheduler::adaptive_jam_count_pickup_circle_goal_delivery_square_goal(int time_limit, std::vector<int>& proposed_schedule)
{
    cout << "adaptive jam count pickup circle goal delivery square goal" << endl;
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    if (free_agents.size() > 50)
    {
        if (first_epoch_done_time == -1)
        {
            // 由于大算例初始任务过多, 在初始任务分配完成前采用默认算法
            greedy_sum_without_newtask(time_limit, proposed_schedule);
            return;
        }
    }
    else
    {
        if (first_epoch_done_time == -1)
        {
            first_epoch_done_time = env->curr_timestep; // 初始阶段的任务分配完毕的时间
        }
    }

    int region_column = 12; // 每个region所占的列数
    int region_row = 12; // 每个region所占的行数

    // 地图有几列region
    int num_region_column = std::ceil((double)env->cols / region_column);
    // 地图有几行region
    int num_region_row = std::ceil((double)env->rows / region_row);

    // Step 1: 将map分为若干区域, 统计每个区域agent goal的数量
    vector<int> region_goal_num(num_region_column * num_region_row, 0);

    for (int i = 0; i < env->goal_locations.size(); i++)
    {
        if (!env->goal_locations[i].empty()) // 这里goal_locations.size()==1, for循环用不用都无所谓
        {
            for (auto const& goal : env->goal_locations[i])
            {
                int agent_goal = goal.first;
                int agent_goal_x = agent_goal % env->cols;
                int agent_goal_y = agent_goal / env->cols;

                int agent_region_x = agent_goal_x / region_column;
                int agent_region_y = agent_goal_y / region_row;

                region_goal_num[agent_region_y * num_region_column + agent_region_x]++;
            }
        }
    }

    /*
    cout << "region goal num: ";
    for(int i : region_goal_num)
    {
        cout << i << " ";
    }
    cout << endl;
     //*/

     // Step 2: 计算每个task delivery归属于哪个区域。
    if (env->curr_timestep == first_epoch_done_time) // 在first_epoch_done_time计算完此时的free tasks
    {
        for (int t_id : free_tasks)
        {
            int delivery_loc = env->task_pool[t_id].locations[1];
            int delivery_loc_x = delivery_loc % env->cols;
            int delivery_loc_y = delivery_loc / env->cols;

            int delivery_region_x = delivery_loc_x / region_column;
            int delivery_region_y = delivery_loc_y / region_row;

            task_region[t_id] = delivery_region_y * num_region_column + delivery_region_x;
        }
    }
    else // first_epoch_done_time之后就只计算新任务
    {
        for (int t_id : env->new_tasks)
        {
            int delivery_loc = env->task_pool[t_id].locations[1];
            int delivery_loc_x = delivery_loc % env->cols;
            int delivery_loc_y = delivery_loc / env->cols;

            int delivery_region_x = delivery_loc_x / region_column;
            int delivery_region_y = delivery_loc_y / region_row;

            task_region[t_id] = delivery_region_y * num_region_column + delivery_region_x;
        }
    }

    /*
    for (const auto& pair : task_region)
    {
        std::cout << "Task ID: " << pair.first << " -> delivery Regions: " << pair.second << endl;
    }
    //*/

    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;
        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            //check for timeout every 10 task evaluations
            if (std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations) {
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }


            // Step 3: 根据task所属区域估计执行成本。
            int pickup_loc = env->task_pool[t_id].locations[0];

            int pickup_jam = compute_jam_count_pickup_circle_goal_delivery_square_goal(i, agent_loc_x,
                agent_loc_y, pickup_loc);

            // cout << "pickup jam: " << pickup_jam << endl;

            int delivery_jam = region_goal_num[task_region[t_id]];

            // cout << "delivery jam: " << delivery_jam << endl;

            int sum_jam_weight = pickup_jam + delivery_jam;

            // sum_jam_weight * jam_coefficient = guess delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic) {
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1) {
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
        // nothing to assign
        else {
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}


int TaskScheduler::compute_jam_task_double_circle_count_goal(int _agent_id, int _agent_loc_x, int _agent_loc_y,
    int _pickup_loc) const
{
    int sum_jam_weight = 0;

    int pickup_loc_x = _pickup_loc % env->cols;
    int pickup_loc_y = _pickup_loc / env->cols;
    // cout << "pickup loc " << pickup_twodim.x << " " << pickup_twodim.y << endl;

    // 当前agent指向某个任务的向量
    int agent_task_direction_x = pickup_loc_x - _agent_loc_x;
    int agent_task_direction_y = pickup_loc_y - _agent_loc_y;
    int agent_task_direction_square = agent_task_direction_x * agent_task_direction_x +
        agent_task_direction_y * agent_task_direction_y;

    for (int j = 0; j < env->goal_locations.size(); j++)
    {
        if (j != _agent_id && !env->goal_locations[j].empty()) // 所有agent都会有任务, 所以都要计入
        {
            int other_agent_goal = env->goal_locations[j][0].first;
            int other_agent_goal_x = other_agent_goal % env->cols;
            int other_agent_goal_y = other_agent_goal / env->cols;
            // cout << "other agent goal " << other_agent_goal << " " << other_agent_goal_x << " "
            // << other_agent_goal_y << endl;

            int other_task_direction_x = pickup_loc_x - other_agent_goal_x;
            int other_task_direction_y = pickup_loc_y - other_agent_goal_y;
            // cout << "other agent direction " << agent_other_direction_x << " " << other_agent_loc_y << endl;
            int other_task_distance_square = other_task_direction_x * other_task_direction_x
                + other_task_direction_y * other_task_direction_y;

            // 只统计以task为圆心, |agent-task|*2范围内的other agent
            if (other_task_distance_square < agent_task_direction_square * 4)
            {
                sum_jam_weight++;
            }
        }
    }

    return sum_jam_weight;
}

// 3.4: 统计以task为圆心，|agent-task|*2为半径的圆中other agent goal的数量作为jam
void TaskScheduler::adaptive_jam_task_double_circle_count_goal(int time_limit, std::vector<int>& proposed_schedule)
{
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;
        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            //check for timeout every 10 task evaluations
            if (std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations) {
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            int pickup_loc = env->task_pool[t_id].locations[0];

            int sum_jam_weight = compute_jam_task_double_circle_count_goal(i, agent_loc_x,
                agent_loc_y, pickup_loc);

            // sum_jam_weight * jam_coefficient = guess delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic) {
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1) {
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
        // nothing to assign
        else {
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

int TaskScheduler::compute_jam_task_triangle_circle_count_goal(int _agent_id, int _agent_loc_x, int _agent_loc_y,
    int _pickup_loc, int _delivery_loc) const
{
    int sum_jam_weight = 0;

    int pickup_loc_x = _pickup_loc % env->cols;
    int pickup_loc_y = _pickup_loc / env->cols;

    // 当前agent指向某个任务的向量
    int agent_task_direction_x = pickup_loc_x - _agent_loc_x;
    int agent_task_direction_y = pickup_loc_y - _agent_loc_y;
    int agent_task_direction_square = agent_task_direction_x * agent_task_direction_x +
        agent_task_direction_y * agent_task_direction_y;

    int agent_pickup_middle_x = (pickup_loc_x + _agent_loc_x) / 2;
    int agent_pickup_middle_y = (pickup_loc_y + _agent_loc_y) / 2;

    int delivery_loc_x = _delivery_loc % env->cols;
    int delivery_loc_y = _delivery_loc / env->cols;

    int pickup_delivery_middle_x = (pickup_loc_x + delivery_loc_x) / 2;
    int pickup_delivery_middle_y = (pickup_loc_y + delivery_loc_y) / 2;

    int triangle_middle_x = (agent_pickup_middle_x + pickup_delivery_middle_x) / 2;
    int triangle_middle_y = (agent_pickup_middle_y + pickup_delivery_middle_y) / 2;

    for (int j = 0; j < env->goal_locations.size(); j++)
    {
        if (j != _agent_id && !env->goal_locations[j].empty()) // 所有agent都会有任务, 所以都要计入
        {
            int other_agent_goal = env->goal_locations[j][0].first;
            int other_agent_goal_x = other_agent_goal % env->cols;
            int other_agent_goal_y = other_agent_goal / env->cols;
            // cout << "other agent goal " << other_agent_goal << " " << other_agent_goal_x << " "
            // << other_agent_goal_y << endl;

            int other_task_direction_x = triangle_middle_x - other_agent_goal_x;
            int other_task_direction_y = triangle_middle_y - other_agent_goal_y;
            // cout << "other agent direction " << agent_other_direction_x << " " << other_agent_loc_y << endl;
            int other_task_distance_square = other_task_direction_x * other_task_direction_x
                + other_task_direction_y * other_task_direction_y;

            // 只统计以task为圆心, |agent-task|*2范围内的other agent
            if (other_task_distance_square < agent_task_direction_square * 4)
            {
                sum_jam_weight++;
            }
        }
    }

    return sum_jam_weight;
}

// 3.5: 统计以|agent-pickup|中心点和|pickup-delivery|中心点的中点为圆心，|agent-task|*2为半径的圆中other agent goal的数量作为jam
void TaskScheduler::adaptive_jam_task_triangle_circle_count_goal(int time_limit, std::vector<int>& proposed_schedule)
{
    cout << "adaptive jam task triangle circle count goal" << endl;
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;
        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            //check for timeout every 10 task evaluations
            if (std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations) {
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            int pickup_loc = env->task_pool[t_id].locations[0];
            int delivery_loc = env->task_pool[t_id].locations[1];

            int sum_jam_weight = compute_jam_task_triangle_circle_count_goal(i, agent_loc_x,
                agent_loc_y, pickup_loc, delivery_loc);

            // sum_jam_weight * jam_coefficient = guess delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic) {
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1) {
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
        // nothing to assign
        else {
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

[[nodiscard]] double TaskScheduler::compute_jam_task_circle_vector_goal(int _agent_id, int _agent_loc_x,
                                                             int _agent_loc_y, int _pickup_loc) const
{
    double sum_jam_weight = 0;

    int pickup_loc_x = _pickup_loc % env->cols;
    int pickup_loc_y = _pickup_loc / env->cols;
    // cout << "pickup loc " << pickup_twodim.x << " " << pickup_twodim.y << endl;

    // 当前agent指向某个任务的向量
    int agent_task_direction_x = pickup_loc_x - _agent_loc_x;
    int agent_task_direction_y = pickup_loc_y - _agent_loc_y;
    int agent_task_direction_square = agent_task_direction_x * agent_task_direction_x +
                                      agent_task_direction_y * agent_task_direction_y;

    for(int j=0;j<env->goal_locations.size();j++)
    {
        if (j != _agent_id && !env->goal_locations[j].empty()) // 所有agent都会有任务, 所以都要计入
        {
            int other_agent_goal = env->goal_locations[j][0].first;
            int other_agent_goal_x = other_agent_goal % env->cols;
            int other_agent_goal_y = other_agent_goal / env->cols;
            // cout << "other agent goal " << other_agent_goal << " " << other_agent_goal_x << " "
            // << other_agent_goal_y << endl;

            int agent_other_direction_x = other_agent_goal_x - _agent_loc_x;
            int agent_other_direction_y = other_agent_goal_y - _agent_loc_y;
            // cout << "other agent direction " << agent_other_direction_x << " " << other_agent_loc_y << endl;
            int agent_other_distance_square = agent_other_direction_x * agent_other_direction_x
                                              + agent_other_direction_y * agent_other_direction_y;

            int other_task_direction_x = pickup_loc_x - other_agent_goal_x;
            int other_task_direction_y = pickup_loc_y - other_agent_goal_y;
            // cout << "other agent direction " << agent_other_direction_x << " " << other_agent_loc_y << endl;
            int other_task_distance_square = other_task_direction_x * other_task_direction_x
                                             + other_task_direction_y * other_task_direction_y;

            // 只统计以task为圆心, agent-task范围内的other agent
            if(other_task_distance_square < agent_task_direction_square)
            {
                int inner_product = agent_other_direction_x * agent_task_direction_x
                                    + agent_other_direction_y * agent_task_direction_y;

                // cout << "task direction: " << agent_task_direction_x << " " << agent_task_direction_y << " "
                // << task_direction_length << endl;

                sum_jam_weight += double (inner_product) / agent_other_distance_square;
            }
        }
    }

    return sum_jam_weight;
}

// 以task pickup为圆心，agent-task为半径朝向task画出一个圆，位于这个圆内的other agent goal的数量为拥堵系数。
void TaskScheduler::adaptive_jam_task_circle_vector_goal(int time_limit, std::vector<int> & proposed_schedule)
{
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for(auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                 << " minDist " << agent_task[element].min_task_dist
                 << " heuristic " << agent_task[element].task_heuristic
                 << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                 << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if(numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;
        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            //check for timeout every 10 task evaluations
            if (std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations){
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            /*
            if(OneDim2TwoDim.find(env->task_pool[t_id].locations[0]) == OneDim2TwoDim.end())
            {
                cerr << "map error!" << endl;
            }
            */

            int pickup_loc = env->task_pool[t_id].locations[0];
            double sum_jam_weight = compute_jam_task_circle_vector_goal(i, agent_loc_x,
                                                                    agent_loc_y, pickup_loc);

            // sum_jam_weight * jam_coefficient = guess delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic){
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1){
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist  = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
            // nothing to assign
        else{
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Time Usage: " <<  ((float)(clock() - start))/CLOCKS_PER_SEC <<endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: "<< env->new_tasks.size() <<  endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

int TaskScheduler::compute_jam_task_circle_count_both_current_goal(int _agent_id, int _agent_loc_x, int _agent_loc_y,
                                                    int _pickup_loc) const
{
    int sum_jam_weight = 0;

    int pickup_loc_x = _pickup_loc % env->cols;
    int pickup_loc_y = _pickup_loc / env->cols;
    // cout << "pickup loc " << pickup_twodim.x << " " << pickup_twodim.y << endl;

    // 当前agent指向某个任务的向量
    int agent_task_direction_x = pickup_loc_x - _agent_loc_x;
    int agent_task_direction_y = pickup_loc_y - _agent_loc_y;
    int agent_task_direction_square = agent_task_direction_x * agent_task_direction_x +
                                      agent_task_direction_y * agent_task_direction_y;

    for(int j=0;j<env->goal_locations.size();j++)
    {
        if (j != _agent_id && !env->goal_locations[j].empty()) // 仅计入有目标点的agent
        {
            int other_agent_loc = env->curr_states.at(j).location;
            int other_agent_loc_x = other_agent_loc % env->cols;
            int other_agent_loc_y = other_agent_loc / env->cols;
            // cout << "other agent loc " << other_agent_loc << " " << other_agent_loc_x << " "
            // << other_agent_loc_y << endl;

            int other_task_direction_x = pickup_loc_x - other_agent_loc_x;
            int other_task_direction_y = pickup_loc_y - other_agent_loc_y;
            // cout << "other agent direction " << agent_other_direction_x << " " << other_agent_loc_y << endl;
            int other_task_distance_square = other_task_direction_x * other_task_direction_x
                                             + other_task_direction_y * other_task_direction_y;

            // 统计以task为圆心, agent-task范围内的other agent
            if(other_task_distance_square < agent_task_direction_square)
            {
                sum_jam_weight++;
            }

            int other_agent_goal = env->goal_locations[j][0].first;
            int other_agent_goal_x = other_agent_goal % env->cols;
            int other_agent_goal_y = other_agent_goal / env->cols;
            // cout << "other agent goal " << other_agent_goal << " " << other_agent_goal_x << " "
            // << other_agent_goal_y << endl;

            int goal_task_direction_x = pickup_loc_x - other_agent_goal_x;
            int goal_task_direction_y = pickup_loc_y - other_agent_goal_y;
            // cout << "other agent direction " << agent_other_direction_x << " " << other_agent_loc_y << endl;
            int goal_task_distance_square = goal_task_direction_x * goal_task_direction_x
                                            + goal_task_direction_y * goal_task_direction_y;

            // 统计以task为圆心, agent-task范围内的other agent goal
            if(goal_task_distance_square < agent_task_direction_square)
            {
                sum_jam_weight++;
            }
        }
    }

    return sum_jam_weight;
}

// 统计以task为圆心，|agent-task|为半径的圆中other agent current location 和 goal的数量作为jam.
void TaskScheduler::adaptive_jam_task_circle_count_both_current_goal(int time_limit, std::vector<int> & proposed_schedule)
{
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for(auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                 << " minDist " << agent_task[element].min_task_dist
                 << " heuristic " << agent_task[element].task_heuristic
                 << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                 << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if(numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;
        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            //check for timeout every 10 task evaluations
            if (count % 10 == 0 && std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations){
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            /*
            if(OneDim2TwoDim.find(env->task_pool[t_id].locations[0]) == OneDim2TwoDim.end())
            {
                cerr << "map error!" << endl;
            }
            */

            int pickup_loc = env->task_pool[t_id].locations[0];
            int sum_jam_weight = compute_jam_task_circle_count_both_current_goal(i, agent_loc_x,
                                                                                 agent_loc_y, pickup_loc);

            // sum_jam_weight * jam_coefficient = guess delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic){
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1){
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist  = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
            // nothing to assign
        else{
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Time Usage: " <<  ((float)(clock() - start))/CLOCKS_PER_SEC <<endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: "<< env->new_tasks.size() <<  endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 统计以task为圆心，|agent-task|为半径的圆中other agent current location 和 goal的数量作为jam.
void TaskScheduler::adaptive_jam_task_circle_count_both_current_goal_compare_dist(int time_limit,
                                                              std::vector<int> & proposed_schedule)
{
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for(auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                 << " minDist " << agent_task[element].min_task_dist
                 << " heuristic " << agent_task[element].task_heuristic
                 << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                 << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if(numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;
        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            //check for timeout every 10 task evaluations
            if (count % 10 == 0 && std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations){
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            if (dist < min_task_heuristic)
            {
                int pickup_loc = env->task_pool[t_id].locations[0];
                int sum_jam_weight = compute_jam_task_circle_count_both_current_goal(i,
                                                             agent_loc_x, agent_loc_y, pickup_loc);

                // sum_jam_weight * jam_coefficient = guess delay time
                if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic){
                    min_task_i = t_id;
                    min_task_dist = dist;
                    min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                    corresponding_traffic_jam = sum_jam_weight;
                }
            }

            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1){
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist  = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
            // nothing to assign
        else{
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Time Usage: " <<  ((float)(clock() - start))/CLOCKS_PER_SEC <<endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: "<< env->new_tasks.size() <<  endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

void TaskScheduler::hungarian_sum_snatch_adaptive_jam_task_circle_count_both_current_goal(
        int time_limit, std::vector<int> & proposed_schedule)
{
    //use at most half of time_limit to compute schedule, -10 for timing error tolerance
    //so that the remainning time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;
    clock_t start = clock();

    // 没有新agent就不用抢单了
    if(env->new_freeagents.empty())
    {
        return;
    }

    //*
    for(auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                 << " minDist " << agent_task[element].min_task_dist
                 << " heuristic " << agent_task[element].task_heuristic
                 << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                 << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if(numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    int counter = 0;
    for (const int& free_task_id : free_tasks)
    {
        if (counter % 10 == 0 && std::chrono::steady_clock::now() > endtime)
        {
            break;
        }

        // this task distance has been calculated
        if (task_distances.find(free_task_id) == task_distances.end())
        {
            int total_dist = 0;
            int curr_loc = env->task_pool[free_task_id].locations[0];

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[free_task_id].locations)
            {
                total_dist += DefaultPlanner::get_h(env, curr_loc, loc);
                curr_loc = loc;
            }

            task_distances[free_task_id] = total_dist;
            counter++;
            // cout << counter << endl;
        }
        else
        {
            // cout << "already in" << endl;
        }
    }

    // free agent and agent with task but before pickup
    std::vector<int> free_agents_and_before_pickup;
    free_agents_and_before_pickup.assign(free_agents.begin(), free_agents.end());

    // free tasks and tasks already assigned but before pickup
    std::vector<int> free_tasks_and_before_pickup;
    free_tasks_and_before_pickup.assign(free_tasks.begin(), free_tasks.end());

    for(const auto& element : env->task_pool)
    {
        if(element.second.agent_assigned != -1 && element.second.idx_next_loc == 0)
        {
            free_agents_and_before_pickup.emplace_back(element.second.agent_assigned);
            free_tasks_and_before_pickup.emplace_back(element.second.task_id);
        }
    }

    // 每个时间步，空闲agent数量等于新出现任务的数量。
    // cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    vector< vector<int> > dist_matrix;
    dist_matrix.resize(free_agents_and_before_pickup.size());
    vector< vector<double> > jam_matrix;
    jam_matrix.resize(free_agents_and_before_pickup.size());
    vector< vector<double> > cost_matrix;
    cost_matrix.resize(free_agents_and_before_pickup.size());
    for(int i=0;i<cost_matrix.size();i++)
    {
        auto agent_id = free_agents_and_before_pickup[i];
        int curr_loc = env->curr_states.at(agent_id).location;
        int agent_loc_x = curr_loc % env->cols;
        int agent_loc_y = curr_loc / env->cols;

        dist_matrix[i].resize(free_tasks_and_before_pickup.size(), 0);
        jam_matrix[i].resize(free_tasks_and_before_pickup.size(), 0);
        cost_matrix[i].resize(free_tasks_and_before_pickup.size(), 0);

        for(int j=0;j<free_tasks_and_before_pickup.size();j++)
        {
            auto task_id = free_tasks_and_before_pickup[j];
            int pickup_loc = env->task_pool[task_id].locations[0];

            int sum_jam_weight = compute_jam_task_circle_count_both_current_goal(agent_id,
                                                             agent_loc_x, agent_loc_y, pickup_loc);
            // cout << "traffic jam: " << sum_jam_weight << endl;

            int dist = DefaultPlanner::get_h(env, curr_loc, pickup_loc) + task_distances[task_id];
            dist_matrix[i][j] = dist;
            // 在算代价时, sum_jam_weight要乘以系数; 记录时, 不乘系数
            jam_matrix[i][j] = sum_jam_weight;
            // 计算agent id完成task id的成本
            cost_matrix[i][j] = dist + sum_jam_weight * jam_coefficient;
        }
    }

    vector<int> work_assignment; // "worker " << i << ", assignment " << work_assignment[i]
    Hungarian HungAlgo(cost_matrix);
    // HungAlgo.print_cost_matrix();
    // cout << "prev cost: " << prev_best_total_distance << endl;
    int cost = HungAlgo.Solve(work_assignment); // 如果后续算拥堵系数, cost和prev_best的类型改成double
    // cout << "new cost: " << cost << endl;

    if (cost != prev_best_total_distance)
    {
        prev_best_total_distance = cost;
        free_agents.clear();
        free_agents.insert(free_agents_and_before_pickup.begin(), free_agents_and_before_pickup.end());
        free_tasks.clear();
        free_tasks.insert(free_tasks_and_before_pickup.begin(), free_tasks_and_before_pickup.end());

        for(int i=0; i < free_agents_and_before_pickup.size(); i++)
        {
            int assigned_agent = free_agents_and_before_pickup[i];
            int assigned_task = free_tasks_and_before_pickup[work_assignment[i]];

            proposed_schedule[assigned_agent] = assigned_task;

            // 该工人被分配了任务
            if(work_assignment[i] != -1)
            {
                free_agents.erase(free_agents_and_before_pickup[i]);
                free_tasks.erase(free_tasks_and_before_pickup[work_assignment[i]]);

                agent_task[assigned_agent].task_id = assigned_task;
                agent_task[assigned_agent].min_task_dist  = dist_matrix[i][work_assignment[i]];
                agent_task[assigned_agent].task_heuristic = cost_matrix[i][work_assignment[i]];
                agent_task[assigned_agent].assign_moment = env->curr_timestep; // assign task moment
                agent_task[assigned_agent].jam_when_assign = jam_matrix[i][work_assignment[i]];
                // cout << "jam when assign: " << agent_task[assigned_agent].jam_when_assign << endl;
            }
        }
    }

    /*
    cout << "work assignment: ";
    for(int i=0;i<work_assignment.size();i++)
    {
        cout << work_assignment[i] << " ";
    }
    cout << endl;
     */

    /*
    cout << "proposed schedule: ";
    for(int i=0;i<proposed_schedule.size();i++)
    {
        cout << proposed_schedule[i] << " ";
    }
    cout << endl;
     //*/

    cout << "Time Usage: " <<  ((float)(clock() - start))/CLOCKS_PER_SEC <<endl;
    // cout << "hungarian total distance: " << cost << endl; // 2087, 比默认方法确实缩小了
}

// 计算adaptive_jam_middle_current_goal_task_circle_count的估计延迟时间
int TaskScheduler::compute_jam_task_circle_count_middle_current_goal(int _agent_id,
                                                                     int _agent_loc_x, int _agent_loc_y, int _pickup_loc) const
{
    int sum_jam_weight = 0;

    int pickup_loc_x = _pickup_loc % env->cols;
    int pickup_loc_y = _pickup_loc / env->cols;
    // cout << "pickup loc " << pickup_twodim.x << " " << pickup_twodim.y << endl;

    // 当前agent指向某个任务的向量
    int agent_task_direction_x = pickup_loc_x - _agent_loc_x;
    int agent_task_direction_y = pickup_loc_y - _agent_loc_y;
    int agent_task_direction_square = agent_task_direction_x * agent_task_direction_x +
                                      agent_task_direction_y * agent_task_direction_y;

    for(int j=0;j<env->goal_locations.size();j++)
    {
        if (j != _agent_id && !env->goal_locations[j].empty()) // 所有agent都会有任务, 所以都要计入
        {
            int other_agent_goal = env->goal_locations[j][0].first;
            // int temp_other_agent_goal = env->task_pool[env->curr_task_schedule[j]].get_next_loc();
            // cout << "temp_other_agent_goal: " << temp_other_agent_goal << endl;
            
            int other_agent_goal_x = other_agent_goal % env->cols;
            int other_agent_goal_y = other_agent_goal / env->cols;
            // cout << "other agent goal " << other_agent_goal << " " << other_agent_goal_x << " "
            // << other_agent_goal_y << endl;

            int other_agent_loc = env->curr_states.at(j).location;
            int other_agent_loc_x = other_agent_loc % env->cols;
            int other_agent_loc_y = other_agent_loc / env->cols;

            // 其他agent当前位置和目标点位置的中点
            int other_agent_middle_x = (other_agent_loc_x + other_agent_goal_x) / 2;
            int other_agent_middle_y = (other_agent_loc_y + other_agent_goal_y) / 2;

            // 其他agent当前位置和目标点位置的中点到pickup的向量
            int middle_task_direction_x = pickup_loc_x - other_agent_middle_x;
            int middle_task_direction_y = pickup_loc_y - other_agent_middle_y;
            // cout << "other agent direction " << agent_other_direction_x << " " << other_agent_loc_y << endl;
            int middle_task_distance_square = middle_task_direction_x * middle_task_direction_x
                                              + middle_task_direction_y * middle_task_direction_y;

            // 统计以task为圆心, agent-task范围内的other agent当前位置和目标点位置的中点的数量
            if(middle_task_distance_square < agent_task_direction_square)
            {
                sum_jam_weight++;
            }
        }
    }

    return sum_jam_weight;
}

// 6: 统计以task为圆心，|agent-task|为半径的圆中, other agent 当前位置和目标点位置的中点的数量作为jam.
void TaskScheduler::adaptive_jam_task_circle_count_middle_current_goal(int time_limit,
                                                                       std::vector<int> & proposed_schedule)
{
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for(auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                 << " minDist " << agent_task[element].min_task_dist
                 << " heuristic " << agent_task[element].task_heuristic
                 << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                 << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if(numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;
        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            //check for timeout every 10 task evaluations
            if (count % 10 == 0 && std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations){
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            int pickup_loc = env->task_pool[t_id].locations[0];
            int sum_jam_weight = compute_jam_task_circle_count_middle_current_goal(i,
                                                           agent_loc_x, agent_loc_y, pickup_loc);

            // sum_jam_weight * jam_coefficient = guess delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic){
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }

            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1){
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist  = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
            // nothing to assign
        else{
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Time Usage: " <<  ((float)(clock() - start))/CLOCKS_PER_SEC <<endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: "<< env->new_tasks.size() <<  endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 计算adaptive_jam_middle_current_goal_task_circle_count的估计延迟时间
int TaskScheduler::compute_jam_task_circle_count_middle_current_next_goal(int _agent_id,
    int _agent_loc_x, int _agent_loc_y, int _pickup_loc) const
{
    int sum_jam_weight = 0;

    int pickup_loc_x = _pickup_loc % env->cols;
    int pickup_loc_y = _pickup_loc / env->cols;
    // cout << "pickup loc " << pickup_twodim.x << " " << pickup_twodim.y << endl;

    // 当前agent指向某个任务的向量
    int agent_task_direction_x = pickup_loc_x - _agent_loc_x;
    int agent_task_direction_y = pickup_loc_y - _agent_loc_y;
    int agent_task_direction_square = agent_task_direction_x * agent_task_direction_x +
        agent_task_direction_y * agent_task_direction_y;

    for (int j = 0; j < env->goal_locations.size(); j++)
    {
        if (j != _agent_id && !env->goal_locations[j].empty()) // 所有agent都会有任务, 所以都要计入
        {
            int goal_index = env->task_pool[env->curr_task_schedule[j]].idx_next_loc;
            // cout << "goal index: " << goal_index << endl;
            int other_agent_goal = env->goal_locations[j][goal_index].first;
            // int temp_other_agent_goal = env->task_pool[env->curr_task_schedule[j]].get_next_loc();
            // cout << "temp_other_agent_goal: " << temp_other_agent_goal << endl;

            int other_agent_goal_x = other_agent_goal % env->cols;
            int other_agent_goal_y = other_agent_goal / env->cols;
            // cout << "other agent goal " << other_agent_goal << " " << other_agent_goal_x << " "
            // << other_agent_goal_y << endl;

            int other_agent_loc = env->curr_states.at(j).location;
            int other_agent_loc_x = other_agent_loc % env->cols;
            int other_agent_loc_y = other_agent_loc / env->cols;

            // 其他agent当前位置和目标点位置的中点
            int other_agent_middle_x = (other_agent_loc_x + other_agent_goal_x) / 2;
            int other_agent_middle_y = (other_agent_loc_y + other_agent_goal_y) / 2;

            // 其他agent当前位置和目标点位置的中点到pickup的向量
            int middle_task_direction_x = pickup_loc_x - other_agent_middle_x;
            int middle_task_direction_y = pickup_loc_y - other_agent_middle_y;
            // cout << "other agent direction " << agent_other_direction_x << " " << other_agent_loc_y << endl;
            int middle_task_distance_square = middle_task_direction_x * middle_task_direction_x
                + middle_task_direction_y * middle_task_direction_y;

            // 统计以task为圆心, agent-task范围内的other agent当前位置和目标点位置的中点的数量
            if (middle_task_distance_square < agent_task_direction_square)
            {
                sum_jam_weight++;
            }
        }
    }

    return sum_jam_weight;
}

// 6.0: 统计以task为圆心，|agent-task|为半径的圆中, other agent 当前位置和下一个目标点位置的中点的数量作为jam.
void TaskScheduler::adaptive_jam_task_circle_count_middle_current_next_goal(int time_limit,
    std::vector<int>& proposed_schedule)
{
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;
        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            //check for timeout every 10 task evaluations
            if (count % 10 == 0 && std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations) {
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            int pickup_loc = env->task_pool[t_id].locations[0];
            int sum_jam_weight = compute_jam_task_circle_count_middle_current_next_goal(i,
                agent_loc_x, agent_loc_y, pickup_loc);

            // sum_jam_weight * jam_coefficient = guess delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic) {
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }

            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1) {
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
        // nothing to assign
        else {
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 计算adaptive_jam_middle_current_goal_task_circle_count的估计延迟时间
double TaskScheduler::compute_jam_task_circle_middle_current_goal_density(int _agent_id,
    int _agent_loc_x, int _agent_loc_y, int _pickup_loc) const
{
    int middle_current_goal_count = 0;

    int pickup_loc_x = _pickup_loc % env->cols;
    int pickup_loc_y = _pickup_loc / env->cols;
    // cout << "pickup loc " << pickup_twodim.x << " " << pickup_twodim.y << endl;

    // 当前agent指向某个任务的向量
    int agent_task_direction_x = pickup_loc_x - _agent_loc_x;
    int agent_task_direction_y = pickup_loc_y - _agent_loc_y;
    int agent_task_direction_square = agent_task_direction_x * agent_task_direction_x +
        agent_task_direction_y * agent_task_direction_y;

    for (int j = 0; j < env->goal_locations.size(); j++)
    {
        if (j != _agent_id && !env->goal_locations[j].empty()) // 所有agent都会有任务, 所以都要计入
        {
            int other_agent_goal = env->goal_locations[j][0].first;
            int other_agent_goal_x = other_agent_goal % env->cols;
            int other_agent_goal_y = other_agent_goal / env->cols;
            // cout << "other agent goal " << other_agent_goal << " " << other_agent_goal_x << " "
            // << other_agent_goal_y << endl;

            int other_agent_loc = env->curr_states.at(j).location;
            int other_agent_loc_x = other_agent_loc % env->cols;
            int other_agent_loc_y = other_agent_loc / env->cols;

            // 其他agent当前位置和目标点位置的中点
            int other_agent_middle_x = (other_agent_loc_x + other_agent_goal_x) / 2;
            int other_agent_middle_y = (other_agent_loc_y + other_agent_goal_y) / 2;

            // 其他agent当前位置和目标点位置的中点到pickup的向量
            int middle_task_direction_x = pickup_loc_x - other_agent_middle_x;
            int middle_task_direction_y = pickup_loc_y - other_agent_middle_y;
            // cout << "other agent direction " << agent_other_direction_x << " " << other_agent_loc_y << endl;
            int middle_task_distance_square = middle_task_direction_x * middle_task_direction_x
                + middle_task_direction_y * middle_task_direction_y;

            // 统计以task为圆心, agent-task范围内的other agent当前位置和目标点位置的中点的数量
            if (middle_task_distance_square < agent_task_direction_square)
            {
                middle_current_goal_count++;
            }
        }
    }

    double middle_current_goal_density = double(middle_current_goal_count) / agent_task_direction_square;

    return middle_current_goal_density;
}


// 6.1: 计算以task为圆心，|agent-task|为半径的圆中, other agent 当前位置和目标点位置的中点的密度作为jam.
void TaskScheduler::adaptive_jam_task_circle_middle_current_goal_density(int time_limit,
    std::vector<int>& proposed_schedule)
{
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;
        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            //check for timeout every 10 task evaluations
            if (count % 10 == 0 && std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations) {
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            int pickup_loc = env->task_pool[t_id].locations[0];
            double sum_jam_weight = compute_jam_task_circle_middle_current_goal_density(i,
                agent_loc_x, agent_loc_y, pickup_loc);

            // sum_jam_weight * jam_coefficient = guess delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic) {
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }

            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1) {
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
        // nothing to assign
        else {
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 6.2: 以task为圆心，|agent-task|为半径的圆中, other agent 当前位置和目标点位置的中点的密度 x |agent pickup|作为jam.
void TaskScheduler::adaptive_jam_task_circle_middle_current_goal_density_times_agent_pickup(int time_limit,
    std::vector<int>& proposed_schedule)
{
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;
        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            //check for timeout every 10 task evaluations
            if (count % 10 == 0 && std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations) {
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            int curr_loc = env->curr_states.at(i).location;
            int pickup_loc = env->task_pool[t_id].locations[0];
            double sum_jam_weight = compute_jam_task_circle_middle_current_goal_density(i,
                agent_loc_x, agent_loc_y, pickup_loc) * DefaultPlanner::get_h(env, curr_loc, pickup_loc);

            // sum_jam_weight * jam_coefficient = guess delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic) {
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }

            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1) {
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
        // nothing to assign
        else {
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 6.3: 以task为圆心，|agent-task|为半径的圆中, other agent 当前位置和目标点位置的中点的密度 x |agent pickup delivery|作为jam.
void TaskScheduler::adaptive_jam_task_circle_middle_current_goal_density_times_agent_pickup_delivery(int time_limit,
    std::vector<int>& proposed_schedule)
{
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;
        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            //check for timeout every 10 task evaluations
            if (count % 10 == 0 && std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations) {
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            int curr_loc = env->curr_states.at(i).location;
            int pickup_loc = env->task_pool[t_id].locations[0];
            double sum_jam_weight = compute_jam_task_circle_middle_current_goal_density(i,
                agent_loc_x, agent_loc_y, pickup_loc) * dist;

            // sum_jam_weight * jam_coefficient = guess delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic) {
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }

            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1) {
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
        // nothing to assign
        else {
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 统计以task为圆心，|agent-task|为半径的圆中, other agent 当前位置和目标点位置的中点的数量作为jam.
void TaskScheduler::adaptive_jam_task_circle_count_middle_current_goal_compare_dist(int time_limit, std::vector<int> & proposed_schedule)
{
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for(auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                 << " minDist " << agent_task[element].min_task_dist
                 << " heuristic " << agent_task[element].task_heuristic
                 << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                 << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if(numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;
        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            //check for timeout every 10 task evaluations
            if (count % 10 == 0 && std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations){
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            /*
            if(OneDim2TwoDim.find(env->task_pool[t_id].locations[0]) == OneDim2TwoDim.end())
            {
                cerr << "map error!" << endl;
            }
            */

            // 排除dist >= min_task_heuristic的情况
            if (dist < min_task_heuristic)
            {
                int pickup_loc = env->task_pool[t_id].locations[0];
                int sum_jam_weight = compute_jam_task_circle_count_middle_current_goal(i,
                                                                                       agent_loc_x, agent_loc_y,
                                                                                       pickup_loc);

                // sum_jam_weight * jam_coefficient = guess delay time
                if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic){
                    min_task_i = t_id;
                    min_task_dist = dist;
                    min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                    corresponding_traffic_jam = sum_jam_weight;
                }
            }

            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1){
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist  = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
            // nothing to assign
        else{
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Time Usage: " <<  ((float)(clock() - start))/CLOCKS_PER_SEC <<endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: "<< env->new_tasks.size() <<  endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// hungarian_sum_snatch计算cost matrix加上adaptive_jam_middle_current_goal_task_circle_count
void TaskScheduler::hungarian_sum_snatch_adaptive_jam_task_circle_count_middle_current_goal(
        int time_limit, std::vector<int> & proposed_schedule)
{
    //use at most half of time_limit to compute schedule, -10 for timing error tolerance
    //so that the remainning time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;
    clock_t start = clock();

    // 没有新agent就不用抢单了
    if(env->new_freeagents.empty())
    {
        return;
    }

    //*
    for(auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                 << " minDist " << agent_task[element].min_task_dist
                 << " heuristic " << agent_task[element].task_heuristic
                 << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                 << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if(numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    int counter = 0;
    for (const int& free_task_id : free_tasks)
    {
        if (counter % 10 == 0 && std::chrono::steady_clock::now() > endtime)
        {
            break;
        }

        // this task distance has been calculated
        if (task_distances.find(free_task_id) == task_distances.end())
        {
            int total_dist = 0;
            int curr_loc = env->task_pool[free_task_id].locations[0];

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[free_task_id].locations)
            {
                total_dist += DefaultPlanner::get_h(env, curr_loc, loc);
                curr_loc = loc;
            }

            task_distances[free_task_id] = total_dist;
            counter++;
            // cout << counter << endl;
        }
        else
        {
            // cout << "already in" << endl;
        }
    }

    // free agent and agent with task but before pickup
    std::vector<int> free_agents_and_before_pickup;
    free_agents_and_before_pickup.assign(free_agents.begin(), free_agents.end());

    // free tasks and tasks already assigned but before pickup
    std::vector<int> free_tasks_and_before_pickup;
    free_tasks_and_before_pickup.assign(free_tasks.begin(), free_tasks.end());

    for(const auto& element : env->task_pool)
    {
        if(element.second.agent_assigned != -1 && element.second.idx_next_loc == 0)
        {
            free_agents_and_before_pickup.emplace_back(element.second.agent_assigned);
            free_tasks_and_before_pickup.emplace_back(element.second.task_id);
        }
    }

    // 每个时间步，空闲agent数量等于新出现任务的数量。
    // cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    vector< vector<int> > dist_matrix;
    dist_matrix.resize(free_agents_and_before_pickup.size());
    vector< vector<double> > jam_matrix;
    jam_matrix.resize(free_agents_and_before_pickup.size());
    vector< vector<double> > cost_matrix;
    cost_matrix.resize(free_agents_and_before_pickup.size());
    for(int i=0;i<cost_matrix.size();i++)
    {
        auto agent_id = free_agents_and_before_pickup[i];
        int curr_loc = env->curr_states.at(agent_id).location;
        int agent_loc_x = curr_loc % env->cols;
        int agent_loc_y = curr_loc / env->cols;

        dist_matrix[i].resize(free_tasks_and_before_pickup.size(), 0);
        jam_matrix[i].resize(free_tasks_and_before_pickup.size(), 0);
        cost_matrix[i].resize(free_tasks_and_before_pickup.size(), 0);

        for(int j=0;j<free_tasks_and_before_pickup.size();j++)
        {
            auto task_id = free_tasks_and_before_pickup[j];
            int pickup_loc = env->task_pool[task_id].locations[0];

            int sum_jam_weight = compute_jam_task_circle_count_middle_current_goal(agent_id,
                                                                                   agent_loc_x, agent_loc_y, pickup_loc);
            // cout << "traffic jam: " << sum_jam_weight << endl;

            int dist = DefaultPlanner::get_h(env, curr_loc, pickup_loc) + task_distances[task_id];
            dist_matrix[i][j] = dist;
            // 在算代价时, sum_jam_weight要乘以系数; 记录时, 不乘系数
            jam_matrix[i][j] = sum_jam_weight;
            // 计算agent id完成task id的成本
            cost_matrix[i][j] = dist + sum_jam_weight * jam_coefficient;
        }
    }

    vector<int> work_assignment; // "worker " << i << ", assignment " << work_assignment[i]
    Hungarian HungAlgo(cost_matrix);
    // HungAlgo.print_cost_matrix();
    // cout << "prev cost: " << prev_best_total_distance << endl;
    int cost = HungAlgo.Solve(work_assignment); // 如果后续算拥堵系数, cost和prev_best的类型改成double
    // cout << "new cost: " << cost << endl;

    if (cost != prev_best_total_distance)
    {
        prev_best_total_distance = cost;
        free_agents.clear();
        free_agents.insert(free_agents_and_before_pickup.begin(), free_agents_and_before_pickup.end());
        free_tasks.clear();
        free_tasks.insert(free_tasks_and_before_pickup.begin(), free_tasks_and_before_pickup.end());

        for(int i=0; i < free_agents_and_before_pickup.size(); i++)
        {
            int assigned_agent = free_agents_and_before_pickup[i];
            int assigned_task = free_tasks_and_before_pickup[work_assignment[i]];

            proposed_schedule[assigned_agent] = assigned_task;

            // 该工人被分配了任务
            if(work_assignment[i] != -1)
            {
                free_agents.erase(free_agents_and_before_pickup[i]);
                free_tasks.erase(free_tasks_and_before_pickup[work_assignment[i]]);

                agent_task[assigned_agent].task_id = assigned_task;
                agent_task[assigned_agent].min_task_dist  = dist_matrix[i][work_assignment[i]];
                agent_task[assigned_agent].task_heuristic = cost_matrix[i][work_assignment[i]];
                agent_task[assigned_agent].assign_moment = env->curr_timestep; // assign task moment
                agent_task[assigned_agent].jam_when_assign = jam_matrix[i][work_assignment[i]];
                // cout << "jam when assign: " << agent_task[assigned_agent].jam_when_assign << endl;
            }
        }
    }

    /*
    cout << "work assignment: ";
    for(int i=0;i<work_assignment.size();i++)
    {
        cout << work_assignment[i] << " ";
    }
    cout << endl;
     */

    /*
    cout << "proposed schedule: ";
    for(int i=0;i<proposed_schedule.size();i++)
    {
        cout << proposed_schedule[i] << " ";
    }
    cout << endl;
     //*/

    cout << "Time Usage: " <<  ((float)(clock() - start))/CLOCKS_PER_SEC <<endl;
    // cout << "hungarian total distance: " << cost << endl; // 2087, 比默认方法确实缩小了
}

// 7: 计算jam_task_Manhattan_circle_count_middle_current_goal的估计延迟时间
int TaskScheduler::compute_jam_task_Manhattan_circle_count_middle_current_goal(int _agent_id,
                                                                               int _agent_loc_x, int _agent_loc_y, int _pickup_loc) const
{
    int sum_jam_weight = 0;

    int pickup_loc_x = _pickup_loc % env->cols;
    int pickup_loc_y = _pickup_loc / env->cols;
    // cout << "pickup loc " << pickup_twodim.x << " " << pickup_twodim.y << endl;

    // 当前agent指向某个任务的向量
    int agent_task_direction_x = pickup_loc_x - _agent_loc_x;
    int agent_task_direction_y = pickup_loc_y - _agent_loc_y;
    int agent_task_Manhattan_distance = std::abs(agent_task_direction_x) +
                                        std::abs(agent_task_direction_y);

    for(int j=0;j<env->goal_locations.size();j++)
    {
        if (j != _agent_id && !env->goal_locations[j].empty()) // 所有agent都会有任务, 所以都要计入
        {
            int other_agent_goal = env->goal_locations[j][0].first;
            int other_agent_goal_x = other_agent_goal % env->cols;
            int other_agent_goal_y = other_agent_goal / env->cols;
            // cout << "other agent goal " << other_agent_goal << " " << other_agent_goal_x << " "
            // << other_agent_goal_y << endl;

            int other_agent_loc = env->curr_states.at(j).location;
            int other_agent_loc_x = other_agent_loc % env->cols;
            int other_agent_loc_y = other_agent_loc / env->cols;

            // 其他agent当前位置和目标点位置的中点
            int other_agent_middle_x = (other_agent_loc_x + other_agent_goal_x) / 2;
            int other_agent_middle_y = (other_agent_loc_y + other_agent_goal_y) / 2;

            // 其他agent当前位置和目标点位置的中点到pickup的向量
            int middle_task_direction_x = pickup_loc_x - other_agent_middle_x;
            int middle_task_direction_y = pickup_loc_y - other_agent_middle_y;
            // cout << "other agent direction " << agent_other_direction_x << " " << other_agent_loc_y << endl;
            int middle_task_Manhattan_distance = std::abs(middle_task_direction_x)
                                                 + std::abs(middle_task_direction_y);

            // 统计以task为圆心, agent-task曼哈顿范围内的other agent当前位置和目标点位置的中点的数量
            if(middle_task_Manhattan_distance < agent_task_Manhattan_distance)
            {
                sum_jam_weight++;
            }
        }
    }

    return sum_jam_weight;
}

// 统计以task为圆心，|agent-task|为半径的Manhattan圆中, other agent 当前位置和目标点位置的中点的数量作为jam.
void TaskScheduler::adaptive_jam_task_Manhattan_circle_count_middle_current_goal(int time_limit,
                                                                                 std::vector<int> & proposed_schedule)
{
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for(auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                 << " minDist " << agent_task[element].min_task_dist
                 << " heuristic " << agent_task[element].task_heuristic
                 << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                 << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if(numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;
        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            //check for timeout every 10 task evaluations
            if (count % 10 == 0 && std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations){
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                // dist += sorting_grid.heuristics[c_loc].at(loc);
                c_loc = loc;
            }

            int pickup_loc = env->task_pool[t_id].locations[0];
            int sum_jam_weight = compute_jam_task_Manhattan_circle_count_middle_current_goal(i,
                                                                                             agent_loc_x, agent_loc_y, pickup_loc);

            // sum_jam_weight * jam_coefficient = guess delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic){
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }

            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1){
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist  = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
            // nothing to assign
        else{
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Time Usage: " <<  ((float)(clock() - start))/CLOCKS_PER_SEC <<endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: "<< env->new_tasks.size() <<  endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 使用RHCR启发式
void TaskScheduler::adaptive_jam_task_Manhattan_circle_count_middle_current_goal_rhcr(
        int time_limit, std::vector<int> & proposed_schedule)
{
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for(auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                 << " minDist " << agent_task[element].min_task_dist
                 << " heuristic " << agent_task[element].task_heuristic
                 << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                 << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if(numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;
        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            //check for timeout every 10 task evaluations
            if (count % 10 == 0 && std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations){
                // 如果sorting_grid.heuristics[loc]没有计算, 就计算
                if(sorting_grid.heuristics.find(loc) == sorting_grid.heuristics.end())
                {
                    sorting_grid.heuristics[loc] =
                            sorting_grid.compute_heuristics(loc);
                }

                dist += sorting_grid.heuristics[loc].at(c_loc);
                c_loc = loc;
            }

            int pickup_loc = env->task_pool[t_id].locations[0];
            int sum_jam_weight = compute_jam_task_Manhattan_circle_count_middle_current_goal(i,
                                                                                             agent_loc_x, agent_loc_y, pickup_loc);

            // sum_jam_weight * jam_coefficient = guess delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic){
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }

            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1){
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist  = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
            // nothing to assign
        else{
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Time Usage: " <<  ((float)(clock() - start))/CLOCKS_PER_SEC <<endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: "<< env->new_tasks.size() <<  endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 8: 计算jam_task_fix_Manhattan_circle_count_middle_current_goal的估计延迟时间
int TaskScheduler::compute_jam_task_fix_Manhattan_circle_count_middle_current_goal(int _agent_id, int _pickup_loc) const
{
    int sum_jam_weight = 0;

    int pickup_loc_x = _pickup_loc % env->cols;
    int pickup_loc_y = _pickup_loc / env->cols;
    // cout << "pickup loc " << pickup_twodim.x << " " << pickup_twodim.y << endl;

    for(int j=0;j<env->goal_locations.size();j++)
    {
        if (j != _agent_id && !env->goal_locations[j].empty()) // 所有agent都会有任务, 所以都要计入
        {
            int other_agent_goal = env->goal_locations[j][0].first;
            int other_agent_goal_x = other_agent_goal % env->cols;
            int other_agent_goal_y = other_agent_goal / env->cols;
            // cout << "other agent goal " << other_agent_goal << " " << other_agent_goal_x << " "
            // << other_agent_goal_y << endl;

            int other_agent_loc = env->curr_states.at(j).location;
            int other_agent_loc_x = other_agent_loc % env->cols;
            int other_agent_loc_y = other_agent_loc / env->cols;

            // 其他agent当前位置和目标点位置的中点
            int other_agent_middle_x = (other_agent_loc_x + other_agent_goal_x) / 2;
            int other_agent_middle_y = (other_agent_loc_y + other_agent_goal_y) / 2;

            // 其他agent当前位置和目标点位置的中点到pickup的向量
            int middle_task_direction_x = pickup_loc_x - other_agent_middle_x;
            int middle_task_direction_y = pickup_loc_y - other_agent_middle_y;
            // cout << "other agent direction " << agent_other_direction_x << " " << other_agent_loc_y << endl;
            int middle_task_Manhattan_distance = std::abs(middle_task_direction_x)
                                                 + std::abs(middle_task_direction_y);

            // 统计以task为圆心, radius_count_agent曼哈顿范围内的other agent当前位置和目标点位置的中点的数量
            if(middle_task_Manhattan_distance < radius_count_agent)
            {
                sum_jam_weight++;
            }
        }
    }

    return sum_jam_weight;
}

// 8: 统计以task为圆心，|num_rows + num_columns| / 8为半径的Manhattan圆中, other agent 当前位置和目标点位置的中点的数量作为jam.
void TaskScheduler::adaptive_jam_task_fix_Manhattan_circle_count_middle_current_goal(int time_limit,
                                                                                 std::vector<int> & proposed_schedule)
{
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for(auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                 << " minDist " << agent_task[element].min_task_dist
                 << " heuristic " << agent_task[element].task_heuristic
                 << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                 << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if(numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            //check for timeout every 10 task evaluations
            if (count % 10 == 0 && std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations){
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            int pickup_loc = env->task_pool[t_id].locations[0];
            int sum_jam_weight = compute_jam_task_fix_Manhattan_circle_count_middle_current_goal(
                    i, pickup_loc);

            // sum_jam_weight * jam_coefficient = guess delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic){
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }

            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1){
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist  = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
            // nothing to assign
        else{
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Time Usage: " <<  ((float)(clock() - start))/CLOCKS_PER_SEC <<endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: "<< env->new_tasks.size() <<  endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 计算adaptive_jam_task_h_circle_count_middle_current_goal的估计延迟时间
int TaskScheduler::compute_jam_task_h_circle_count_middle_current_goal(int _agent_id, int _pickup_loc, int _h_radius) const
{
    int sum_jam_weight = 0;

    for (int j = 0; j < env->goal_locations.size(); j++)
    {
        if (j != _agent_id && !env->goal_locations[j].empty()) // 所有agent都会有任务, 所以都要计入
        {
            int other_agent_goal = env->goal_locations[j][0].first;
            // int other_agent_goal = env->task_pool[agent_task[j].task_id].get_next_loc(); 
            int other_agent_goal_x = other_agent_goal % env->cols;
            int other_agent_goal_y = other_agent_goal / env->cols;
            // cout << "other agent goal " << other_agent_goal << " " << other_agent_goal_x << " "
            // << other_agent_goal_y << endl;

            int other_agent_loc = env->curr_states.at(j).location;
            int other_agent_loc_x = other_agent_loc % env->cols;
            int other_agent_loc_y = other_agent_loc / env->cols;

            // 其他agent当前位置和目标点位置的中点
            int other_agent_middle_x = (other_agent_loc_x + other_agent_goal_x) / 2;
            int other_agent_middle_y = (other_agent_loc_y + other_agent_goal_y) / 2;
            int other_agent_middle = other_agent_middle_y * env->cols + other_agent_middle_x;

            // 其他agent当前位置和目标点位置的中点到pickup的启发式距离
            int middle_task_distance = DefaultPlanner::get_h(env, other_agent_middle, _pickup_loc);

            // 统计get_h(other middle, pickup) < get_h(agent, pickup), other agent 当前位置和目标点位置的中点的数量.
            if (middle_task_distance < _h_radius)
            {
                sum_jam_weight++;
            }
        }
    }

    return sum_jam_weight;
}

// 8.1: 统计get_h(other middle, pickup) < get_h(agent, pickup), other agent 当前位置和目标点位置的中点的数量作为jam.
void TaskScheduler::adaptive_jam_task_h_circle_count_middle_current_goal(int time_limit,
    std::vector<int>& proposed_schedule)
{
    cout << "adaptive jam task h circle count middle current goal" << endl;
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;
        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            //check for timeout every 10 task evaluations
            if (count % 10 == 0 && std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations) {
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            int curr_loc = env->curr_states.at(i).location;
            int pickup_loc = env->task_pool[t_id].locations[0];
            int h_radius = DefaultPlanner::get_h(env, curr_loc, pickup_loc);
            int sum_jam_weight = compute_jam_task_h_circle_count_middle_current_goal(i, pickup_loc, h_radius);

            // sum_jam_weight * jam_coefficient = guess delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic) {
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }

            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1) {
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
        // nothing to assign
        else {
            proposed_schedule[i] = -1;
            it++;
        }
    }

    /*
    if (agent_task[1].task_id != -1)
    {
        cout << "agent 1's curr goal index:" << env->task_pool[agent_task[1].task_id].idx_next_loc << endl;
        cout << "agent 1's curr goal loc:" << env->task_pool[agent_task[1].task_id].get_next_loc() << endl;
    }    
    */

    cout << "Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 9: 将地图分成16x16的区域, task所在区域中agent当前位置和目标点位置的中点的数量作为作为sum jam weight
void TaskScheduler::adaptive_jam_task_region_count_middle_current_goal(int time_limit,
                                                                       std::vector<int> & proposed_schedule)
{
    cout << "adaptive jam task region count middle current goal" << endl;
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for(auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                 << " minDist " << agent_task[element].min_task_dist
                 << " heuristic " << agent_task[element].task_heuristic
                 << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                 << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if(numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    if(free_agents.size() > 50)
    {
        if(first_epoch_done_time == -1)
        {
            // 由于大算例初始任务过多, 在初始任务分配完成前采用默认算法
            greedy_sum_without_newtask(time_limit, proposed_schedule);
            return;
        }
    }
    else
    {
        if(first_epoch_done_time == -1)
        {
            first_epoch_done_time = env->curr_timestep; // 初始阶段的任务分配完毕的时间
        }
    }

    int region_column = 15; // 每个region所占的列数
    int region_row = 15; // 每个region所占的行数

    // 地图有几列region
    int num_region_column = std::ceil((double)env->cols / region_column);
    // 地图有几行region
    int num_region_row = std::ceil((double)env->rows / region_row);

    // 将map分为若干区域, 统计每个区域agent当前位置和目标点位置的中点的数量
    vector<int> region_middle_num(num_region_column * num_region_row, 0);

    for (int i=0;i<env->num_of_agents;i++)
    {
        if (!env->goal_locations[i].empty()) // 只统计有目标的agent
        {
            int other_agent_goal = env->goal_locations[i][0].first;
            int other_agent_goal_x = other_agent_goal % env->cols;
            int other_agent_goal_y = other_agent_goal / env->cols;
            // cout << "other agent goal " << other_agent_goal << " " << other_agent_goal_x << " "
            // << other_agent_goal_y << endl;

            int other_agent_loc = env->curr_states.at(i).location;
            int other_agent_loc_x = other_agent_loc % env->cols;
            int other_agent_loc_y = other_agent_loc / env->cols;

            // 其他agent当前位置和目标点位置的中点
            int other_agent_middle_x = (other_agent_loc_x + other_agent_goal_x) / 2;
            int other_agent_middle_y = (other_agent_loc_y + other_agent_goal_y) / 2;

            int middle_region_x = other_agent_middle_x / region_column;
            int middle_region_y = other_agent_middle_y / region_row;

            region_middle_num[middle_region_y * num_region_column + middle_region_x]++;
        }
    }

    /*
    cout << "region agent num: ";
    for(int i : region_middle_num)
    {
        cout << i << " ";
    }
    cout << endl;
     //*/

    if(env->num_of_agents <= 500) // 小算例直接算
    {
        for (int t_id : env->new_tasks)
        {
            int pickup_loc = env->task_pool[t_id].locations[0];
            int pickup_loc_x = pickup_loc % env->cols;
            int pickup_loc_y = pickup_loc / env->cols;

            int pickup_region_x = pickup_loc_x / region_column;
            int pickup_region_y = pickup_loc_y / region_row;

            task_region[t_id] = pickup_region_y * num_region_column + pickup_region_x;
        }
    }
    else // 大算例
    {
        if(env->curr_timestep == first_epoch_done_time) // 在first_epoch_done_time计算完此时的free tasks
        {
            for (int t_id : free_tasks)
            {
                int pickup_loc = env->task_pool[t_id].locations[0];
                int pickup_loc_x = pickup_loc % env->cols;
                int pickup_loc_y = pickup_loc / env->cols;

                int pickup_region_x = pickup_loc_x / region_column;
                int pickup_region_y = pickup_loc_y / region_row;

                task_region[t_id] = pickup_region_y * num_region_column + pickup_region_x;
            }
        }
        else // first_epoch_done_time之后就只计算新任务
        {
            for (int t_id : env->new_tasks)
            {
                int pickup_loc = env->task_pool[t_id].locations[0];
                int pickup_loc_x = pickup_loc % env->cols;
                int pickup_loc_y = pickup_loc / env->cols;

                int pickup_region_x = pickup_loc_x / region_column;
                int pickup_region_y = pickup_loc_y / region_row;

                task_region[t_id] = pickup_region_y * num_region_column + pickup_region_x;
            }
        }
    }


    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            // check for timeout every 10 task evaluations
            if (std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations){
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            int pickup_loc = env->task_pool[t_id].locations[0];
            int sum_jam_weight = region_middle_num[task_region[t_id]];

            // sum_jam_weight * jam_coefficient = estimated delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic){
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1){
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist  = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
            // nothing to assign
        else{
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Task Time Usage: " <<  ((float)(clock() - start))/CLOCKS_PER_SEC <<endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: "<< env->new_tasks.size() <<  endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// (10) 以task pickup为圆心，agent-task为半径朝向task画出一个圆，位于这个圆内的other agent当前位置和目标点位置的中点的计入拥堵系数。为了量纲相等还要乘以|at|。jam = cost<ao,at> * |at| / |ao| = inner(ao, at) / inner(ao, ao) if |to| < |at|; =0, otherwise
void TaskScheduler::adaptive_jam_task_circle_vector_middle_current_goal(int time_limit, std::vector<int> & proposed_schedule)
{
    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for(auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                 << " minDist " << agent_task[element].min_task_dist
                 << " heuristic " << agent_task[element].task_heuristic
                 << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                 << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if(numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;
        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            // check for timeout every 10 task evaluations
            if (std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            double sum_jam_weight = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations){
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            /*
            if(OneDim2TwoDim.find(env->task_pool[t_id].locations[0]) == OneDim2TwoDim.end())
            {
                cerr << "map error!" << endl;
            }
            */

            int pickup_loc = env->task_pool[t_id].locations[0];
            int pickup_loc_x = env->task_pool[t_id].locations[0] % env->cols;
            int pickup_loc_y = env->task_pool[t_id].locations[0] / env->cols;
            // cout << "pickup loc " << pickup_twodim.x << " " << pickup_twodim.y << endl;

            // 当前agent指向某个任务的向量
            int agent_task_direction_x = pickup_loc_x - agent_loc_x;
            int agent_task_direction_y = pickup_loc_y - agent_loc_y;
            int agent_task_direction_square = agent_task_direction_x * agent_task_direction_x +
                                              agent_task_direction_y * agent_task_direction_y;

            for(int j=0;j<env->goal_locations.size();j++)
            {
                if (j != i && !env->goal_locations[j].empty()) // 所有agent都会有任务, 所以都要计入
                {
                    int other_agent_loc = env->curr_states.at(j).location;
                    int other_agent_loc_x = other_agent_loc % env->cols;
                    int other_agent_loc_y = other_agent_loc / env->cols;

                    int other_agent_goal = env->goal_locations[j][0].first;
                    int other_agent_goal_x = other_agent_goal % env->cols;
                    int other_agent_goal_y = other_agent_goal / env->cols;
                    // cout << "other agent goal " << other_agent_goal << " " << other_agent_goal_x << " "
                    // << other_agent_goal_y << endl;

                    // 其他agent当前位置和目标点位置的中点
                    int other_agent_middle_x = (other_agent_loc_x + other_agent_goal_x) / 2;
                    int other_agent_middle_y = (other_agent_loc_y + other_agent_goal_y) / 2;

                    // 当前agent指向其他agent当前位置和目标点中点的向量
                    int agent_middle_direction_x = other_agent_middle_x - agent_loc_x;
                    int agent_middle_direction_y = other_agent_middle_y - agent_loc_y;
                    // cout << "other agent direction " << agent_other_direction_x << " " << other_agent_loc_y << endl;
                    int agent_middle_distance_square = agent_middle_direction_x * agent_middle_direction_x
                                                      + agent_middle_direction_y * agent_middle_direction_y;

                    // 其他agent当前位置和目标点中点指向任务点的向量
                    int middle_task_direction_x = pickup_loc_x - other_agent_goal_x;
                    int middle_task_direction_y = pickup_loc_y - other_agent_goal_y;
                    // cout << "other agent direction " << agent_other_direction_x << " " << other_agent_loc_y << endl;
                    int middle_task_distance_square = middle_task_direction_x * middle_task_direction_x
                                                     + middle_task_direction_y * middle_task_direction_y;

                    // 只统计以task为圆心, agent-task范围内的other agent当前位置和目标点的中点
                    if(middle_task_distance_square < agent_task_direction_square)
                    {
                        int inner_product = agent_middle_direction_x * agent_task_direction_x
                                            + agent_middle_direction_y * agent_task_direction_y;

                        // cout << "task direction: " << agent_task_direction_x << " " << agent_task_direction_y << " "
                        // << task_direction_length << endl;

                        sum_jam_weight += double (inner_product) / agent_middle_distance_square;
                    }
                }
            }

            // sum_jam_weight * jam_coefficient = guess delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic){
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1){
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist  = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
            // nothing to assign
        else{
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Time Usage: " <<  ((float)(clock() - start))/CLOCKS_PER_SEC <<endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: "<< env->new_tasks.size() <<  endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}


// compute pickup jam by counting whether other agent-task line intersect with this agent-task line
[[nodiscard]] int TaskScheduler::compute_jam_curr_pickup_intersect_curr_goal(int _agent_id,
                                                                 Point _agent_loc, Point _agent_end)
{
    int sum_jam_weight = 0;

    // cout << "pickup loc " << pickup_twodim.x << " " << pickup_twodim.y << endl;

    for(int j=0;j<env->goal_locations.size();j++)
    {
        if (j != _agent_id && !env->goal_locations[j].empty()) // only consider the agent with goals
        {
            int other_agent_loc = env->curr_states.at(j).location;
            Point other_agent_start{other_agent_loc % env->cols, other_agent_loc / env->cols};

            int other_agent_goal = env->goal_locations[j][0].first;
            Point other_agent_end{other_agent_goal % env->cols, other_agent_goal / env->cols};
            // cout << "other agent goal " << other_agent_goal << " " << other_agent_goal_x << " "
            // << other_agent_goal_y << endl;

            // 统计other agent和它目标点的连线与agent-pickup连线发生交叉的数量
            if(isIntersecting(_agent_loc, _agent_end, other_agent_start, other_agent_end))
            {
                // cout << "task direction: " << agent_task_direction_x << " " << agent_task_direction_y << " "
                // << task_direction_length << endl;

                sum_jam_weight++;
            }
        }
    }

    return sum_jam_weight;
}

// 11: compute pickup jam by counting whether other agent-task line intersect with this agent-task line
void TaskScheduler::adaptive_jam_curr_pickup_intersect_curr_goal(int time_limit, std::vector<int> & proposed_schedule)
{
    // test whether two vectors intersect or not
    /*
    Point startA{0, 0};
    Point endA{0, 2};
    Point startB{2, 0};
    Point endB{2, 2};
    cout << "is intersect: " << isIntersecting(startA, endA, startB, endB) << endl;
     （*/

    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for(auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                 << " minDist " << agent_task[element].min_task_dist
                 << " heuristic " << agent_task[element].task_heuristic
                 << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                 << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if(numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        int agent_loc = env->curr_states.at(i).location;
        Point agent_point{agent_loc % env->cols, agent_loc / env->cols};
        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            // check for timeout every 10 task evaluations
            if (count % 10 == 0 && std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations){
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            int pickup_loc = env->task_pool[t_id].locations[0];
            Point pickup_point{pickup_loc % env->cols, pickup_loc / env->cols};
            int sum_jam_weight = compute_jam_curr_pickup_intersect_curr_goal(i,
                                                                             agent_point,
                                                                             pickup_point);

            // sum_jam_weight * jam_coefficient = guess delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic){
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1){
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist  = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
            // nothing to assign
        else{
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Time Usage: " <<  ((float)(clock() - start))/CLOCKS_PER_SEC <<endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: "<< env->new_tasks.size() <<  endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 11.-1: 来不及做的任务就不接了
void TaskScheduler::adaptive_jam_curr_pickup_intersect_curr_goal_not_get(int time_limit, std::vector<int>& proposed_schedule)
{
    cout << "adaptive jam curr pickup intersect curr goal not get" << endl;

    // test whether two vectors intersect or not
    /*
    Point startA{0, 0};
    Point endA{0, 2};
    Point startB{2, 0};
    Point endB{2, 2};
    cout << "is intersect: " << isIntersecting(startA, endA, startB, endB) << endl;
     （*/

     // use at most half of time_limit to compute schedule, -10 for timing error tolerance
     // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            /*
            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;
                */
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        int agent_loc = env->curr_states.at(i).location;
        Point agent_point{ agent_loc % env->cols, agent_loc / env->cols };
        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            // check for timeout every 10 task evaluations
            if (count % 10 == 0 && std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations) {
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            int pickup_loc = env->task_pool[t_id].locations[0];
            Point pickup_point{ pickup_loc % env->cols, pickup_loc / env->cols };
            int sum_jam_weight = compute_jam_curr_pickup_intersect_curr_goal(i,
                agent_point,
                pickup_point);

            // sum_jam_weight * jam_coefficient = guess delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic) {
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1 && min_task_dist < 4995 - env->curr_timestep)
        {
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
        // nothing to assign
        else {
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 11.0: 一次性把加和做完
void TaskScheduler::adaptive_jam_curr_pickup_intersect_curr_goal_at_once(int time_limit, std::vector<int>& proposed_schedule)
{
    cout << "adaptive jam curr pickup intersect curr goal at once" << endl;
    // test whether two vectors intersect or not
    /*
    Point startA{0, 0};
    Point endA{0, 2};
    Point startB{2, 0};
    Point endB{2, 2};
    cout << "is intersect: " << isIntersecting(startA, endA, startB, endB) << endl;
     （*/

     // use at most half of time_limit to compute schedule, -10 for timing error tolerance
     // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // 在开始前一口气把新任务长度算完
    for (const int& new_task_id : env->new_tasks)
    {
        // this task distance has been calculated
        int total_dist = 0;
        int curr_loc = env->task_pool[new_task_id].locations[0];

        // iterate over the locations (errands) of the task to compute the makespan to finish the task
        // makespan: the time for the agent to complete all the errands of the task t_id in order
        for (int loc : env->task_pool[new_task_id].locations)
        {
            total_dist += DefaultPlanner::get_h(env, curr_loc, loc);
            curr_loc = loc;
        }

        task_distances[new_task_id] = total_dist;
        // cout << counter << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        int agent_loc = env->curr_states.at(i).location;
        Point agent_point{ agent_loc % env->cols, agent_loc / env->cols };
        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            // check for timeout every 10 task evaluations
            if (count % 10 == 0 && std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations) {
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                dist += task_distances[t_id];
                c_loc = loc;
                break;
            }

            int pickup_loc = env->task_pool[t_id].locations[0];
            Point pickup_point{ pickup_loc % env->cols, pickup_loc / env->cols };
            int sum_jam_weight = compute_jam_curr_pickup_intersect_curr_goal(i,
                agent_point,
                pickup_point);

            // sum_jam_weight * jam_coefficient = guess delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic) {
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1) {
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
        // nothing to assign
        else {
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 11.0.-2: 来不及接的任务就不接了
void TaskScheduler::adaptive_jam_curr_pickup_intersect_curr_goal_at_once_not_get(int time_limit, std::vector<int>& proposed_schedule)
{
    cout << "adaptive jam curr pickup intersect curr goal at once not get" << endl;
    // test whether two vectors intersect or not
    /*
    Point startA{0, 0};
    Point endA{0, 2};
    Point startB{2, 0};
    Point endB{2, 2};
    cout << "is intersect: " << isIntersecting(startA, endA, startB, endB) << endl;
     （*/

     // use at most half of time_limit to compute schedule, -10 for timing error tolerance
     // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // 在开始前一口气把新任务长度算完
    for (const int& new_task_id : env->new_tasks)
    {
        // this task distance has been calculated
        int total_dist = 0;
        int curr_loc = env->task_pool[new_task_id].locations[0];

        // iterate over the locations (errands) of the task to compute the makespan to finish the task
        // makespan: the time for the agent to complete all the errands of the task t_id in order
        for (int loc : env->task_pool[new_task_id].locations)
        {
            total_dist += DefaultPlanner::get_h(env, curr_loc, loc);
            curr_loc = loc;
        }

        task_distances[new_task_id] = total_dist;
        // cout << counter << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        int agent_loc = env->curr_states.at(i).location;
        Point agent_point{ agent_loc % env->cols, agent_loc / env->cols };
        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            // check for timeout every 10 task evaluations
            if (count % 10 == 0 && std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations) {
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                dist += task_distances[t_id];
                c_loc = loc;
                break;
            }

            int pickup_loc = env->task_pool[t_id].locations[0];
            Point pickup_point{ pickup_loc % env->cols, pickup_loc / env->cols };
            int sum_jam_weight = compute_jam_curr_pickup_intersect_curr_goal(i,
                agent_point,
                pickup_point);

            // sum_jam_weight * jam_coefficient = guess delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic) {
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1 && min_task_dist < 5000 - env->curr_timestep)
        {
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
        // nothing to assign
        else {
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// compute pickup jam by counting whether other agent-task line intersect with this agent-task line
[[nodiscard]] int TaskScheduler::compute_jam_vector_curr_pickup_intersect_curr_goal(int _agent_id,
    Point _agent_loc, Point _agent_end)
{
    int sum_jam_weight = 0;

    // cout << "pickup loc " << pickup_twodim.x << " " << pickup_twodim.y << endl;

    for (int j = 0; j < env->goal_locations.size(); j++)
    {
        if (j != _agent_id && !env->goal_locations[j].empty()) // only consider the agent with goals
        {
            int other_agent_loc = env->curr_states.at(j).location;
            Point other_agent_start{ other_agent_loc % env->cols, other_agent_loc / env->cols };

            int other_agent_goal = env->goal_locations[j][0].first;
            Point other_agent_end{ other_agent_goal % env->cols, other_agent_goal / env->cols };
            // cout << "other agent goal " << other_agent_goal << " " << other_agent_goal_x << " "
            // << other_agent_goal_y << endl;

            // 统计other agent和它目标点的连线与agent-pickup连线发生交叉的数量
            if (isIntersecting(_agent_loc, _agent_end, other_agent_start, other_agent_end))
            {
                // cout << "task direction: " << agent_task_direction_x << " " << agent_task_direction_y << " "
                // << task_direction_length << endl;

                // cout << "angle type: " << angleType(_agent_loc, _agent_end, other_agent_start, other_agent_end) << endl;

                sum_jam_weight += angleType(_agent_loc, _agent_end, other_agent_start, other_agent_end);
            }
        }
    }

    return sum_jam_weight;
}

// 11.0.1: 锐角夹角加一，钝角夹角加二
void TaskScheduler::adaptive_jam_vector_curr_pickup_intersect_curr_goal_at_once(int time_limit, std::vector<int>& proposed_schedule)
{
    cout << "adaptive jam vector curr pickup intersect curr goal at once" << endl;
    // test whether two vectors intersect or not
    /*
    Point startA{0, 0};
    Point endA{0, 2};
    Point startB{2, 0};
    Point endB{2, 2};
    cout << "is intersect: " << isIntersecting(startA, endA, startB, endB) << endl;
     （*/

     // use at most half of time_limit to compute schedule, -10 for timing error tolerance
     // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // 在开始前一口气把新任务长度算完
    for (const int& new_task_id : env->new_tasks)
    {
        // this task distance has been calculated
        int total_dist = 0;
        int curr_loc = env->task_pool[new_task_id].locations[0];

        // iterate over the locations (errands) of the task to compute the makespan to finish the task
        // makespan: the time for the agent to complete all the errands of the task t_id in order
        for (int loc : env->task_pool[new_task_id].locations)
        {
            total_dist += DefaultPlanner::get_h(env, curr_loc, loc);
            curr_loc = loc;
        }

        task_distances[new_task_id] = total_dist;
        // cout << counter << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        int agent_loc = env->curr_states.at(i).location;
        Point agent_point{ agent_loc % env->cols, agent_loc / env->cols };
        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            // check for timeout every 10 task evaluations
            if (count % 10 == 0 && std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations) {
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                dist += task_distances[t_id];
                c_loc = loc;
                break;
            }

            int pickup_loc = env->task_pool[t_id].locations[0];
            Point pickup_point{ pickup_loc % env->cols, pickup_loc / env->cols };
            int sum_jam_weight = compute_jam_vector_curr_pickup_intersect_curr_goal(i,
                agent_point,
                pickup_point);

            // sum_jam_weight * jam_coefficient = guess delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic) {
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1) {
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
        // nothing to assign
        else {
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// 11.1: 用adaptive_jam_task_circle_count_current预分配
void TaskScheduler::adaptive_jam_curr_pickup_intersect_curr_goal_preassign(int time_limit, std::vector<int>& proposed_schedule)
{
    cout << "adaptive jam curr pickup intersect curr goal preassign" << endl;
    // test whether two vectors intersect or not
    /*
    Point startA{0, 0};
    Point endA{0, 2};
    Point startB{2, 0};
    Point endB{2, 2};
    cout << "is intersect: " << isIntersecting(startA, endA, startB, endB) << endl;
     （*/

     // use at most half of time_limit to compute schedule, -10 for timing error tolerance
     // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    if (free_agents.size() > 1000)
    {
        adaptive_jam_task_circle_count_current_without_newtask(time_limit, proposed_schedule);
        return;
    }

    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        int agent_loc = env->curr_states.at(i).location;
        Point agent_point{ agent_loc % env->cols, agent_loc / env->cols };
        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            // check for timeout every 10 task evaluations
            if (count % 10 == 0 && std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations) {
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            int pickup_loc = env->task_pool[t_id].locations[0];
            Point pickup_point{ pickup_loc % env->cols, pickup_loc / env->cols };
            int sum_jam_weight = compute_jam_curr_pickup_intersect_curr_goal(i,
                agent_point,
                pickup_point);

            // sum_jam_weight * jam_coefficient = guess delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic) {
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1) {
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
        // nothing to assign
        else {
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}


// 11.2: compute pickup jam by counting whether other agent-task line intersect with this agent-task line density
void TaskScheduler::adaptive_jam_curr_pickup_intersect_curr_goal_density(int time_limit, std::vector<int>& proposed_schedule)
{
    cout << "adaptive jam curr pickup intersect curr goal density" << endl;
    // test whether two vectors intersect or not
    /*
    Point startA{0, 0};
    Point endA{0, 2};
    Point startB{2, 0};
    Point endB{2, 2};
    cout << "is intersect: " << isIntersecting(startA, endA, startB, endB) << endl;
     （*/

     // use at most half of time_limit to compute schedule, -10 for timing error tolerance
     // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout<<"schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for (auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                << " minDist " << agent_task[element].min_task_dist
                << " heuristic " << agent_task[element].task_heuristic
                << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if (numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    // Step 1: 统计每个区域agent的数量。
    // 因为intersect已经计算过了, 这里就不计算了。
    /*
    small_region_wait_num.assign(small_region_wait_num.size(), 0); // 每次清空

    for (int i = 0; i < env->num_of_agents; i++)
    {
        int agent_loc = env->curr_states.at(i).location;
        int agent_loc_x = agent_loc % env->cols;
        int agent_loc_y = agent_loc / env->cols;

        int agent_region_x = agent_loc_x / small_region_column;
        int agent_region_y = agent_loc_y / small_region_row;

        small_region_wait_num[agent_region_y * num_small_region_column + agent_region_x]++;
    }
    */

    /*
    cout << "region agent num: ";
    for(int i : small_region_wait_num)
    {
        cout << i << " ";
    }
    cout << endl;
     //*/

    // Step 2: 计算每个task归属于哪个区域。
    for (int t_id : env->new_tasks)
    {
        int pickup_loc = env->task_pool[t_id].locations[0];
        int pickup_loc_x = pickup_loc % env->cols;
        int pickup_loc_y = pickup_loc / env->cols;

        int pickup_region_x = pickup_loc_x / small_region_column;
        int pickup_region_y = pickup_loc_y / small_region_row;

        task_region[t_id] = pickup_region_y * num_small_region_column + pickup_region_x;
    }

    /*
    for (const auto& pair : task_region)
    {
        std::cout << "Task ID: " << pair.first << " -> pickup regions: " << pair.second << endl;
    }
    //*/

    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        int agent_loc = env->curr_states.at(i).location;
        Point agent_point{ agent_loc % env->cols, agent_loc / env->cols };
        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            // check for timeout every 10 task evaluations
            if (count % 10 == 0 && std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations) {
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            int pickup_loc = env->task_pool[t_id].locations[0];
            Point pickup_point{ pickup_loc % env->cols, pickup_loc / env->cols };
            int sum_jam_intersect = compute_jam_curr_pickup_intersect_curr_goal(i,
                agent_point,
                pickup_point);

            int pickup_region_blank_num = small_region_blank_num[task_region[t_id]];
            // cout << "pickup_region_blank_num: " << pickup_region_blank_num << endl;

            double sum_jam_weight = static_cast<double>(sum_jam_intersect) / pickup_region_blank_num;
            // cout << "sum jam weight: " << sum_jam_weight << endl;

            // sum_jam_weight * jam_coefficient = guess delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic) {
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1) {
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
        // nothing to assign
        else {
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Time Usage: " << ((float)(clock() - start)) / CLOCKS_PER_SEC << endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: " << env->new_tasks.size() << endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}


void TaskScheduler::adaptive_jam_curr_pickup_delivery_intersect_curr_goal(int time_limit,
                                                              std::vector<int> & proposed_schedule)
{
    // test whether two vectors intersect or not
    /*
    Point startA{0, 0};
    Point endA{0, 2};
    Point startB{2, 0};
    Point endB{2, 2};
    cout << "is intersect: " << isIntersecting(startA, endA, startB, endB) << endl;
     （*/

    // use at most half of time_limit to compute schedule, -10 for timing error tolerance
    // so that the remaining time are left for path planner
    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);
    // cout << "schedule plan limit" << time_limit <<endl;

    // cout << "task pool size " << env->task_pool.size() << endl;

    //*
    for(auto const& element : env->new_freeagents)
    {
        agent_task[element].complete_moment = env->curr_timestep;

        if (agent_task[element].task_id != -1)
        {
            numTaskFinished++;
            /*
            FinishedTask temp;
            temp.task_id = agent_task[element].task_id;
            temp.min_task_dist = agent_task[element].min_task_dist;
            temp.jam_when_assign = agent_task[element].jam_when_assign;
            temp.heuristic_duration = agent_task[element].task_heuristic;
            temp.real_duration = agent_task[element].complete_moment - agent_task[element].assign_moment;
            finished_tasks.emplace_back(temp);
             */

            total_min_span += agent_task[element].min_task_dist;
            total_real_duration += agent_task[element].complete_moment - agent_task[element].assign_moment;
            total_jam += agent_task[element].jam_when_assign;

            cout << "complete task " << agent_task[element].task_id
                 << " minDist " << agent_task[element].min_task_dist
                 << " heuristic " << agent_task[element].task_heuristic
                 << " real " << agent_task[element].complete_moment - agent_task[element].assign_moment
                 << " jam " << agent_task[element].jam_when_assign << endl;
        }

        agent_task[element].task_id = -1;
    }
    //*/

    if(numTaskFinished > 0 && total_jam > 0)
    {
        jam_coefficient = (total_real_duration - total_min_span) / total_jam;
        cout << "current jam coefficient: " << jam_coefficient << endl;
    }

    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps
    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());
    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());

    cout << "free agent num: " << free_agents.size() << endl;
    // cout << "free task num: " << free_tasks.size() << endl;

    int min_task_i, dist, c_loc, count;
    clock_t start = clock();

    // iterate over the free agents to decide which task to assign to each of them
    auto it = free_agents.begin();
    while (it != free_agents.end())
    {
        // keep assigning until timeout
        if (std::chrono::steady_clock::now() > endtime)
        {
            break;
        }
        int i = *it;

        assert(env->curr_task_schedule[i] == -1);

        min_task_i = -1;
        int min_task_dist = INT_MAX; // 完成该任务的理论时间下界
        double min_task_heuristic = DBL_MAX;
        double corresponding_traffic_jam = DBL_MAX;
        count = 0;

        int agent_loc = env->curr_states.at(i).location;
        Point agent_point{agent_loc % env->cols, agent_loc / env->cols};
        // cout << "agent loc " << agent_twodim.x << " " << agent_twodim.y << endl;

        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i
        for (int t_id : free_tasks)
        {
            // check for timeout every 10 task evaluations
            if (count % 10 == 0 && std::chrono::steady_clock::now() > endtime)
            {
                break;
            }
            dist = 0;
            c_loc = env->curr_states.at(i).location;

            // iterate over the locations (errands) of the task to compute the makespan to finish the task
            // makespan: the time for the agent to complete all the errands of the task t_id in order
            for (int loc : env->task_pool[t_id].locations){
                dist += DefaultPlanner::get_h(env, c_loc, loc);
                c_loc = loc;
            }

            /*
            if(OneDim2TwoDim.find(env->task_pool[t_id].locations[0]) == OneDim2TwoDim.end())
            {
                cerr << "map error!" << endl;
            }
            */

            int pickup_loc = env->task_pool[t_id].locations[0];
            Point pickup_point{pickup_loc % env->cols, pickup_loc / env->cols};
            int delivery_loc = env->task_pool[t_id].locations[1];
            Point delivery_point{delivery_loc % env->cols, delivery_loc / env->cols};
            int sum_jam_weight = compute_jam_curr_pickup_intersect_curr_goal(i,
                                             agent_point, pickup_point)
                                + compute_jam_curr_pickup_intersect_curr_goal(i,
                                               pickup_point, delivery_point);

            // sum_jam_weight * jam_coefficient = guess delay time
            if (dist + sum_jam_weight * jam_coefficient < min_task_heuristic){
                min_task_i = t_id;
                min_task_dist = dist;
                min_task_heuristic = dist + sum_jam_weight * jam_coefficient;
                corresponding_traffic_jam = sum_jam_weight;
            }
            count++;
        }

        // assign the best free task to the agent i (assuming one exists)
        if (min_task_i != -1){
            proposed_schedule[i] = min_task_i;
            it = free_agents.erase(it);
            free_tasks.erase(min_task_i);
            agent_task[i].task_id = min_task_i;
            agent_task[i].min_task_dist  = min_task_dist;
            agent_task[i].task_heuristic = min_task_heuristic;
            agent_task[i].assign_moment = env->curr_timestep; // assign task moment
            agent_task[i].jam_when_assign = corresponding_traffic_jam;
        }
            // nothing to assign
        else{
            proposed_schedule[i] = -1;
            it++;
        }
    }

    cout << "Time Usage: " <<  ((float)(clock() - start))/CLOCKS_PER_SEC <<endl;
#ifndef NDEBUG
    cout << "new free agents: " << env->new_freeagents.size() << " new tasks: "<< env->new_tasks.size() <<  endl;
    cout << "free agents: " << free_agents.size() << " free tasks: " << free_tasks.size() << endl;
#endif
}

// RHCR functions
MAPFSolver* TaskScheduler::set_solver(const BasicGraph& G, const boost::program_options::variables_map& vm)
{
    string solver_name = vm["single_agent_solver"].as<string>();
    SingleAgentSolver* path_planner;
    MAPFSolver* mapf_solver;
    if (solver_name == "ASTAR")
    {
        path_planner = new StateTimeAStar();
    }
    else if (solver_name == "SIPP")
    {
        path_planner = new SIPP();
    }
    else
    {
        cout << "Single-agent solver " << solver_name << "does not exist!" << endl;
        exit(-1);
    }

    solver_name = vm["solver"].as<string>();
    if (solver_name == "ECBS")
    {
        ECBS* ecbs = new ECBS(G, *path_planner);
        ecbs->potential_function = vm["potential_function"].as<string>();
        ecbs->potential_threshold = vm["potential_threshold"].as<double>();
        ecbs->suboptimal_bound = vm["suboptimal_bound"].as<double>();
        mapf_solver = ecbs;
    }
    else if (solver_name == "PBS")
    {
        PBS* pbs = new PBS(G, *path_planner);
        pbs->lazyPriority = vm["lazyP"].as<bool>();
        auto prioritize_start = vm["prioritize_start"].as<bool>();
        if (vm["hold_endpoints"].as<bool>() || vm["dummy_paths"].as<bool>())
            prioritize_start = false;
        pbs->prioritize_start = prioritize_start;
        pbs->setRT(vm["CAT"].as<bool>(), prioritize_start);
        mapf_solver = pbs;
    }
    else if (solver_name == "WHCA")
    {
        mapf_solver = new WHCAStar(G, *path_planner);
    }
    else if (solver_name == "LRA")
    {
        mapf_solver = new LRAStar(G, *path_planner);
    }
    else
    {
        cout << "Solver " << solver_name << "does not exist!" << endl;
        exit(-1);
    }

    if (vm["id"].as<bool>())
    {
        return new ID(G, *path_planner, *mapf_solver);
    }
    else
    {
        return mapf_solver;
    }
}

void TaskScheduler::set_parameters(BasicSystem& system, const boost::program_options::variables_map& vm)
{
    system.outfile = vm["output"].as<std::string>();
    system.screen = vm["screen"].as<int>();
    system.log = vm["log"].as<bool>();
    system.num_of_drives = vm["agentNum"].as<int>();
    system.time_limit = vm["cutoffTime"].as<int>();
    system.simulation_window = vm["simulation_window"].as<int>();
    system.planning_window = vm["planning_window"].as<int>();
    system.travel_time_window = vm["travel_time_window"].as<int>();
    system.consider_rotation = vm["rotation"].as<bool>();
    system.k_robust = vm["robust"].as<int>();
    system.hold_endpoints = vm["hold_endpoints"].as<bool>(); // 如果只plan一步, 不用担心hold endpoints
    system.useDummyPaths = vm["dummy_paths"].as<bool>();
    if (vm.count("seed"))
        system.seed = vm["seed"].as<int>();
    else
        system.seed = (int)time(0);
    srand(system.seed);
}